{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Build","text":""},{"location":"#algobulls","title":"AlgoBulls","text":"<p>Welcome to AlgoBulls, the AI-powered trading platform that unlocks new dimensions in algorithmic trading. Our mission is to boost your expertise in designing and executing personalised trading strategies using our cutting-edge product - Python Build. </p>"},{"location":"#introducing-python-build-your-gateway-to-algorithmic-trading","title":"Introducing Python Build: Your Gateway to Algorithmic Trading","text":"<p>Python Build is your ultimate companion for crafting and executing trading strategies with the precision of a seasoned professional. Designed for both experienced traders and newcomers, this platform offers a range of powerful tools that empower you to make well-informed decisions and trade confidently in dynamic financial markets.</p> <p>When it comes to strategy development, Python Build lets you dive into coding, backtesting, and deploying your trading strategies with remarkable ease. With an intuitive interface, you gain the ability to precisely set entry and exit points, handle multiple instruments, and take actions based on informed insights.</p> <p></p> <p>What sets Python Build apart is its adaptable strategy format, suitable for various trading styles. Whether you're into backtesting, paper trading, or live trading, the same strategy code works for all three, making the experience straightforward.</p> <p>The library covers all scenarios (backtesting, paper trading, and live trading) during strategy execution or generating analytics. This unified approach ensures seamless transitions between these modes, eliminating the need for complex adjustments. Additionally, it simplifies the creation of progress logs, helping you track your journey and anticipate completion times. For real-time updates, live logs are available too, offering transparency and control over your trading endeavours.</p> <p></p> <p>Python Build's strength lies in its seamless integration with real-time market data sources, historical data, and trading platforms. Its adaptable nature enables connection with various data providers and broker APIs, ensuring access to the information you need for well-informed trading decisions.</p>"},{"location":"#powerful-stats-visual-analytics","title":"Powerful Stats &amp; Visual Analytics","text":"<p>In the pursuit of successful trading, Python Build equips you with advanced visual tools for strategy analytics. These tools provide a deeper understanding of your strategies' performance, helping you manage risks and fine-tune your plans for optimal success. Visualisations facilitate data-driven decision-making, giving you clearer insights into the intricacies of your trading activities.</p>"},{"location":"#multiple-platforms-to-use-python-build","title":"Multiple Platforms to use Python Build","text":"<p>To support our diverse community of users, we have the options of two dynamic platforms for our users to use Python Build - pyalgotrading and Python Build Web</p> <p>Explore our Python Package: Pyalgotrading</p> <p>Dive into the amazing Features of our Web-App: Python Build Web</p>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>AlgoBulls is more than just a platform; it's a community. Connect, learn, and collaborate with traders and developers. Code your strategies or explore ours \u2013 AlgoBulls is where innovation meets trading expertise.</p> <p>By becoming part of the Python Build community, you tap into a rich network of traders and developers. This community serves as a platform for collaboration, offering guidance, valuable insights, and collective refinement of trading strategies. Diverse perspectives help you approach trading challenges from multiple angles, fostering growth and improvement.</p> <p>Join us in this journey as AlgoBulls revolutionizes algorithmic trading!</p> <p>In essence, Python Build is more than a product; it's your comprehensive guide to mastering algorithmic trading. With its user-friendly interface, diverse functionalities, and seamless integration, it's a valuable asset for traders of all levels. By simplifying strategy crafting, integration, execution, and analysis, Python Build empowers you to navigate the trading world with confidence and precision.</p>"},{"location":"#open-source-strategy-library","title":"Open Source Strategy Library","text":"<p>We maintain an open source GitHub repository, pyalgostrategypool containing fully functional algorithmic trading strategies. These strategies can be used for Backtesting, Paper Trading, or Live Trading across various brokers and exchanges. The same code works in all trading modes.</p> <p>Keep an eye on our GitHub repo</p> <p>Our team periodically updates the library to add more strategy Python codes</p> <p>For those new to algorithmic trading or Python Build, exploring included example strategies is an excellent starting point. These strategies are pre-built scenarios showcasing different trading strategies and concepts. By studying and experimenting with these examples, you'll gain a deeper grasp of how Python Build operates and how strategies are constructed.</p> <p>Here's what you can do with the example strategies:</p> <ul> <li>Analyze Structure: Study code structure, including strategy definition, condition setting, and action execution.</li> <li> <p>Modify and Experiment: Once comfortable with examples, customise them to your preferences. Adjust parameters, conditions, and actions to observe their impact on trading outcomes.</p> </li> <li> <p>Learn Strategies: Each example represents a different trading approach, like trend-following or mean-reversion. Studying these examples introduces you to various trading strategies and their underlying principles.</p> </li> </ul> <p>Remember, these example strategies lay the foundation for your learning journey. As you grow more familiar with the library, you can create and customise your own strategies based on your insights and preferences.</p> <p>To conclude, the installation process readies you to use Python Build, while the documentation and example strategies empower you to explore the library's capabilities and apply them to real trading situations. Whether you're a beginner or a seasoned trader...</p>"},{"location":"#limitations-of-python-build","title":"Limitations of Python Build","text":"<p>In the exciting world of algorithmic trading, Python Build offers numerous benefits and considerations for traders and developers. Let's also acknowledge its limitations to help you make an informed decision.</p> <p> </p> <ol> <li> <p>Python Speed Limitations:  While versatile, Python isn't the fastest language for computation. This may pose challenges for complex strategies requiring extensive calculations. Our team is actively transitioning a major part of the codebase to Cython to enhance speed while retaining Python's simplicity. We're also exploring options like GPUs for the future.</p> </li> <li> <p>Cloud Cold-Start Speed Limitations: Each strategy runs on a dedicated virtual server in the cloud. While this ensures secure execution with dedicated resources, there's a short delay as the cloud fetches the resource before strategy execution begins. This minor delay is part of our ongoing optimization efforts.</p> </li> </ol> <p>Note</p> <p>Our team is working round the clock to make these limitations a thing of the past.</p>"},{"location":"#references","title":"References","text":"<p>To unleash Python Build's full potential, dive into its comprehensive documentation. This roadmap offers detailed insights into the product's features, functionalities, and capabilities. It's your go-to resource for harnessing the power of Python Build effectively. The documentation includes:</p> <ul> <li>Code Examples: Real code snippets showcasing how to implement specific strategies, functions, and techniques using Python Build.</li> <li>Python Cookbook for Algorithmic Trading: A Python Cookbook for Algorithmic Trading, explaining in-depth about strategy creation and execution from scratch using Python. Explore the technical content of the book on GitHub.</li> </ul>"},{"location":"analytics/pyalgotrading_analytics/","title":"Pyalgotrading Analytics","text":""},{"location":"analytics/pyalgotrading_analytics/#metric-values-and-statistics","title":"Metric Values and Statistics","text":""},{"location":"analytics/pyalgotrading_analytics/#cumulative-returns","title":"Cumulative Returns","text":"<ul> <li>The Cumulative Returns chart illustrates how our strategy's returns value has evolved over time in percentage. </li> <li>Positive values indicate gains, while negatives reflect losses. Bigger positive returns are more favourable. </li> <li>Keep in mind, this chart focuses on gains and losses, excluding risk and timing considerations.</li> <li>There are 2 sub categories of cumulative returns chart depending on the scale we are using. One is normal scaled and other is log scaled </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#end-of-year-returns-eoy","title":"End of Year Returns (EoY)","text":"<ul> <li>The End of Year Returns chart showcases our strategy's annual performance as a percentage. </li> <li>It quantifies its overall performance, considering gains or losses throughout each year.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#distributions-of-monthly-returns-histogram","title":"Distributions of Monthly Returns (Histogram)","text":"<ul> <li>In the Monthly Returns Distribution Histogram, we see the frequency distribution of different levels of returns over consecutive months. </li> <li>This histogram helps us understand the range and patterns in monthly returns, shedding light on our strategy's volatility and performance trends.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#daily-returns","title":"Daily Returns","text":"<ul> <li>The Daily Returns Chart portrays the percentage change in our strategy's returns between trading days. </li> <li>It provides insights into short-term volatility, trend analysis, and risk assessment.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#rolling-volatility-6-months","title":"Rolling Volatility (6 months)","text":"<ul> <li>A Rolling Volatility (6 months) Plot showcases the changing volatility of an investment over time using a rolling window of six months. </li> <li>This plot reveals how the investment's price fluctuations vary as the window moves across the dataset. </li> <li>It provides insights into short-term volatility patterns, helping investors understand how the investment's risk level evolves in response to different market conditions.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#rolling-sharpe-6-months","title":"Rolling Sharpe (6 months)","text":"<ul> <li>A Rolling Sharpe (6 months) Plot illustrates the dynamic changes in the Sharpe ratio over time using a rolling window of six months. </li> <li>The plot shows how the risk-adjusted performance of an investment fluctuates as the window moves through the dataset. </li> <li>This visualization helps investors understand how the Sharpe ratio varies with changing market conditions and provides insights into the investment's consistency and risk-return trade-offs over short-term periods.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#rolling-sortino-6-months","title":"Rolling Sortino (6 months)","text":"<ul> <li>A Rolling Sortino (6 months) Plot visualizes the variation in the Sortino ratio over time using a rolling window of six months. </li> <li>This plot demonstrates how the investment's risk-adjusted performance, considering only downside volatility, changes as the window progresses through the data. </li> <li>It offers insights into how the Sortino ratio evolves with market conditions, helping investors assess the investment's ability to generate favorable risk-adjusted returns over short-term intervals.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#worst-5-drawdown-periods","title":"Worst 5 Drawdown Periods","text":"<ul> <li>A Worst 5 Drawdown Periods plot displays the top five periods during which the strategy experienced the largest declines from peak to trough. </li> <li>This visualization helps strategists understand the most significant loss-making episodes in the strategy's run. </li> <li>It shows the magnitude and duration of these drawdowns, providing insights into the strategy's risk and potential vulnerabilities.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#underwater-plot","title":"Underwater Plot","text":"<ul> <li>The Underwater Plot visually narrates our strategy's performance concerning its past peaks. </li> <li>It showcases how much our returns value has dropped from its highest point over time. </li> <li>This aids in visualising periods of drawdown and recovery, offering insights into historical risk and resilience.    </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#monthly-returns-heatmap","title":"Monthly Returns (Heatmap)","text":"<ul> <li>The Monthly Returns Heatmap offers a colour-coded view of our strategy's performance across months. </li> <li>Shades of green indicate positive returns, while shades of red signify losses. </li> <li>This visual tool helps spot trends and patterns, aiding in identifying strong and weak performance periods.    </li> </ul>"},{"location":"analytics/python-build-view-results/","title":"Python build view results","text":""},{"location":"analytics/python-build-view-results/#how-to-view-the-results","title":"How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can switch to the Analytics tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Analytics: In the analytics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p>"},{"location":"analytics/python-build-view-results/#stats","title":"Stats","text":"<p>In this section you can see the total returns, sharpe ratio, sortino ratio, volatility, Max Drawdown, Total wins or Loses, Total short or long trades, hit ratio, number of trades, average trades per day, max profit, max loss, average profit per winning trade, average loss per losing trade. </p>"},{"location":"analytics/python-build-view-results/#cumulative-returns","title":"Cumulative Returns","text":""},{"location":"analytics/python-build-view-results/#profit-loss-currency-or","title":"Profit &amp; Loss (Currency or %)","text":"<p>The trade by trade P&amp;L in Currency or Percentage. </p>"},{"location":"analytics/python-build-view-results/#end-of-year-returns-plot","title":"End of Year Returns Plot (%)","text":""},{"location":"analytics/python-build-view-results/#monthly-returns-histogram","title":"Monthly Returns Histogram (%)","text":""},{"location":"analytics/python-build-view-results/#monthly-returns-heatmap","title":"Monthly Returns Heatmap (%)","text":""},{"location":"analytics/python-build-view-results/#daily-returns","title":"Daily Returns (%)","text":""},{"location":"analytics/python-build-view-results/#underwater-drawdown-plot","title":"Underwater Drawdown Plot (%)","text":""},{"location":"analytics/python-build-view-results/#pl-book","title":"P&amp;L Book","text":"<p>View detailed trade by trade report. Premium users can analyze this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades. </p>"},{"location":"analytics/python-build-view-results/#user-log","title":"User Log","text":"<p>Real-time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behavior and performance. </p>"},{"location":"analytics/python-build-view-results/#order-history","title":"Order History","text":"<p>View the order state transition for every order placed by your strategy in-depth. </p>"},{"location":"brokers/broker_alpaca_guide/","title":"Alpaca","text":"<p>Alpaca is a technology company that offers a modern, developer-friendly trading platform designed for algorithmic and automated trading in the financial markets, particularly focused on equities and cryptocurrencies. The company provides APIs (Application Programming Interfaces) that allow developers and traders to access market data, execute trades, and build their own algorithmic trading strategies.</p> <p>Key features and offerings of Alpaca include:</p> <ol> <li> <p>APIs and SDKs: Alpaca offers APIs and software development kits (SDKs) that enable developers to programmatically access real-time and historical market data, as well as execute trades on various exchanges.</p> </li> <li> <p>Algorithmic Trading: Alpaca's platform is tailored for algorithmic trading strategies, where traders can automate trading decisions based on predefined conditions and rules.</p> </li> <li> <p>Paper Trading: Alpaca provides a simulated environment called \"paper trading,\" allowing traders to test their strategies in a risk-free setting before deploying them with real money.</p> </li> <li> <p>Market Data: The platform offers access to real-time and historical market data, which is crucial for building and testing trading strategies.</p> </li> <li> <p>Order Execution: Traders can use Alpaca's API to execute trades on supported exchanges. This includes submitting market, limit, and stop orders.</p> </li> <li> <p>Customizable Dashboards: Alpaca provides customizable dashboards and interfaces to monitor trading activity and portfolio performance.</p> </li> <li> <p>Brokerage Services: Alpaca acts as a brokerage, providing services that allow traders to execute their strategies on supported exchanges.</p> </li> <li> <p>Regulatory Compliance: Alpaca operates within the regulations of the financial industry, ensuring compliance with rules and requirements.</p> </li> </ol> <p>Alpaca's platform aims to democratize algorithmic trading by providing accessible tools and resources for both individual traders and developers. It's worth noting that the landscape of algorithmic trading and financial technology is constantly evolving, so it's a good idea to check Alpaca's official website for the most current information about their offerings and services.</p>"},{"location":"brokers/broker_alpaca_guide/#how-to-get-api-keys-for-trading-in-alpaca","title":"How to get API-keys for trading in Alpaca ?","text":""},{"location":"brokers/broker_alpaca_guide/#create-or-login-to-alpaca-account","title":"Create or Login to Alpaca Account","text":""},{"location":"brokers/broker_alpaca_guide/#go-to-home-page-of-your-account","title":"Go to Home Page of your Account","text":""},{"location":"brokers/broker_alpaca_guide/#view-api-keys-or-generate-api-keys","title":"View API keys or Generate API keys","text":""},{"location":"brokers/broker_alpaca_guide/#get-the-secret-key-and-api-key","title":"Get the <code>Secret-Key</code> and <code>API key</code>","text":""},{"location":"brokers/broker_alpaca_guide/#why-do-we-need-alpaca-account","title":"Why do we need Alpaca Account ?","text":"<p>If you want to run your strategy on American exchanges like NASDAQ or NYSE, you need access to the historical data as well as live data of all the stocks and that is provided by Alpaca. Besides this it will also be helpful to do live trading on AlgoBulls using these credentials.</p>"},{"location":"gen_ai/gen_ai_prompt_library/","title":"Prompt Library for Gen AI","text":""},{"location":"gen_ai/gen_ai_prompt_library/#here-are-some-prompts-for-creating-strategy-using-genai","title":"Here are some prompts for Creating Strategy using GenAI","text":""},{"location":"gen_ai/gen_ai_prompt_library/#moving-averages-ema-or-sma","title":"Moving Averages (EMA or SMA)","text":"<ul> <li>Create a trading strategy which takes a BUY trade when EMA cuts SMA upwards and a SELL trade when EMA cuts SMA downwards. While placing a trade, if a previous position is open, it should be exited before placing the new trade</li> <li>Create a strategy which uses 2 EMAs of different time periods, and it BUYs when EMA of timeperiod 1 crosses the EMA of timeperiod 2 upwards and SELLs when EMA of timeperiod 1 crosses the EMA of timeperiod 2 downwards.</li> <li>Create a trading strategy which takes a BUY trade when EMA cuts SMA upwards and a SELL trade when EMA cuts SMA downwards. While placing a trade, if a previous position is open, it should be exited before placing the new trade</li> <li>Develop a strategy that generates a BUY signal when a shorter-term moving average crosses above an intermediate-term moving average, which then crosses above a longer-term moving average. Conversely, generate a SELL signal when the moving averages crossover in the opposite direction.</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#relative-strength-index-rsi","title":"Relative Strength Index (RSI)","text":"<ul> <li>Create a strategy that uses RSI indicator to give signals based on over bought or over sold conditions. If RSI is above 70, the strategy should generate a SELL signal and if it's below 30, it should generate a BUY signal</li> <li>Create a strategy using RSI of MACD-signal of close with fast MA period as X, slow MA period as Y and signal period as Z, which will SELL on crossing the upper band and BUY on crossing the lower band</li> <li>Create a trading strategy which takes BUY when RSI crosses lower band and create a SELL when RSI crosses the upward band, set a stop loss of 2% and target to be 15%.</li> <li>Create a trading strategy using RSI technical indicator</li> <li>Create a strategy using RSI of MACD-signal of close with fast MA period as X, slow MA period as Y and signal period as Z, which will SELL on crossing the upper band and BUY on crossing the lower band</li> <li>Please help me with a strategy that uses RSI indicator to give signals based on over bought or over sold conditions. If RSI is above 70, the strategy should generate a SELL signal and if it's below 30, it should generate a BUY signal</li> <li>Create a trading strategy which takes BUY when RSI crosses lower band and create a SELL when RSI crosses the upward band, set a stop loss of 2% and target to be 15%.</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#aroon","title":"Aroon","text":"<ul> <li>Create a trading strategy that utilizes the Aroon indicator to generate signals based on overbought or oversold conditions. If the Aroon Up line crosses below the Aroon Down line and falls below 30, the strategy should generate a BUY signal. Conversely, if the Aroon Up line crosses above the Aroon Down line and rises above 70, the strategy should generate a SELL signal</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#stochastic","title":"Stochastic","text":"<ul> <li>Develop a trading strategy that incorporates the stochastic crossover to generate signals. When the %K line crosses above the %D line and both lines are below 30, the strategy should generate a BUY signal. Similarly, when the %K line crosses below the %D line and both lines are above 70, the strategy should generate a SELL signal</li> <li>Develop a strategy that generates a BUY signal when the Stochastic RSI indicator crosses above the oversold level (e.g., 20) and a SELL signal when it crosses below the overbought level (e.g., 80).</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#bollinger-bands-bb","title":"Bollinger Bands (BB)","text":"<ul> <li>Develop a strategy that generates a BUY signal when the price breaks above the upper Bollinger Band. Similarly, generate a SELL signal when the price breaks below the lower Bollinger Band</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#fibonacci","title":"Fibonacci","text":"<ul> <li>Develop a strategy that generates a BUY signal when the price retraces to a key Fibonacci level (e.g., 38.2% or 50%) and shows signs of reversal using other technical indicators. Similarly, generate a SELL signal when the price retraces to a Fibonacci level and shows signs of continuation in the prevailing trend</li> <li>Create a strategy that generates a BUY signal when the price retraces to a key Fibonacci level (e.g., 61.8%) and then extends beyond the previous swing high. Similarly, generate a SELL signal when the price retraces to a Fibonacci level and then extends beyond the previous swing low.</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#atr-volatility","title":"ATR (Volatility)","text":"<ul> <li>Develop a strategy that generates a BUY signal when the price surpasses a multiple of the ATR above a recent swing high, indicating increased volatility and potential upward momentum. Conversely, generate a SELL signal when the price drops below a multiple of the ATR below a recent swing low, indicating increased volatility and potential downward momentum.</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#moving-average-convergence-divergence-macd","title":"Moving Average Convergence Divergence (MACD)","text":"<ul> <li>Create a strategy that generates a BUY signal when the MACD histogram bars cross above the zero line and a SELL signal when the histogram bars cross below the zero line.</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#volume-weighted-average-price-vwap","title":"Volume Weighted Average Price (VWAP)","text":"<ul> <li>Create a strategy that generates a BUY signal when the price rises above the VWAP line and a SELL signal when the price drops below the VWAP line, indicating potential shifts in supply and demand.</li> </ul>"},{"location":"gen_ai/gen_ai_prompt_library/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Create a strategy that generates a BUY signal when the price crosses above the cloud (Span A and Span B) and the cloud changes color from red to green. Conversely, generate a SELL signal when the price crosses below the cloud and the cloud changes color from green to red.</li> <li>Create a strategy that generates a BUY signal when there is a significant increase in volume accompanied by a bullish candlestick pattern. Similarly, generate a SELL signal when there is a significant increase in volume accompanied by a bearish candlestick pattern</li> <li>Create a strategy that generates a BUY signal when the RVI indicator crosses above its signal line and a SELL signal when it crosses below its signal line, indicating potential changes in momentum.</li> <li>Create a strategy that generates a BUY signal when the price breaks above the upper pivot point level or a key resistance level and a SELL signal when the price breaks below the lower pivot point level or a key support level.</li> <li>Develop a strategy that generates a BUY signal when the price crosses above the Parabolic SAR dots and a SELL signal when the price crosses below the dots.</li> <li>Create a strategy that generates a BUY signal when a bullish harmonic pattern, such as a bullish butterfly or bullish Gartley, forms and validates with other technical indicators. Similarly, generate a SELL signal when a bearish harmonic pattern forms and validates.</li> <li>Create a strategy that generates a BUY signal when the price breaks above the upper Donchian Channel and a SELL signal when the price breaks below the lower Donchian Channel.</li> <li>Implement a gap and go strategy that capitalizes on the momentum created by price gaps at the market open. When the price gaps up significantly and continues to move higher, generate a BUY signal. Similarly, when the price gaps down substantially and continues to move lower, generate a SELL signal.</li> </ul>"},{"location":"gen_ai/get_open_ai_keys/","title":"OpenAI","text":""},{"location":"gen_ai/get_open_ai_keys/#what-is-chat-gpt","title":"What is Chat-GPT ?","text":"<p>Generative AI involves creating new content using machine learning. A key method is GANs, where a generator creates data and a discriminator evaluates its realism. Another method is VAEs, which encode and decode data. ChatGPT is a specific AI model using generative text, like a conversation. It can understand context, answer questions, and generate text in a human-like manner. It finds use in various fields, from text generation to customer service, but also raises concerns about accuracy and responsible use.</p>"},{"location":"gen_ai/get_open_ai_keys/#why-we-use-chat-gpt","title":"Why we use Chat-GPT ?","text":"<p>ChatGPT can assist in generating code for algorithmic trading strategies. It can translate strategy ideas into code snippets, provide coding guidance, and help with customization. However, human expertise is essential to validate, optimize, and manage risks in the complex realm of algorithmic trading.</p>"},{"location":"gen_ai/get_open_ai_keys/#how-to-get-chat-gpt-api-keys","title":"How to get Chat-GPT API keys ?","text":"<p>To get your chat GPT API keys, you can watch the video given below</p> <p></p> <p>Or</p> <p>You can simply follow the steps here:</p>"},{"location":"gen_ai/get_open_ai_keys/#step-1-loginsignup","title":"Step 1 - Login/Signup","text":"<p>Login or Signup in your open AI account, you can use gmail account, microsoft account or apple account to signup.  </p>"},{"location":"gen_ai/get_open_ai_keys/#step-2-open-your-profile","title":"Step 2 - Open Your Profile","text":"<p>Once you are on the home page of your account, you can select your profile on top-right corner, and then select the option View API Keys from the drop-down menu. </p>"},{"location":"gen_ai/get_open_ai_keys/#step-3-generate-new-secret-keys","title":"Step 3 - Generate New Secret Keys","text":"<p>Now that you are in the API Keys section, you will have to create a new key.  </p>"},{"location":"gen_ai/get_open_ai_keys/#step-4-get-secrete-keys","title":"Step 4 - Get Secrete Keys","text":"<p>On clicking Create new secret key a pop-up will appear, where you can enter the key name, which is for your reference to remember multiple secret keys, once done, there will be another section where you can copy the open-ai secret keys.  </p>"},{"location":"gen_ai/get_open_ai_keys/#step-5-ready-to-go-with-algobulls","title":"Step 5 - Ready to go with AlgoBulls","text":"<p>Once you have copied your secret key then you can now save it on your AlgoBulls Account for accessing the gen-ai feature to create a strategy, and there you go. To know how to save keys and start with generating strategies using Chat-GPT, click here Happy Trading !</p>"},{"location":"pyalgotrad/introduction/","title":"pyalgotrading","text":""},{"location":"pyalgotrad/introduction/#introduction","title":"Introduction","text":"<p>Welcome to the Pyalgotrading Documentation \u2013 your guide to practising and acquainting yourself with the pyalgotrading package. Pyalgotrading, built with Python, is an algorithmic trading library that empowers you to design and implement trading strategies on a variety of financial instruments, such as equities, futures, and options. To embark on your journey with Pyalgotrading, ensure you have an active AlgoBulls account, a platform designed for creating and testing trading strategies.</p>"},{"location":"pyalgotrad/introduction/#key-features","title":"Key Features","text":"<ul> <li>Fueled by the AlgoBulls</li> <li>Comprehensive Support for Algorithmic Trading Strategies:</li> <li>Create &amp; upload strategies seamlessly on the AlgoBulls Platform</li> <li>Access a range of strategies from the pyalgostrategypool</li> <li>Over 150 Technical Indicators from TA-Lib at your disposal</li> <li>Multiple candlestick patterns including Japanese OHLC, Renko, Heikin-Ashi, Linebreak</li> <li>Support for varied candle intervals: 1 minute, 3 minutes, 5 minutes, and more</li> <li>Diverse order types supported: MARKET, LIMIT, STOPLOSS-MARKET, STOPLOSS-LIMIT</li> <li>Flexibility for both INTRADAY and DELIVERY orders</li> <li>Full Spectrum of Trading: Backtesting, Paper Trading, and Real Trading:</li> <li>Currently supported with selected brokers</li> <li>Real-time Logs and Reports for Backtesting, Paper Trading, and Real Trading:</li> <li>Detailed Profit and Loss reports (PnL report)</li> <li>Insightful statistics derived from PnL report</li> <li>Order History showcasing state transitions and timestamps</li> <li>Generate Candlestick charts using plotly.py</li> </ul> <p>Execute Backtesting, Paper Trading, and Real Trading using the same strategy code base.</p> <p>Prerequisites</p> <p>Before you commence development, make sure to establish your workspace and gather all prerequisites as outlined here.</p>"},{"location":"pyalgotrad/introduction/#support-seeking-assistance","title":"Support / Seeking Assistance","text":"<ul> <li>Bug Reporting / New Feature Request: Create a new issue on GitHub.</li> <li>Engage in Discussion: Join fellow developers on the discussion forum.</li> <li>Additional Support: For further help, contact pushpak@algobulls.com.</li> </ul>"},{"location":"pyalgotrad/introduction/#overview","title":"Overview","text":"<ol> <li> <p>Check out the basic structure of a strategy: Before coding your strategy, refer to the basic structure guide provided by the Pyalgotrading package. This will help you understand the trading strategy methods and flow.</p> </li> <li> <p>Code your own simple strategy using the pyalgotrading package: Use your Python IDE to code your trading strategy using the pyalgotrading package. You can also use ready-made strategies from the pyalgostrategypool package if you prefer not to code your own.</p> </li> <li> <p>Upload your strategy to the platform: Upon coding your strategy, upload it to the AlgoBulls platform by crafting a new strategy and uploading the corresponding file.</p> </li> <li> <p>Run Backtest / Paper Trade / Real Trade with your strategy:  Once uploaded, initiate backtests, paper trades, or real trades on the AlgoBulls platform to evaluate its performance.</p> </li> <li> <p>Retrieve real-time logs, review reports and stats, and inspect order history:Monitor your strategy's performance by fetching runtime logs, examining reports and statistics, and reviewing your order history to track executed trades.</p> </li> <li> <p>Reach out to AlgoBulls Support for any queries: If you encounter issues during the tutorial, contact the AlgoBulls Support team for assistance.</p> </li> </ol>"},{"location":"pyalgotrad/introduction/#conclusion","title":"Conclusion","text":"<p>This documentation serves as your launchpad into the Pyalgotrading package and the creation of your trading strategies. It also steers you through the process of uploading, executing, and monitoring strategies on the AlgoBulls platform. Our goal is to equip you with the expertise needed to craft effective trading strategies using Pyalgotrading.</p>"},{"location":"pyalgotrad/introduction/#contribution-guidelines","title":"Contribution Guidelines","text":"<ol> <li>Fork this project to your account.</li> <li>Create a branch for the change you intend to make.</li> <li>Make your changes to your fork.</li> <li>Send a pull request from your fork\u2019s branch to our <code>master</code> branch.</li> </ol> <p>See CHANGELOG.md for the changelog and LICENSE for the license.</p>"},{"location":"pyalgotrad/prerequisites/","title":"Setup your Workspace","text":""},{"location":"pyalgotrad/prerequisites/#prerequisites","title":"Prerequisites","text":"<p>You will need the following to start with Pyalgotrading:</p>"},{"location":"pyalgotrad/prerequisites/#algobulls-account","title":"AlgoBulls Account","text":"<p>To upload and test your strategies, you will need this account. You can create your account for FREE on the Algobulls website.</p>"},{"location":"pyalgotrad/prerequisites/#developer-key","title":"Developer Key","text":"<p>To access the features, you will need a developer key. The key can be obtained as follows:</p> <ul> <li>Step 1: Activate the Advanced Developer Plan from the Pricing menu. </li> <li>Step 2: Get the Developer Key from the Settings section. </li> </ul> <p>Please Note</p> <p>For security reasons, the developer key will get reset every time you log out from your AlgoBulls account.</p> <p>Once you have the developer key, you can access the AlgoBulls platform using <code>pyalgotrading</code> functions.   </p>"},{"location":"pyalgotrad/prerequisites/#python-310","title":"Python 3.10+","text":"<p>The Pyalgotrading platform can run all strategies that conform to Python 3.8 or higher. However, we recommend Python 3.10 or higher. </p> <p>Python Tips</p> <ul> <li>It is a good idea to set up a virtual environment first while installing Python 3.10.</li> <li>Once Python is installed, most packages are easily installed in your venv using <code>pip install</code> command</li> </ul>"},{"location":"pyalgotrad/prerequisites/#pyalgotrading-package","title":"Pyalgotrading Package","text":"<p>To create and execute your fully automated trading strategies, you only need to install <code>pyalgotrading</code>. You can install the <code>pyalgotrading</code> package using the following command:     <pre><code>pip install pyalgotrading\n</code></pre></p>"},{"location":"pyalgotrad/prerequisites/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>You will use a Jupyter Notebook to connect to the AlgoBulls platform. Using the notebook, you can upload the strategy, test your strategy (Backtesting, Paper Trading, or Real Trading), and fetch logs.        Install Jupyter Notebook using the following command: <pre><code>pip install jupyter\n</code></pre></p> <p>Pro Tip</p> <p>If you are an experienced Pyalgotrading user, Jupyter Notebook might not be necessary. You can directly integrate it into your application.</p>"},{"location":"pyalgotrad/prerequisites/#enhancing-productivity","title":"Enhancing Productivity","text":"<p>For enhancing your productivity while building and executing strategies using Pyalgotrading, you can make use of Python IDEs of your choice, such as:</p> <ul> <li>PyCharm</li> <li>VS Code</li> </ul>"},{"location":"pyalgotrad/programexample/","title":"Create your Strategy","text":""},{"location":"pyalgotrad/programexample/#previously","title":"Previously...","text":"<p>You have covered the basic code structure of a strategy.</p>"},{"location":"pyalgotrad/programexample/#now","title":"Now...","text":"<p>You can either follow this page to create a strategy, or you can pick up a ready strategy (shown below) and move to the next page. </p>"},{"location":"pyalgotrad/programexample/#before-you-start","title":"Before you start...","text":"<p>If you want to use a ready strategy from the pyalgostrategypool package, then you can directly jump to the Upload section. </p>"},{"location":"pyalgotrad/programexample/#lets-start","title":"Let's Start...","text":"<p>Follow the steps given below to create a new strategy of your own.</p> <p>Create a python file called <code>strategy_sma_regular_order.py</code>.</p> <p>You will add the following code snippets into the file and then save it.</p>"},{"location":"pyalgotrad/programexample/#import-statements","title":"Import statements","text":"<pre><code>from pyalgotrading.strategy.strategy_base import StrategyBase\nfrom pyalgotrading.constants import *\n</code></pre>"},{"location":"pyalgotrad/programexample/#create-the-class-strategysmaregularorder-and-subclass-it-from-strategybase","title":"Create the class <code>StrategySMARegularOrder</code> and subclass it from <code>StrategyBase</code>","text":"<p><pre><code>class StrategySMARegularOrder(StrategyBase):\n</code></pre> Now you can add the methods mentioned in the structure inside the class. First you can add the <code>__init__</code> and the <code>initialize</code> methods.</p>"},{"location":"pyalgotrad/programexample/#constructor-def-__init__","title":"Constructor: <code>def __init__()</code>","text":"<pre><code>def __init__(self, *args, **kwargs):\n    name = 'SMA Regular Order Strategy'\n    super().__init__(*args, **kwargs)\n\n    self.timeperiod_x = self.strategy_parameters['timeperiod1']\n    self.timeperiod_y = self.strategy_parameters['timeperiod2']\n\n    self.main_order = None\n</code></pre> <p>The <code>init</code> method does the following:</p> <ol> <li><code>name</code> - variable which should store the name of your strategy</li> <li><code>super()</code> - Calls the constructor of the superclass.</li> <li><code>self.strategy_parameters</code> - Catches the parameters and saves them for local use - When you will submit a testing job for your SMA strategy,  you will pass parameters that will be used inside the strategy.  For SMA, we are calculating crossover for 2 SMA timeperiod values, example 5 and 12.  These 2 parameters will be caught by <code>self.strategy_parameters</code> and stored for local use in <code>self.timeperiod1</code> and <code>self.timeperiod2</code>.</li> <li><code>self.main_order</code> - Create an object that manages orders for you throughout the strategy.</li> </ol> <p>The <code>init</code> method is specific to Python's internal workings, and it is preceded and succeeded by double underscores ( _ _ ) joined together.</p>"},{"location":"pyalgotrad/programexample/#def-initialize","title":"<code>def initialize()</code>","text":"<pre><code>def initialize(self):\n    self.main_order = {}\n</code></pre> <p>The <code>initialize</code> method sets the <code>self.main_order</code> as an empty dictionary. This method is called at the start of every trading day.</p> <p>For instance, say you are submitting a backtesting job for 5 previous days starting at 10:30 every day, then the <code>initialize</code> method will be called every day for 5 days at 10:30.</p> <p>Now add the two static methods, <code>name</code> and <code>versions_supprted</code>.</p>"},{"location":"pyalgotrad/programexample/#def-name-optional","title":"<code>def name()</code> (optional)","text":"<p>If the <code>name</code> variable is defined in <code>__init__()</code>, this function is not needed. <pre><code>@staticmethod\ndef name():\n    return 'SMA Regular Order Strategy'\n</code></pre> The name should be unique in your collection of strategies.</p>"},{"location":"pyalgotrad/programexample/#def-versions_supported-optional","title":"<code>def versions_supported()</code> (optional)","text":"<p>not required it will take the latest version of AlgoBullsEngine by default <pre><code>@staticmethod\ndef versions_supported():\n    return AlgoBullsEngineVersion.VERSION_3_2_0\n</code></pre> Mark both the above methods as <code>@staticmethod</code>.</p> <p>The <code>versions_supported</code> method does the following:</p> <ol> <li>It notifies the AlgoBulls platform that the strategy is working correctly for the platform version 3.2.0</li> <li>Since the platform will be constantly upgraded to incorporate new features and improve efficiency, the version may change.</li> <li>If the version changes, and if you submit a job for this strategy, then the AlgoBulls platform will spawn a server having version 3.2.0 for your strategy.</li> <li>Having this method ensures that the AlgoBulls platform always provides the correct environment for your strategy.</li> </ol>"},{"location":"pyalgotrad/programexample/#def-strategy_select_instruments_for_entry","title":"<code>def strategy_select_instruments_for_entry()</code>","text":"<pre><code>def strategy_select_instruments_for_entry(self, candle, instruments_bucket):\n\n    instruments = []\n    meta = []\n\n    for instrument in instruments_bucket:\n        crossover_value = self.get_crossover_value(instrument)\n        if crossover_value == 1:\n            instruments.append(instrument)\n            meta.append({'action': 'BUY'})\n        elif crossover_value == -1:\n            if self.strategy_mode is StrategyMode.INTRADAY:\n                instruments.append(instrument)\n                meta.append({'action': 'SELL'})\n\n    return instruments, meta\n</code></pre> <p>The <code>strategy_select_instruments_for_entry</code> method does the following:</p> <ol> <li><code>instruments</code> and <code>meta</code> - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively.</li> <li>The Loop - The loop will iterate over each instrument name passed (while submitting the job) and will decide whether to set an entry position or not for it.</li> <li><code>crossover_value</code> - The crossover value is calculated and stored here. Crossover values are interpreted as:<ol> <li>Value 1 - Cut upwards</li> <li>Value -1 - Cut downwards</li> <li>Value 0 - No crossover</li> </ol> </li> <li>If conditions - If the crossover value is 1, then the instrument is selected for entry position, with the position as 'BUY'. If the crossover value is -1, then the instrument is selected for entry position, with the position as 'SELL'. The selected instrument is appended to the <code>instruments</code>, and the associated action (BUY/SELL) is appended to the <code>meta</code>.</li> <li><code>instruments</code> and <code>meta</code> - Both the lists (whether populated or empty) are returned to the platform for further actions.</li> </ol> <p>Note</p> <ul> <li>SELL Entry positions are allowed only if the strategy is running for INTRADAY. DELIVERY strategies do not allow SELL as entry positions. This is taken care of in the <code>elif</code> part.</li> <li>The <code>strategy_select_instruments_for_entry</code> method is called once for every candle time. For Instance, if you submit a job with the candle time as 15 minutes, then this method will be called once for every 15 minute candle.</li> <li>The actual Entry position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the <code>meta</code>. The Entry position will be taken in the next method below.</li> <li>The <code>meta</code> contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. </li> </ul>"},{"location":"pyalgotrad/programexample/#def-strategy_enter_position","title":"<code>def strategy_enter_position()</code>","text":"<pre><code>def strategy_enter_position(self, candle, instrument, sideband_info):\n    if sideband_info['action'] == 'BUY':\n        qty = self.number_of_lots * instrument.lot_size\n        self.main_order[instrument] = \\\n            self.broker.BuyOrderRegular(instrument=instrument,\n                order_code=BrokerOrderCodeConstants.INTRADAY,\n                order_variety=BrokerOrderVarietyConstants.MARKET,\n                quantity=qty)\n    elif sideband_info['action'] == 'SELL':\n        qty = self.number_of_lots * instrument.lot_size\n        self.main_order[instrument] = \\\n            self.broker.SellOrderRegular(instrument=instrument,\n                 order_code=BrokerOrderCodeConstants.INTRADAY,\n                 order_variety=BrokerOrderVarietyConstants.MARKET,\n                 quantity=qty)\n    else:\n        raise SystemExit(f'Got invalid sideband_info value: {sideband_info}')\n\n    return self.main_order[instrument]\n</code></pre>"},{"location":"pyalgotrad/programexample/#or","title":"or","text":"<pre><code>def strategy_enter_position(self, candle, instrument, meta):\n    self.main_order_map[instrument] = _ = self.broker.OrderRegular(\n        intrument=instrument,                           \n        order_transaction_type=meta['action'],              # 'BUY' or 'SELL'\n        quantity=self.number_of_lots * instrument.lot_size, # number of lots (int)\n        price=None,\n        trigger_price=None\n    )\n    return _\n</code></pre> <p>The <code>strategy_enter_position</code> method does the following:</p> <ol> <li>If conditions - The conditions read the action from the <code>sideband_info</code> and perform the required action (BUY/SELL).</li> <li><code>qty</code> - The quantity is calculated and stored here. The number of lots will be passed by you as a parameter while submitting a job. The parameter will be caught in <code>self.number_of_lots</code>. The instrument object has the 'lot size', which you can retrieve using <code>instrument.lot_size</code>. You can then use the formula as shown in the code to calculate the quantity.</li> <li><code>OrderRegular</code>,<code>BuyOrderRegular</code> and <code>SellOrderRegular</code> - These execute the required action. You need to pass the instrument, order code, order variety and the quantity values.<ul> <li><code>instrument</code> - the instrument on which the BUY/SELL action will be performed.</li> <li><code>order_code</code> - whether the order is for INTRADAY or DELIVERY. Possible values are:<ul> <li><code>BrokerOrderCodeConstants.INTRADAY</code></li> <li><code>BrokerOrderCodeConstants.DELIVERY</code></li> <li><code>BrokerOrderCodeConstants.DELIVERY_T1</code></li> <li><code>BrokerOrderCodeConstants.DELIVERY_T2</code></li> </ul> </li> <li><code>order_variety</code> - the type of order variety. Possible values are:<ul> <li><code>BrokerOrderVarietyConstants.MARKET</code></li> <li><code>BrokerOrderVarietyConstants.LIMIT</code></li> <li><code>BrokerOrderVarietyConstants.STOPLOSS_MARKET</code></li> <li><code>BrokerOrderVarietyConstants.STOPLOSS_LIMIT</code></li> </ul> </li> <li><code>qty</code> - the quantity to BUY/SELL.</li> </ul> </li> <li><code>self.main_order</code> - The main order (for that particular instrument) is now populated (BUY OR SELL) and is returned to the platform for further actions.</li> </ol> <p>You can also punch Bracket Orders instead of Regular Orders. A typical BUY Bracket Order will look like this: <pre><code>qty = self.number_of_lots * instrument.lot_size\nltp = self.broker.get_ltp(instrument)\nself.main_order[instrument] = \\\n            self.broker.BuyOrderBracket(instrument=instrument,\n                order_code=BrokerOrderCodeConstants.INTRADAY,\n                order_variety=BrokerOrderVarietyConstants.LIMIT,\n                quantity=qty,\n                price=ltp,\n                stoploss_trigger=ltp - (ltp * self.stoploss),\n                target_trigger=ltp + (ltp * self.target),\n                trailing_stoploss_trigger=ltp * self.trailing_stoploss)\n</code></pre></p> <p>The additional parameters are:</p> <ul> <li><code>price</code> - If you want to BUY at the market price (Last Traded Price) or LTP, then just fetch the LTP using <code>get_ltp</code> as shown in the code above. Store the value in <code>ltp</code> and pass it to <code>price</code>.</li> <li><code>stoploss_trigger</code>, <code>target_trigger</code> and <code>trailing_stoploss_trigger</code> - You can calculate these using the <code>ltp</code> and the values you will pass through  the job that you will submit. The parameters will be caught as <code>self.stoploss</code>, <code>self.target</code> and <code>self.trailing_stoploss</code>.</li> </ul> <p>Note</p> <ul> <li>If you plan to use Bracket Order instead of Regular Orders, then create a separate Python file for it, say <code>strategy_sma_bracket_order.py</code>.  You can also change the class name as <code>StrategySMABracketOrder</code>. There will be changes in the entry and exit methods also.</li> <li>The <code>strategy_enter_position</code> method is called once for every instrument. For instance, you want to run this strategy for 5 instruments. Say that the <code>strategy_select_instruments_for_entry</code> method selects 3 instruments for ENTRY positions (BUY/SELL). Then, the <code>strategy_enter_position</code> method will be called thrice, once for each instrument respectively within the candle time frame (say, 15 minutes). </li> </ul>"},{"location":"pyalgotrad/programexample/#def-strategy_select_instruments_for_exit","title":"<code>def strategy_select_instruments_for_exit()</code>","text":"<pre><code>def strategy_select_instruments_for_exit(self, candle, instruments_bucket):\n    instruments = []\n    meta = []\n\n    for instrument in instruments_bucket:\n        if self.main_order.get(instrument) is not None:\n            crossover_value = self.get_crossover_value(instrument)\n            if crossover_value in [1, -1]:\n                instruments.append(instrument)\n                meta.append({'action': 'EXIT'})\n    return instruments, meta\n</code></pre> <p>The <code>strategy_select_instruments_for_exit</code> method does the following:</p> <ol> <li><code>instruments</code> and <code>meta</code> - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively.</li> <li>The Loop - The loop will iterate over each instrument name passed (which are in Entry position (BUY/SELL)) and will decide whether to set an exit position or not for it.</li> <li>If condition - The exit steps are executed only if the instrument is holding at an ENTRY position (BUY/SELL). You can do this by checking if the <code>self.main_order</code> object is <code>None</code> or not, and proceed only if it is not <code>None</code>. </li> <li><code>crossover_value</code> - The crossover value is calculated and stored here. Crossover values are interpreted as:<ol> <li>Value 1 - Cut upwards</li> <li>Value -1 - Cut downwards</li> <li>Value 0 - No crossover</li> </ol> </li> <li>If condition - If the crossover value is 1 or -1, then the instrument is selected for exit position. The selected instrument is appended to the <code>instruments</code>, and the associated action (EXIT) is appended to the <code>meta</code>.</li> <li><code>instruments</code> and <code>meta</code> - Both the lists (whether populated or empty) are returned to the platform for further actions.</li> </ol> <p>Note</p> <ul> <li>The actual Exit position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the <code>meta</code>. The Exit position will be taken in the next method below.</li> <li>The <code>meta</code> contains a very versatile dictionary object. You may use it to pass any other additional information that you wish.</li> <li>Whenever a new trading day starts, the <code>strategy_select_instruments_for_exit</code> is called first. This is very important for DELIVERY strategies. Many instruments might be holding in an Entry Position at the end of the previous trading day, and they might be eligible for exit at the start of the new trading day.  </li> </ul>"},{"location":"pyalgotrad/programexample/#def-strategy_exit_position","title":"<code>def strategy_exit_position()</code>","text":"<pre><code>def strategy_exit_position(self, candle, instrument, sideband_info):\n    if sideband_info['action'] == 'EXIT':\n        self.main_order[instrument].exit_position()\n        self.main_order[instrument] = None\n        return True\n\n    return False\n</code></pre> <p>The <code>strategy_exit_position</code> method does the following:</p> <ol> <li>If condition - checks whether the appropriate action is set in the <code>sideband_info</code>.</li> <li><code>self.main_order</code> - calls <code>exit_position</code> method for the particular main order of the instrument. If the Entry Position was BUY, then the exit position is automatically taken as SELL and vice versa. The platform takes care of this automatically.</li> <li><code>self.main_order</code> - set it to <code>None</code>, as the order has been exited and no longer holds anything.</li> <li>Return values - returns <code>True</code> to the platform if the exit steps were performed, else return <code>False</code>.</li> </ol>"},{"location":"pyalgotrad/programexample/#def-get_crossover_value","title":"<code>def get_crossover_value()</code>","text":"<pre><code>def get_crossover_value(self, instrument):\n    hist_data = self.get_historical_data(instrument)\n    sma_x = talib.SMA(hist_data['close'], timeperiod=self.timeperiod_x)\n    sma_y = talib.SMA(hist_data['close'], timeperiod=self.timeperiod_y)\n    crossover_value = self.utils.crossover(sma_x, sma_y)\n    return crossover_value\n</code></pre> <p>The <code>get_crossover_value</code> method does the following:</p> <ol> <li><code>hist_data</code> - The historical data for the instrument is fetched using the <code>get_historical_data</code> method and stored here. The data is in the form of a table (Pandas DataFrame) having the following columns:<ul> <li><code>timestamp</code> - the data and time when the data was measured</li> <li><code>volume</code> - the volume of that instrument</li> <li><code>open</code>, <code>high</code>, <code>low</code> and <code>close</code> - the OHLC values of the instrument</li> <li><code>oi</code> - the Open Interest of that instrument</li> </ul> </li> <li><code>sma_x</code> and <code>sma_y</code> - the SMA function from the <code>talib</code> package is used to calculate the Moving Average for both SMA time-periods. The candle close value is used for calculations, i.e. <code>hist_data['close']</code>.</li> <li><code>crossover_value</code> - calculates the crossover value using the <code>crossover</code> method from the <code>utils</code> package.</li> <li>Return value - return the crossover value to the caller method.</li> </ol> <p>Note</p> <ul> <li>The order of values passed to the <code>crossover</code> method of the <code>utils</code> package is very important.</li> <li>Example: you have 2 SMA values, 5 and 12. The strategy describes that there should be an BUY Entry Position when SMA(5) cuts SMA(12) upwards (crossover value should be 1).</li> <li>In this case, if you mistakenly pass SMA(12) value first and SMA(5) value next to the <code>crossover</code> function, the answer you will get is -1 (Cut downwards).</li> <li>Though, the crossover value is correct, the strategy is expecting to BUY at crossover 1 as per the code, which will not work now.</li> <li>Therefore, the strategy will work correctly only if you pass SMA(5) first and then SMA(12) to the <code>crossover</code> function, thus making the order of parameters passed an important point to be aware of, while coding the strategy.</li> </ul>"},{"location":"pyalgotrad/programexample/#whats-next","title":"What's Next...","text":"<p>Next, you upload the strategy into your AlgoBulls account.</p>"},{"location":"pyalgotrad/pyalgotrading_analytics/","title":"Pyalgotrading Analytics","text":""},{"location":"pyalgotrad/pyalgotrading_analytics/#metric-values-and-statistics","title":"Metric Values and Statistics","text":""},{"location":"pyalgotrad/pyalgotrading_analytics/#cumulative-returns","title":"Cumulative Returns","text":"<ul> <li>The Cumulative Returns chart illustrates how our strategy's returns value has evolved over time in percentage. </li> <li>Positive values indicate gains, while negatives reflect losses. Bigger positive returns are more favourable. </li> <li>Keep in mind, this chart focuses on gains and losses, excluding risk and timing considerations.</li> <li>There are 2 sub categories of cumulative returns chart depending on the scale we are using. One is normal scaled and other is log scaled </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#end-of-year-returns-eoy","title":"End of Year Returns (EoY)","text":"<ul> <li>The End of Year Returns chart showcases our strategy's annual performance as a percentage. </li> <li>It quantifies its overall performance, considering gains or losses throughout each year.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#distributions-of-monthly-returns-histogram","title":"Distributions of Monthly Returns (Histogram)","text":"<ul> <li>In the Monthly Returns Distribution Histogram, we see the frequency distribution of different levels of returns over consecutive months. </li> <li>This histogram helps us understand the range and patterns in monthly returns, shedding light on our strategy's volatility and performance trends.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#daily-returns","title":"Daily Returns","text":"<ul> <li>The Daily Returns Chart portrays the percentage change in our strategy's returns between trading days. </li> <li>It provides insights into short-term volatility, trend analysis, and risk assessment.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#rolling-volatility-6-months","title":"Rolling Volatility (6 months)","text":"<ul> <li>A Rolling Volatility (6 months) Plot showcases the changing volatility of an investment over time using a rolling window of six months. </li> <li>This plot reveals how the investment's price fluctuations vary as the window moves across the dataset. </li> <li>It provides insights into short-term volatility patterns, helping investors understand how the investment's risk level evolves in response to different market conditions.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#rolling-sharpe-6-months","title":"Rolling Sharpe (6 months)","text":"<ul> <li>A Rolling Sharpe (6 months) Plot illustrates the dynamic changes in the Sharpe ratio over time using a rolling window of six months. </li> <li>The plot shows how the risk-adjusted performance of an investment fluctuates as the window moves through the dataset. </li> <li>This visualization helps investors understand how the Sharpe ratio varies with changing market conditions and provides insights into the investment's consistency and risk-return trade-offs over short-term periods.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#rolling-sortino-6-months","title":"Rolling Sortino (6 months)","text":"<ul> <li>A Rolling Sortino (6 months) Plot visualizes the variation in the Sortino ratio over time using a rolling window of six months. </li> <li>This plot demonstrates how the investment's risk-adjusted performance, considering only downside volatility, changes as the window progresses through the data. </li> <li>It offers insights into how the Sortino ratio evolves with market conditions, helping investors assess the investment's ability to generate favorable risk-adjusted returns over short-term intervals.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#worst-5-drawdown-periods","title":"Worst 5 Drawdown Periods","text":"<ul> <li>A Worst 5 Drawdown Periods plot displays the top five periods during which the strategy experienced the largest declines from peak to trough. </li> <li>This visualization helps strategists understand the most significant loss-making episodes in the strategy's run. </li> <li>It shows the magnitude and duration of these drawdowns, providing insights into the strategy's risk and potential vulnerabilities.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#underwater-plot","title":"Underwater Plot","text":"<ul> <li>The Underwater Plot visually narrates our strategy's performance concerning its past peaks. </li> <li>It showcases how much our returns value has dropped from its highest point over time. </li> <li>This aids in visualising periods of drawdown and recovery, offering insights into historical risk and resilience.    </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#monthly-returns-heatmap","title":"Monthly Returns (Heatmap)","text":"<ul> <li>The Monthly Returns Heatmap offers a colour-coded view of our strategy's performance across months. </li> <li>Shades of green indicate positive returns, while shades of red signify losses. </li> <li>This visual tool helps spot trends and patterns, aiding in identifying strong and weak performance periods.    </li> </ul>"},{"location":"pyalgotrad/python-build-view-results/","title":"Analytics in AlgoBulls Platform","text":""},{"location":"pyalgotrad/python-build-view-results/#how-to-view-the-results","title":"How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can switch to the Analytics tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Analytics: In the analytics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p>"},{"location":"pyalgotrad/python-build-view-results/#stats","title":"Stats","text":"<p>In this section you can see the total returns, sharpe ratio, sortino ratio, volatility, Max Drawdown, Total wins or Loses, Total short or long trades, hit ratio, number of trades, average trades per day, max profit, max loss, average profit per winning trade, average loss per losing trade. </p>"},{"location":"pyalgotrad/python-build-view-results/#cumulative-returns","title":"Cumulative Returns","text":""},{"location":"pyalgotrad/python-build-view-results/#profit-loss-currency-or","title":"Profit &amp; Loss (Currency or %)","text":"<p>The trade by trade P&amp;L in Currency or Percentage. </p>"},{"location":"pyalgotrad/python-build-view-results/#end-of-year-returns-plot","title":"End of Year Returns Plot (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#monthly-returns-histogram","title":"Monthly Returns Histogram (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#monthly-returns-heatmap","title":"Monthly Returns Heatmap (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#daily-returns","title":"Daily Returns (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#underwater-drawdown-plot","title":"Underwater Drawdown Plot (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#pl-book","title":"P&amp;L Book","text":"<p>View detailed trade by trade report. Premium users can analyze this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades. </p>"},{"location":"pyalgotrad/python-build-view-results/#user-log","title":"User Log","text":"<p>Real-time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behavior and performance. </p>"},{"location":"pyalgotrad/python-build-view-results/#order-history","title":"Order History","text":"<p>View the order state transition for every order placed by your strategy in-depth. </p>"},{"location":"pyalgotrad/select/","title":"Select your Strategy","text":""},{"location":"pyalgotrad/select/#previously","title":"Previously...","text":"<p>You have uploaded or saved a strategy by:</p> <ul> <li>Your strategy is already uploaded on the AlgoBulls account and you want to search or select it</li> </ul> <p>OR</p> <ul> <li>You have saved the strategy from the AlgoBulls Website</li> </ul>"},{"location":"pyalgotrad/select/#now","title":"Now...","text":"<p>You are now ready to select or import your strategy from your AlgoBulls account for Backtesting, Paper Trading and/or Real Trading. </p>"},{"location":"pyalgotrad/select/#before-you-start","title":"Before you start...","text":"<ul> <li>Make sure you have an active working AlgoBulls account ready to go!</li> <li>Open a Jupyter Notebook.</li> <li>If you have coded the strategy yourself and not used a ready strategy from the pyalgostrategypool package, then make sure your strategy file (.py) and the Jupyter Notebook are in the same folder. </li> </ul>"},{"location":"pyalgotrad/select/#lets-start","title":"Let's Start...","text":"<p>Run the following code snippets into the Jupyter Notebook one by one (or all together).</p>"},{"location":"pyalgotrad/select/#import-statements","title":"Import statements","text":"<pre><code>import inspect\nfrom pyalgotrading.algobulls import AlgoBullsConnection\n</code></pre>"},{"location":"pyalgotrad/select/#import-the-strategy-class","title":"Import the strategy class","text":"<p>Perform the below step either to import a ready strategy OR to import your own created strategy.</p> <ul> <li> <p>Import a ready strategy <pre><code>from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder\n</code></pre></p> </li> <li> <p>Import your own strategy <pre><code>from strategy_sma_regular_order import StrategySMARegularOrder\n</code></pre></p> </li> </ul>"},{"location":"pyalgotrad/select/#establish-a-connection-to-the-algobulls-platform","title":"Establish a connection to the AlgoBulls Platform","text":"<p><pre><code>algobulls_connection = AlgoBullsConnection()\nalgobulls_connection.get_authorization_url()\n</code></pre> The output of the above step is:</p> <p><code>Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login</code></p> <p>Get Developer Key</p> <p>You will need to log in to your AlgoBulls account and fetch the access token from:  (See How) Settings -&gt; General -&gt; Developer Options </p> <p>Once you have the access token, set it in the code as shown here:</p> <p><pre><code>algobulls_connection.set_access_token('4365817b795770ea31040a21ad29c8e78b63ad88')\n</code></pre> Replace the token you have copied with the token in the code above.</p>"},{"location":"pyalgotrad/select/#view-all-the-strategies-in-your-algobulls-account","title":"View all the strategies in your AlgoBulls Account","text":"<p>You can view all the strategy saved on your AlgoBulls account. <pre><code>all_strategies_df = algobulls_connection.get_all_strategies()\nprint(all_strategies_df)\n</code></pre></p>"},{"location":"pyalgotrad/select/#search-your-strategy","title":"Search your Strategy","text":"<ul> <li>Search your strategy using <code>strategy name</code>. Make sure you have the strategy with given name in your AlgoBulls Account.      <pre><code>    strategy_name = 'Exponential Moving Averages Crossover'\n    strategy_code, strategy_name = all_strategies_df.loc[all_strategies_df['strategyName'] == strategy_name].iloc[0]        \n</code></pre></li> <li>Search your strategy using <code>strategy code</code>. Make sure you have the strategy with given code in your AlgoBulls Account.      <pre><code>strategy_code = 'afd6214c5db94dbeae7502e861fa4ffc'\nstrategycode, strategyname = all_strategies_df.loc[all_strategies_df['strategyCode'] == strategy_code].iloc[0]\n</code></pre></li> </ul>"},{"location":"pyalgotrad/select/#whats-next","title":"What's Next...","text":"<p>You are now ready to test your uploaded strategy and perform Backtesting, Paper Trading and/or Real Trading with it.</p>"},{"location":"pyalgotrad/testing/","title":"Execute your Strategy","text":""},{"location":"pyalgotrad/testing/#previously","title":"Previously...","text":"<p>You have uploaded your strategy to the AlgoBulls platform.</p>"},{"location":"pyalgotrad/testing/#now","title":"Now...","text":"<p>Using the uploaded strategy, you can now try: * Backtesting * Paper Trading * Real Trading </p>"},{"location":"pyalgotrad/testing/#before-you-start","title":"Before you start...","text":"<p>Open a Jupyter Notebook.</p> <p>The steps you will follow are:</p> <ol> <li>Establish a connection to the AlgoBulls Platform.</li> <li>Display all Strategies you have in your account.</li> <li>Select the strategy.</li> <li>Optionally, print the strategy once.</li> <li>Select instrument(s).</li> <li>Submit/Run a Backtest, Paper Trade or Real Trade job.</li> <li>Check Job Status.</li> <li>Fetch Logs (even while the job is running).</li> <li>Fetch Reports. (PnL, Statistics, Order History)</li> </ol>"},{"location":"pyalgotrad/testing/#lets-start","title":"Let's Start...","text":"<p>Run the following code snippets into the Jupyter Notebook one by one (or all together).</p>"},{"location":"pyalgotrad/testing/#import-statements","title":"Import statements","text":"<pre><code>from pyalgotrading.algobulls import AlgoBullsConnection\nfrom datetime import datetime as dt\nfrom pyalgotrading.constants import *\n</code></pre>"},{"location":"pyalgotrad/testing/#establish-a-connection-to-the-algobulls-platform","title":"Establish a connection to the AlgoBulls Platform","text":"<p><pre><code>algobulls_connection = AlgoBullsConnection()\nalgobulls_connection.get_authorization_url()\n</code></pre> The output of the above step is:</p> <p><code>Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login</code></p> <p>Get Developer Key</p> <p>You will need to log in to your AlgoBulls account and fetch the access token from:  (See How) Settings -&gt; General -&gt; Developer Options </p> <p>Once you have the access token, set it in the code as shown here:</p> <pre><code>algobulls_connection.set_access_token('4365817b795770ea31040a21ad29c8e78b63ad88')\n</code></pre> <p>Replace the token you have copied with the token in the code above.</p>"},{"location":"pyalgotrad/testing/#display-all-strategies-in-your-account","title":"Display all strategies in your account","text":"<pre><code>all_strategies = algobulls_connection.get_all_strategies()\nall_strategies\n</code></pre> <p>An example of the output will be: </p>"},{"location":"pyalgotrad/testing/#select-the-strategy","title":"Select the strategy","text":"<p>Select the last entry of the <code>strategyCode</code> column and display it. <pre><code>strategy_code = all_strategies.iloc[-1]['strategyCode']\nstrategy_code\n</code></pre></p>"},{"location":"pyalgotrad/testing/#print-your-strategy-code","title":"Print your Strategy code","text":"<p>You can print your strategy code once to verify if this is the correct code. This step is optional.</p> <pre><code>strategy_details1 = algobulls_connection.get_strategy_details(strategy_code)\nprint(strategy_details1)\n</code></pre>"},{"location":"pyalgotrad/testing/#search-for-instruments-based-on-a-search-query","title":"Search for instruments (based on a search query)","text":"<p>Now display a few instruments with some keyword. The example below uses 'SBIN' as the keyword.</p> <pre><code>instruments = algobulls_connection.search_instrument('SBIN')\ninstruments\n</code></pre>"},{"location":"pyalgotrad/testing/#select-an-instrument","title":"Select an instrument","text":"<p>From the output, select the instrument on which you wish to test your strategy. For this example, select the first one. <pre><code>instrument = instruments[0]['value']\ninstrument\n</code></pre></p>"},{"location":"pyalgotrad/testing/#submit-a-job","title":"Submit a Job","text":"<p>Delete previous trades <pre><code>algobulls_connection.delete_previous_trades(strategy=strategy)\n</code></pre></p> <p>Set the parameters for the strategy <pre><code>parameters={\n    'timeperiod1': 5,\n    'timeperiod2': 12\n}\n</code></pre></p> <pre><code>vendor_details = {\n    'brokerName': '&lt;VENDOR_NAME&gt;',\n    'credentialParameters': {\n        'api_key': '&lt;API_KEY&gt;',\n        'secret_key': '&lt;SECRET_KEY&gt;'\n    }\n}\n</code></pre> <pre><code>broking_details = {\n    'brokerName': '&lt;BROKER_NAME&gt;',\n    'credentialParameters': {\n        'user_id': '&lt;USER_ID&gt;',\n        'api_key': '&lt;API_KEY&gt;',\n        'password': '&lt;PASSWORD&gt;'\n    }\n}\n</code></pre> <p>Click on each of the tabs to see the relevant code snippet.</p> BacktestingPaper TradingReal Trading <pre><code>algobulls_connection.backtest(\n        strategy=strategy_code,         # strategy code\n        start='2020-7-1 09:15 +0530',   # start date-time of strategy ('YYYY-MM-DD HH:MM z')\n        end='2020-7-7 15:30 +0530',     # end date-time of strategy ('YYYY-MM-DD HH:MM z')\n        instruments='NSE:SBIN',         # name of the instrument\n        lots=1,                         # number of lots per trade\n        parameters=parameters,          # parameters required for the strategy\n        candle='15 minutes',            # candle size eg : '1 Day', '1 hour', '3 minutes'\n        delete_previous_trades=True,    # delete the previous trades for papertrading (default is true),\n        initial_funds_virtual=10000,    # virtual funds allotted before the paper trading starts (default is 1e9)\n        vendor_details=vendor_details   # vendor's details for authentication and verification \n)\n</code></pre> <pre><code>algobulls_connection.papertrade(\n        strategy=strategy_code,         # strategy code\n        start='09:15 +0530',            # start time of strategy (HH:MM z)     \n        end='15:30 +0530',              # end time of strategy (HH:MM z)\n        instruments='NSE:SBIN',         # name of the instrument\n        lots=1,                         # number of lots per trade\n        parameters=parameters,          # parameters required for the strategy\n        candle='15 minutes',            # candle size eg : '1 Day', '1 hour', '3 minutes'\n        delete_previous_trades=True,    # delete the previous trades for papertrading (default is true)\n        initial_funds_virtual=10000,    # virtual funds allotted before the paper trading starts (default is 1e9)\n        vendor_details=vendor_details   # vendor's details for authentication and verification \n)\n</code></pre> <pre><code>algobulls_connection.realtrade(\n        strategy=strategy_code,          # strategy code\n        start='09:15 +0530',             # start time of strategy (HH:MM z)     \n        end='15:30 +0530',               # end time of strategy (HH:MM z)\n        instruments='NSE:SBIN',          # name of the instrument\n        lots=1,                          # number of lots per trade\n        parameters=parameters,           # parameters required for the strategy\n        candle='15 minutes',             # candle size eg : '1 Day', '1 hour', '3 minutes'\n        broking_details=broking_details  # broker's details for authentication and verification \n)\n</code></pre>"},{"location":"pyalgotrad/testing/#fetch-job-status","title":"Fetch Job Status","text":"<p>Click on each of the tabs to see the relevant code snippet. There are 4 stages of your strategy execution : STARTING, STARTED, STOPPING and STOPPED </p> BacktestingPaper TradingReal Trading <pre><code>algobulls_connection.get_backtesting_job_status(strategy_code)\n</code></pre> <pre><code>algobulls_connection.get_papertrading_job_status(strategy_code)\n</code></pre> <pre><code>algobulls_connection.get_realtrading_job_status(strategy_code)\n</code></pre> <p>You can stop a submitted job anytime.</p>"},{"location":"pyalgotrad/testing/#stop-a-job","title":"Stop a Job","text":"<p>Click on each of the tabs to see the relevant code snippet.  </p> BacktestingPaper TradingReal Trading <pre><code>algobulls_connection.stop_backtesting_job(strategy_code)\n</code></pre> <pre><code>algobulls_connection.stop_papertrading_job(strategy_code)\n</code></pre> <pre><code>algobulls_connection.stop_realtrading_job(strategy_code)\n</code></pre> <p>You can fetch the logs in the middle of a job to monitor the progress.</p>"},{"location":"pyalgotrad/testing/#fetch-logs","title":"Fetch logs","text":"<p>Logging Tip</p> <ul> <li>There are 2 variations when fetching logs:  <ul> <li>Progressive Logs (<code>auto_update</code> = True):  will show progress bar and update the latest logs as the strategy is executed</li> <li>Complete Logs (<code>auto_update</code> = False): will fetch logs only till the point where strategy is currently executing.(It wont update the latest logs, unless called manually again)</li> </ul> </li> </ul> <p>Click on each of the tabs to see the relevant code snippet.  </p> BacktestingPaper TradingReal Trading <pre><code>logs = algobulls_connection.get_backtesting_logs(\n            strategy_code,                              # strategy code \n            auto_update=True,                           # (default=True)update the logs and show your strategy progress. If False, will only fetch logs from start to the current stage of execution\n            display_logs_in_auto_update_mode=True       # only if auto_update is also True, will print logs as the progress is tracked\n        )\nprint(logs)\n</code></pre> <pre><code>logs = algobulls_connection.get_papertrading_logs(\n            strategy_code,                              # strategy code \n            auto_update=True,                           # (default=True)update the logs and show your strategy progress. If False, will only fetch logs from start to the current stage of execution\n            display_logs_in_auto_update_mode=True       # only if auto_update is also True, will print logs as the progress is tracked\n        )\nprint(logs)\n</code></pre> <pre><code>logs = algobulls_connection.get_realtrading_logs(\n            strategy_code,                              # strategy code \n            auto_update=True,                           # (default=True)update the logs and show your strategy progress. If False, will only fetch logs from start to the current stage of execution\n            display_logs_in_auto_update_mode=True       # only if auto_update is also True, will print logs as the progress is tracked\n        )\nprint(logs)\n</code></pre> <p>You can fetch the PnL report, statistics and order history for a job.</p>"},{"location":"pyalgotrad/testing/#fetch-pnl-reports","title":"Fetch PnL Reports","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Please Note</p> <p>Make sure that  strategy's execution status is at STOPPED stage before generating PnL reports</p> BacktestingPaper TradingReal Trading <pre><code>algobulls_connection.get_backtesting_report_pnl_table(\n        strategy_code,              # strategy code\n        show_all_rows=True,         # default=True         \n        force_fetch=True,           # pnl data is saved locally once fetched, to update the locally fetched data, make this parameter True\n        country='USA',              # country of the exchange that was used while starting the job ('India' or 'USA')\n)\n</code></pre> <pre><code>algobulls_connection.get_papertrading_report_pnl_table(\n        strategy_code,              # strategy code\n        show_all_rows=True,         # default=True         \n        force_fetch=True,           # pnl data is saved locally once fetched, to update the locally fetched data, make this parameter True\n        country='USA',              # country of the exchange that was used while starting the job ('India' or 'USA')\n)\n</code></pre> <pre><code>algobulls_connection.get_realtrading_report_pnl_table(\n        strategy_code,              # strategy code\n        show_all_rows=True,         # default=True         \n        force_fetch=True,           # pnl data is saved locally once fetched, to update the locally fetched data, make this parameter True\n        country='USA',              # country of the exchange that was used while starting the job ('India' or 'USA')\n)\n</code></pre>"},{"location":"pyalgotrad/testing/#fetch-report-statistics","title":"Fetch Report Statistics","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Analytics Tips</p> <p>You can view your analytics on the python build page as well, simply log inside your AlgoBulls Account, and look for your Strategy in Python Build -&gt; My Coded Strategies</p> BacktestingPaper TradingReal Trading <pre><code>algobulls_connection.get_backtesting_report_statistics(\n    strategy_code,          # strategy code\n    mode='quantstats',      # package used to generate statistics\n    report='full',          # format of the report\n    html_dump=True          # save report as html file\n)\n</code></pre> <pre><code>algobulls_connection.get_papertrading_report_statistics(\n    strategy_code,          # strategy code\n    mode='quantstats',      # package used to generate statistics\n    report='full',          # format of the report\n    html_dump=True          # save report as html file\n)\n</code></pre> <pre><code>algobulls_connection.get_realtrading_report_statistics(\n    strategy_code,          # strategy code\n    mode='quantstats',      # package used to generate statistics\n    report='full',          # format of the report\n    html_dump=True          # save report as html file\n)\n</code></pre>"},{"location":"pyalgotrad/testing/#fetch-order-history","title":"Fetch Order History","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> BacktestingPaper TradingReal Trading <pre><code>order_history = algobulls_connection.get_backtesting_report_order_history(strategy_code)\nprint(order_history)\n</code></pre> <pre><code>order_history = algobulls_connection.get_papertrading_report_order_history(strategy_code)\nprint(order_history)\n</code></pre> <pre><code>order_history = algobulls_connection.get_realtrading_report_order_history(strategy_code)\nprint(order_history)\n</code></pre> <p>Note</p> <ul> <li>Order History for Real Trading is not supported by brokers.</li> <li>Order History for Backtesting, Paper Trading and Real Trading is supported by the AlgoBulls Virtual Brokers.</li> </ul>"},{"location":"pyalgotrad/testing/#whats-next","title":"What's Next...","text":"<p>You can now explore more by creating and uploading more complex strategies.</p> <p>You can also check out the Strategy Coding Guidelines.</p>"},{"location":"pyalgotrad/upload/","title":"Upload your Strategy","text":""},{"location":"pyalgotrad/upload/#previously","title":"Previously...","text":"<p>You have created a strategy by:</p> <ul> <li>Coding the complete strategy from the Create page.</li> </ul> <p>OR</p> <ul> <li>Picking up a ready strategy from the pyalgostrategypool package.</li> </ul>"},{"location":"pyalgotrad/upload/#now","title":"Now...","text":"<p>You are now ready to upload your strategy into your AlgoBulls account for Backtesting, Paper Trading and/or Real Trading. </p>"},{"location":"pyalgotrad/upload/#before-you-start","title":"Before you start...","text":"<ul> <li>Make sure you have an active working AlgoBulls account ready to go!</li> <li>Open a Jupyter Notebook.</li> <li>If you have coded the strategy yourself and not used a ready strategy from the pyalgostrategypool package, then make sure your strategy file (.py) and the Jupyter Notebook are in the same folder. </li> </ul>"},{"location":"pyalgotrad/upload/#lets-start","title":"Let's Start...","text":"<p>Run the following code snippets into the Jupyter Notebook one by one (or all together).</p>"},{"location":"pyalgotrad/upload/#import-statements","title":"Import statements","text":"<pre><code>import inspect\nfrom pyalgotrading.algobulls import AlgoBullsConnection\n</code></pre> <ul> <li> <p>Import a ready strategy <pre><code>from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder\n</code></pre></p> </li> <li> <p>Import your own strategy <pre><code>from strategy_sma_regular_order import StrategySMARegularOrder\n</code></pre></p> </li> </ul>"},{"location":"pyalgotrad/upload/#establish-a-connection-to-the-algobulls-platform","title":"Establish a connection to the AlgoBulls Platform","text":"<p><pre><code>algobulls_connection = AlgoBullsConnection()\nalgobulls_connection.get_authorization_url()\n</code></pre> The output of the above step is:</p> <p><code>Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login</code></p> <p>Get Developer Key</p> <p>You will need to log in to your AlgoBulls account and fetch the access token from:  (See How) Settings -&gt; General -&gt; Developer Options </p> <p>Once you have the access token, set it in the code as shown here:</p> <p><pre><code>algobulls_connection.set_access_token('4365817b795770ea31040a21ad29c8e78b63ad88')\n</code></pre> Replace the token you have copied with the token in the code above.</p>"},{"location":"pyalgotrad/upload/#print-your-strategy-code","title":"Print your Strategy code","text":"<p>You can print your strategy code once to verify if this is the correct code before uploading it to the platform. This step is optional. <pre><code>print(inspect.getsource(StrategySMARegularOrder))\n</code></pre></p>"},{"location":"pyalgotrad/upload/#upload-your-strategy_1","title":"Upload your Strategy","text":"<p>Upload your strategy as shown in the code below. <pre><code>algobulls_connection.create_strategy(StrategySMARegularOrder)\n</code></pre></p>"},{"location":"pyalgotrad/upload/#re-upload-your-strategy-after-modifications","title":"Re-upload your Strategy after modifications","text":"<p>If you are re-uploading your strategy after some changes, then use the <code>overwrite</code> switch as shown here. <pre><code>algobulls_connection.create_strategy(StrategySMARegularOrder, overwrite=True)\n</code></pre></p>"},{"location":"pyalgotrad/upload/#whats-next","title":"What's Next...","text":"<p>You are now ready to test your uploaded strategy and perform Backtesting, Paper Trading and/or Real Trading with it.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/","title":"Options Strategy Structure","text":"<p>Links</p> <ul> <li>Code Structure of Strategy (workflow of a strategy)</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#1-initial-steps","title":"1. Initial steps","text":""},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#create-a-new-strategy-file","title":"Create a new strategy file","text":"eg: strategy_<code>&lt;developer_initials&gt;</code>_options_ema_crossover.py <p>Coding Conventions</p> <ul> <li>Keep a unique file name</li> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#naming-a-class","title":"Naming a Class","text":"<pre><code>eg: For the above strategy name the class name would be:\nStrategy```&lt;developer_initials&gt;```OptionsEMACrossover(StrategyOptionsBaseV2)\n</code></pre> <p>Coding Conventions<ul> <li>Make a class with the same name as the file name</li> <li>Make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.</li> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every options strategy is a child class of the StrategyOptionsBaseV2 class.</li> </ul> </p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#strategy-info","title":"Strategy info","text":"<p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'OPTIONS'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' \n                    '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' \n                    '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> </li> </ul> <p>Note</p> <ul> <li>The parameter names and the number of parameters may change for different strategies.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#parameter-creation","title":"Parameter creation","text":"<p>Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE']\nself.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE']\nself._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE']\nself._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#parameter-validation","title":"Parameter validation","text":"<p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument      Checks a single parameter passed in it.      Syntax:          check_argument(value to be checked, 'extern_function', validating condition or method, error_message)          eg: </p> <pre><code> check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk      Checks multiple parameters passed in a list </p> <p>Syntax:    check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)      eg:</p> <pre><code> is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\n check_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>No of the strikes values are validated as follows:</p> <pre><code>no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')]\n\nfor no_of_strikes, text in no_of_strikes_list:\n    check_argument(no_of_strikes, 'extern_function', lambda x: 0 &lt;= x &lt;= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50')\n</code></pre> <p>Strike direction values are validated as follows:</p> <pre><code>strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')]\n\nfor strike_direction, text in strikes_direction_list:\n    check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM')\n</code></pre> <p>Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file.</p> <p>We define the below dictionary for <code>strike_direction</code>.</p> <pre><code>strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value}\n</code></pre> <p>Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value.</p> <pre><code>self.strike_direction_ce = strike_direction_map[self._strike_direction_ce]\nself.strike_direction_pe = strike_direction_map[self._strike_direction_pe]\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#start-time-and-end-time-creation","title":"Start time and End time creation","text":"<p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <p>try: <pre><code>    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> try: <pre><code>    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre></p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#strategy-variables","title":"Strategy variables","text":"<p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <pre><code>self.main_order = None            # We save the entry order in this variable\nself.stoploss_order = None        # We save the corresponding stoploss exit order of the entry order in this variable\n</code></pre> We initialize the variables with a None value.     !!! Note             There could be more strategy variables required as per the strategy requirement. </p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <pre><code>self.order_tag_manager = OrderTagManager\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#add_order","title":"add_order","text":"<ul> <li>Stores the order object for the given tags. eg:</li> </ul> <pre><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])\n</code></pre> <ul> <li>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#get_orders","title":"get_orders","text":"<ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <pre><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)\n</code></pre> <ul> <li>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#remove_tags","title":"remove_tags","text":"<ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <pre><code>self.order_tag_manager.remove_tags(tags=entry_key)\n</code></pre> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#remove_order","title":"remove_order","text":"<ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><pre><code>self.order_tag_manager.remove_order(main_order)\n</code></pre> Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#get_internals","title":"get_internals","text":"<pre><code>Returns the values i.e. both the entry and exit orders stored inside the tags list.\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#5-child-instruments-calculation","title":"5. Child instruments calculation","text":""},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#get_ltp","title":"get_ltp","text":"<p>Fetch the ltp of the base instrument (instrument in the YAML) <pre><code>ltp = self.broker.get_ltp(self.underlying_instrument)\n</code></pre></p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#options_instruments_set_up_local","title":"options_instruments_set_up_local","text":"<pre><code>Get the ATM ITM and OTM lists of the child instrument based on the LTP\n```\nself.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp)\n```\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#get_child_instrument_details","title":"get_child_instrument_details","text":"<pre><code>Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument\n```\nchild_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)\n```\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#6-entry-methods","title":"6. Entry Methods","text":""},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry","text":"<ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selectd_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#strategy_enter_position","title":"strategy_enter_position","text":"<ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#7-exit-methods","title":"7. Exit Methods","text":""},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit","text":"<ul> <li>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</li> <li>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#strategy_exit_position","title":"strategy_exit_position","text":"<ul> <li>Here is where we actually place the exit order for where we exit the order which was placed during entry. If the order is placed successfully we clear the order in a class variable such that we can add new orders to the vacant place in variable in the entry methods.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#8-other-common-methods","title":"8. Other common methods","text":"<p>There are other methods that are used in the strategy:</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#check_and_place_stoploss_order","title":"check_and_place_stoploss_order","text":"<p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#set_all_none","title":"set_all_none","text":"<p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#options_instruments_set_up_local_1","title":"options_instruments_set_up_local","text":"<p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. </p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#get_child_instrument_details_1","title":"get_child_instrument_details","text":"<p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch a single child instrument based on the no of strikes and strike direction.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#9-cleanup","title":"9. Cleanup","text":"<ol> <li> <p>Add comments and docstrings wherever possible to improve code readability.</p> </li> <li> <p>Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.**</p> </li> </ol> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/","title":"Regular Strategy Structure","text":"<p>Links</p> <ul> <li>Code Structure of Strategy (workflow of a strategy)</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#1-initial-steps","title":"1. Initial steps","text":""},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#create-a-new-strategy-file","title":"Create a new strategy file","text":"eg: strategy_<code>&lt;developer_initials&gt;</code>_futures_ema_crossover.py <p>Coding Conventions</p> <ul> <li>Keep a unique file name</li> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#naming-a-class","title":"Naming a Class","text":"<pre><code>eg: For the above strategy name the class name would be:\nStrategy```&lt;developer_initials&gt;```FuturesEMACrossover(StrategyBase)\n</code></pre> <p>Coding Conventions<ul> <li>Make a class with the same name as the file name</li> <li>Make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.</li> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy is a child class of the StrategyBase class.</li> </ul> </p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#strategy-info","title":"Strategy info","text":"<p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'FUTURES'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is FUTURES, REGULAR, or OPTIONS.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\\n                           '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may be different for different strategies.</li> </ul> </p> </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#parameter-creation","title":"Parameter creation","text":"<p>Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#parameter-validation","title":"Parameter validation","text":"<p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument     Checks a single parameter passed in it.     Syntax:         check_argument(value to be checked, 'extern_function', validating condition or method, error_message)         eg: </p> <pre><code>check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk     Checks multiple parameters passed in a list     Syntax:         check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)         eg: </p> <pre><code>is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int     Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float    Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int    Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float    Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#start-time-and-end-time-creation","title":"Start time and End time creation","text":"<p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file. try: <pre><code>    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> try:  <pre><code>    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre></p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#strategy-variables","title":"Strategy variables","text":"<p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <code>self.order_tag_manager = None</code> </p> <p>We initialize the variables with a None value.</p> <p>Note<p>There could be more strategy variables required as per the strategy requirement. </p> </p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#add_order","title":"add_order","text":"<ul> <li>Stores the order object for the given tags. eg: <pre><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])\n</code></pre></li> <li>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#get_orders","title":"get_orders","text":"<ul> <li>Retrieve the order(s) for the given tags. eg: <pre><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)\n</code></pre></li> <li>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#remove_tags","title":"remove_tags","text":"<ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag eg: <pre><code>self.order_tag_manager.remove_tags(tags=entry_key)\n</code></pre></li> <li>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</li> </ul> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags.</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#remove_order","title":"remove_order","text":"<ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s). eg:</li> </ul> <pre><code>self.order_tag_manager.remove_order(main_order)\n</code></pre> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#get_internals","title":"get_internals","text":"<ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.   </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#5-entry-methods","title":"5. Entry Methods","text":""},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry","text":"<ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selected_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#strategy_enter_position","title":"strategy_enter_position","text":"<ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#6-exit-methods","title":"6. Exit Methods","text":""},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit:","text":"<ul> <li>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</li> <li>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#strategy_exit_position","title":"strategy_exit_position","text":"<ul> <li>Here is where we actually place the exit order for where we exit the order which was placed during entry. If the order is placed successfully we clear the order in a class variable such that we can add new orders to the vacant place in variable in the entry methods.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#7-other-common-methods","title":"7. Other common methods","text":"<p>There are other methods that are used in the strategy:</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#check_and_place_stoploss_order","title":"check_and_place_stoploss_order","text":"<p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#set_all_none","title":"set_all_none","text":"<pre><code>This method is called in the ```strategy_exit_position``` when our entry order has exited, and we want to remove the order object from the ```self.main_order``` variable.\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#8-cleanup","title":"8. Cleanup","text":"<ol> <li> <p>Add comments and docstrings wherever possible to improve code readability.</p> </li> <li> <p>Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> </li> </ol> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"pyalgotrad/strategy_guides/structure/","title":"Code Structure of Strategy","text":""},{"location":"pyalgotrad/strategy_guides/structure/#previously","title":"Previously...","text":"<p>You now have the necessary prerequisites installed and ready.</p>"},{"location":"pyalgotrad/strategy_guides/structure/#now","title":"Now...","text":"<p>This page describes the methods you will use to create your strategy.</p>"},{"location":"pyalgotrad/strategy_guides/structure/#lets-start","title":"Let's Start...","text":"<p>You have the following methods.</p>"},{"location":"pyalgotrad/strategy_guides/structure/#methods","title":"Methods","text":"<ol> <li><code>strategy_select_instruments_for_entry()</code> - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy,  the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument,  allowing you to decide whether an order is to be punched for that particular instrument or not.</li> <li><code>strategy_enter_position()</code> - You can now punch your order in this method for each instrument that you have selected for entry in the previous method.</li> <li><code>strategy_select_instruments_for_exit()</code> - Once a position is entered for a particular instrument, the backend core calls this method for those  instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that  particular instrument is to be exited or not.</li> <li><code>strategy_exit_position()</code> - You can now exit positions in this method for each instrument that you have selected for exit in the previous method.</li> </ol>"},{"location":"pyalgotrad/strategy_guides/structure/#supporting-methods","title":"Supporting Methods","text":"<p>You have the following supporting methods:</p> <ol> <li><code>__init__()</code> - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy.   </li> <li><code>initialize()</code> - This method is called every time the strategy starts for the first time as well as the start of every trading day.  You may set initial values for the set of variables that you have declared in the previous method. </li> <li><code>name()</code> - This method sets a unique name for your strategy.</li> <li><code>versions_supported()</code> - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you.</li> </ol>"},{"location":"pyalgotrad/strategy_guides/structure/#utility-functions","title":"Utility Functions","text":"<p>You have the following utility function to be used in this strategy :</p> <ol> <li><code>get_crossover_value()</code> - A utility method available which calculates the crossover value. </li> </ol> <p>Links</p> <ul> <li>Strategy Structure (regular)</li> <li>Strategy Structure (options)</li> <li>List of Strategies</li> </ul>"},{"location":"pyalgotrad/strategy_guides/structure/#flowchart","title":"Flowchart","text":"<p>Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.</p> <p></p>"},{"location":"pyalgotrad/strategy_guides/structure/#whats-next","title":"What's Next...","text":"<p>Checkout the strategy guides for building a Regular Strategy or Options Strategy</p>"},{"location":"python_build/pyalgotrading_analytics/","title":"Pyalgotrading Analytics","text":""},{"location":"python_build/pyalgotrading_analytics/#metric-values-and-statistics","title":"Metric Values and Statistics","text":""},{"location":"python_build/pyalgotrading_analytics/#cumulative-returns","title":"Cumulative Returns","text":"<ul> <li>The Cumulative Returns chart illustrates how our strategy's returns value has evolved over time in percentage. </li> <li>Positive values indicate gains, while negatives reflect losses. Bigger positive returns are more favourable. </li> <li>Keep in mind, this chart focuses on gains and losses, excluding risk and timing considerations.</li> <li>There are 2 sub categories of cumulative returns chart depending on the scale we are using. One is normal scaled and other is log scaled </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#end-of-year-returns-eoy","title":"End of Year Returns (EoY)","text":"<ul> <li>The End of Year Returns chart showcases our strategy's annual performance as a percentage. </li> <li>It quantifies its overall performance, considering gains or losses throughout each year.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#distributions-of-monthly-returns-histogram","title":"Distributions of Monthly Returns (Histogram)","text":"<ul> <li>In the Monthly Returns Distribution Histogram, we see the frequency distribution of different levels of returns over consecutive months. </li> <li>This histogram helps us understand the range and patterns in monthly returns, shedding light on our strategy's volatility and performance trends.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#daily-returns","title":"Daily Returns","text":"<ul> <li>The Daily Returns Chart portrays the percentage change in our strategy's returns between trading days. </li> <li>It provides insights into short-term volatility, trend analysis, and risk assessment.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#rolling-volatility-6-months","title":"Rolling Volatility (6 months)","text":"<ul> <li>A Rolling Volatility (6 months) Plot showcases the changing volatility of an investment over time using a rolling window of six months. </li> <li>This plot reveals how the investment's price fluctuations vary as the window moves across the dataset. </li> <li>It provides insights into short-term volatility patterns, helping investors understand how the investment's risk level evolves in response to different market conditions.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#rolling-sharpe-6-months","title":"Rolling Sharpe (6 months)","text":"<ul> <li>A Rolling Sharpe (6 months) Plot illustrates the dynamic changes in the Sharpe ratio over time using a rolling window of six months. </li> <li>The plot shows how the risk-adjusted performance of an investment fluctuates as the window moves through the dataset. </li> <li>This visualization helps investors understand how the Sharpe ratio varies with changing market conditions and provides insights into the investment's consistency and risk-return trade-offs over short-term periods.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#rolling-sortino-6-months","title":"Rolling Sortino (6 months)","text":"<ul> <li>A Rolling Sortino (6 months) Plot visualizes the variation in the Sortino ratio over time using a rolling window of six months. </li> <li>This plot demonstrates how the investment's risk-adjusted performance, considering only downside volatility, changes as the window progresses through the data. </li> <li>It offers insights into how the Sortino ratio evolves with market conditions, helping investors assess the investment's ability to generate favorable risk-adjusted returns over short-term intervals.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#worst-5-drawdown-periods","title":"Worst 5 Drawdown Periods","text":"<ul> <li>A Worst 5 Drawdown Periods plot displays the top five periods during which the strategy experienced the largest declines from peak to trough. </li> <li>This visualization helps strategists understand the most significant loss-making episodes in the strategy's run. </li> <li>It shows the magnitude and duration of these drawdowns, providing insights into the strategy's risk and potential vulnerabilities.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#underwater-plot","title":"Underwater Plot","text":"<ul> <li>The Underwater Plot visually narrates our strategy's performance concerning its past peaks. </li> <li>It showcases how much our returns value has dropped from its highest point over time. </li> <li>This aids in visualising periods of drawdown and recovery, offering insights into historical risk and resilience.    </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#monthly-returns-heatmap","title":"Monthly Returns (Heatmap)","text":"<ul> <li>The Monthly Returns Heatmap offers a colour-coded view of our strategy's performance across months. </li> <li>Shades of green indicate positive returns, while shades of red signify losses. </li> <li>This visual tool helps spot trends and patterns, aiding in identifying strong and weak performance periods.    </li> </ul>"},{"location":"python_build/python-build-code-gen-ai/","title":"Code Using AI","text":"<p>If you have creative ideas in your mind and want to design a algotrading strategy but you are new at coding, don't worry, we have got it covered using our Python Build's Create Using AI feature which will help you to create trading strategies seamlessly.</p> <p>You can check here on how to get your Chat-GPT API key</p>"},{"location":"python_build/python-build-code-gen-ai/#set-your-gen-ai-api-keys-and-model","title":"Set your Gen-AI API keys and Model","text":"<ol> <li>Once you have retrieved the API key, you need to paste it in the input box for API keys.  </li> <li>Select the model of AI from the drop-down menu below.   </li> <li> <p>Click on the Save button to save your key and model and establish the connection.</p> <p></p> </li> </ol>"},{"location":"python_build/python-build-code-gen-ai/#enter-your-prompts","title":"Enter your Prompts","text":"<ol> <li>On the left hand side you can see the previous sessions and chat history</li> <li>Right below you will see a button for Prompts Library which has all the sample prompts that would generate wonderful strategies, you can pick any of them, if needed you can even tailor those prompts and use them.</li> <li>To start a new session click on New Session</li> <li>Enter your prompt or select from the sample prompts or take one prompt from the Prompts Library</li> <li>Click on the send button to start generating</li> </ol> <p>Please Note, It takes some time to generate the strategy as it processes a lot of data, so please be patient</p> <p></p>"},{"location":"python_build/python-build-code-gen-ai/#save-your-strategy","title":"Save your Strategy","text":"<ol> <li>Once it gives you the strategy you can ask it to make more changes as per your need or you can save it directly.</li> <li>To save, click on the top right corner of the code, you can even copy the code if you want.</li> <li>Once you save it, it will redirect you to a new page where you have save your strategy and update its configuration parameters from the parameter settings.</li> <li>All your saved strategies can be viewed in My Coded Strategies section in Python Build.     </li> </ol>"},{"location":"python_build/python-build-code-new/","title":"Code New Strategy","text":""},{"location":"python_build/python-build-code-new/#how-to-code-a-new-strategy","title":"How to code a new strategy?","text":"<p>If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section.</p> <p></p> <p>A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section.</p> <p></p> <p>Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view &amp; edit the strategy parameters.</p> <p>To test the behavior and performance of the strategy, click on Save &amp; Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section.</p> <p>You can rename a strategy by clicking the edit symbol beside the strategy name. </p> <p></p>"},{"location":"python_build/python-build-code-ready-templates/","title":"Code Ready Templates","text":""},{"location":"python_build/python-build-code-ready-templates/#how-to-code-strategies-using-ready-templates","title":"How to code strategies using Ready Templates?","text":"<p>Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates, click on More.</p> <p></p> <p>Click on the Code button placed in the bottom right corner of the selected template to view the strategy code.</p> <p></p> <p>You should now see the code editor, where you can start modifying the code as required.</p> <p></p> <p>To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies.</p> <p></p>"},{"location":"python_build/python-build-config-parameters/","title":"Configure and Execute your Strategy","text":""},{"location":"python_build/python-build-config-parameters/#configure-strategy-parameters","title":"Configure Strategy Parameters","text":"<p>You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section, you can view a strategy\u2019s parameters or edit these parameters too.</p> <p></p> <p>There 4 sections for configuring your parameters:</p>"},{"location":"python_build/python-build-config-parameters/#instruments","title":"Instruments","text":"<ul> <li>Here you can select the allowed exchanges from the drop box given on the left (eg: NASDAQ, NYSE, NSE etc.)</li> <li>Once you have selected the exchange you can search the instrument in the search-box right beside it</li> </ul>"},{"location":"python_build/python-build-config-parameters/#strategy-settings","title":"Strategy Settings","text":"<ul> <li>Here you can select the candle size, it is the size of candle on which you are running your strategy is going to be executed</li> <li>You can even select the mode i.e. INTRADAY or DELIVERY</li> </ul>"},{"location":"python_build/python-build-config-parameters/#order-settings","title":"Order Settings","text":"<ul> <li>You can adjust your orders, on how they will act when the strategy is 'Resumed' or strategy is 'Exited'</li> <li>Resume Positions from Start: If you have previous trades in your strategy, you can resume your strategy without deleting or overwriting them. Only applicable for DELIVERY mode.</li> <li>Exit Intraday Orders on Stop: If checked, strategy will square-off positions automatically at the end of each trading day.</li> <li>Max Order Count: Maximum number of orders your strategy will execute per day. Once this limit is completed for the day, all BUY/SELL signals for new orders would be automatically ignored.</li> <li>Crossover Accuracy Decimal: When running a crossover strategy, the number of decimals of the underlying indicators to be taken do decide an upward cut, downward cut or no cut.</li> <li>Credit Exposure Factor: Applicable only for Live Trading. Use this to set the exposure limit given by your broker. System will take available funds as 'current fund balance X credit exposure factor' for executing the strategy</li> </ul>"},{"location":"python_build/python-build-config-parameters/#user-parameters","title":"User Parameters","text":"<p>Use this option to pass various values of the strategy parameters from outside, without changing the code base for every execution. The are accessible as a dictionary called 'strategy_parameters' inside  your strategy class' constructor method.</p> <p>To know more about the parameters, click here.</p> <p>User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.</p> <p>Once Strategy and User Parameters are configured, you can follow these steps to execute your strategy.</p>"},{"location":"python_build/python-build-config-parameters/#follow-these-simple-steps-to-test-the-strategys-performance","title":"Follow these simple steps to test the strategy's performance","text":"<p>Step 1</p> <p>After clicking Save &amp; Start, a pop-up window will appear.</p> <p></p> <p>Step 2</p> <p>In the customizations section, choose Backtesting to backtest or Paper Trading to Paper Trade a strategy.</p> <p>Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting, you will need to put the start date and end date along with time.</p> <p></p> <p>In Paper Trading, you only need to add the start and end time.</p> <p></p> <p>Step 3</p> <p>In the Strategy Configuration section, you can check the parameters added or modified by you. </p> <p>Step 4</p> <p>To begin testing the strategy, click on Execute. </p> <p>Step 5</p> <p>Go to the Analytics section to see the returns and performance of the strategy visualized.</p> <p>Note:</p> <p>The use of Paper Trading would be available from Monday - Friday (excluding exchange's holidays) from 9 AM to 16:00 PM. You can code your strategy &amp; analyze the strategy results 24x7.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Go to the Logs section to see the step-by-step execution of the strategy in logs.</p> <p></p> <p></p> <p>You can rename a strategy by clicking the edit symbol beside the strategy name.</p> <p></p>"},{"location":"python_build/python-build-getstarted/","title":"Setup your Workspace","text":""},{"location":"python_build/python-build-getstarted/#how-to-get-started-with-python-build","title":"How to get started with Python Build?","text":"<p>To start developing your own strategy, you must first activate a plan from the Pricing section. Select the Developers tab in the Pricing section and select a plan of your choice. There is currently one developer plan available:</p> <p></p> <ul> <li>Advanced Developer Plan: Develop your own Algorithmic Trading Strategy for Free along with Analytics support, concurrent Strategy Executions, Professional Support, and more.</li> </ul> <p>After selecting your plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use the My Coded Strategies section to create your own strategies.</p>"},{"location":"python_build/python-build-introduction/","title":"Python Build Web","text":""},{"location":"python_build/python-build-introduction/#introduction","title":"Introduction","text":"<p>Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infrastructure so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak until you are satisfied with the performance. Get your strategy approved for live trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic.</p> <p>Select Python Build from the navigation bar on the left to know more.</p> <p></p>"},{"location":"python_build/python-build-introduction/#an-overview","title":"An overview","text":"<p>Running Strategies: This section shows how many strategies are currently active and running in your account. </p> <p>Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. </p> <p>Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies.</p> <p>Note:</p> <p>Paper Trading would be available from Monday - Friday (excluding NSE/NASDAQ holidays) within the trading time of that particular exchange. You can code your strategy, execute on Backtesting mode or analyse the strategy results 24x7.</p> <p>Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users.</p> <p>Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. </p> <p>Active Plan: This section displays the current plan active on your AlgoBulls account. </p> <p>Ready Templates: Ready-to-use templates that you can modify and test.</p> <p></p> <p>My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you.</p> <p></p> <p>Quick Help: Resources to help you code better.</p> <p></p>"},{"location":"python_build/python-build-view-results/","title":"Analytics in AlgoBulls Platform","text":""},{"location":"python_build/python-build-view-results/#how-to-view-the-results","title":"How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can switch to the Analytics tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Analytics: In the analytics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p>"},{"location":"python_build/python-build-view-results/#stats","title":"Stats","text":"<p>In this section you can see the total returns, sharpe ratio, sortino ratio, volatility, Max Drawdown, Total wins or Loses, Total short or long trades, hit ratio, number of trades, average trades per day, max profit, max loss, average profit per winning trade, average loss per losing trade. </p>"},{"location":"python_build/python-build-view-results/#cumulative-returns","title":"Cumulative Returns","text":""},{"location":"python_build/python-build-view-results/#profit-loss-currency-or","title":"Profit &amp; Loss (Currency or %)","text":"<p>The trade by trade P&amp;L in Currency or Percentage. </p>"},{"location":"python_build/python-build-view-results/#end-of-year-returns-plot","title":"End of Year Returns Plot (%)","text":""},{"location":"python_build/python-build-view-results/#monthly-returns-histogram","title":"Monthly Returns Histogram (%)","text":""},{"location":"python_build/python-build-view-results/#monthly-returns-heatmap","title":"Monthly Returns Heatmap (%)","text":""},{"location":"python_build/python-build-view-results/#daily-returns","title":"Daily Returns (%)","text":""},{"location":"python_build/python-build-view-results/#underwater-drawdown-plot","title":"Underwater Drawdown Plot (%)","text":""},{"location":"python_build/python-build-view-results/#pl-book","title":"P&amp;L Book","text":"<p>View detailed trade by trade report. Premium users can analyze this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades. </p>"},{"location":"python_build/python-build-view-results/#user-log","title":"User Log","text":"<p>Real-time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behavior and performance. </p>"},{"location":"python_build/python-build-view-results/#order-history","title":"Order History","text":"<p>View the order state transition for every order placed by your strategy in-depth. </p>"},{"location":"python_build/strategy_guides/common_options_strategy/","title":"Options Strategy Structure","text":"<p>Links</p> <ul> <li>Code Structure of Strategy (workflow of a strategy)</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#1-initial-steps","title":"1. Initial steps","text":""},{"location":"python_build/strategy_guides/common_options_strategy/#create-a-new-strategy-file","title":"Create a new strategy file","text":"eg: strategy_<code>&lt;developer_initials&gt;</code>_options_ema_crossover.py <p>Coding Conventions</p> <ul> <li>Keep a unique file name</li> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#naming-a-class","title":"Naming a Class","text":"<pre><code>eg: For the above strategy name the class name would be:\nStrategy```&lt;developer_initials&gt;```OptionsEMACrossover(StrategyOptionsBaseV2)\n</code></pre> <p>Coding Conventions<ul> <li>Make a class with the same name as the file name</li> <li>Make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.</li> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every options strategy is a child class of the StrategyOptionsBaseV2 class.</li> </ul> </p>"},{"location":"python_build/strategy_guides/common_options_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#strategy-info","title":"Strategy info","text":"<p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'OPTIONS'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' \n                    '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' \n                    '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> </li> </ul> <p>Note</p> <ul> <li>The parameter names and the number of parameters may change for different strategies.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#parameter-creation","title":"Parameter creation","text":"<p>Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE']\nself.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE']\nself._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE']\nself._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p>"},{"location":"python_build/strategy_guides/common_options_strategy/#parameter-validation","title":"Parameter validation","text":"<p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument      Checks a single parameter passed in it.      Syntax:          check_argument(value to be checked, 'extern_function', validating condition or method, error_message)          eg: </p> <pre><code> check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk      Checks multiple parameters passed in a list </p> <p>Syntax:    check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)      eg:</p> <pre><code> is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\n check_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>No of the strikes values are validated as follows:</p> <pre><code>no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')]\n\nfor no_of_strikes, text in no_of_strikes_list:\n    check_argument(no_of_strikes, 'extern_function', lambda x: 0 &lt;= x &lt;= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50')\n</code></pre> <p>Strike direction values are validated as follows:</p> <pre><code>strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')]\n\nfor strike_direction, text in strikes_direction_list:\n    check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM')\n</code></pre> <p>Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file.</p> <p>We define the below dictionary for <code>strike_direction</code>.</p> <pre><code>strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value}\n</code></pre> <p>Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value.</p> <pre><code>self.strike_direction_ce = strike_direction_map[self._strike_direction_ce]\nself.strike_direction_pe = strike_direction_map[self._strike_direction_pe]\n</code></pre>"},{"location":"python_build/strategy_guides/common_options_strategy/#start-time-and-end-time-creation","title":"Start time and End time creation","text":"<p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <p>try: <pre><code>    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> try: <pre><code>    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre></p>"},{"location":"python_build/strategy_guides/common_options_strategy/#strategy-variables","title":"Strategy variables","text":"<p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <pre><code>self.main_order = None            # We save the entry order in this variable\nself.stoploss_order = None        # We save the corresponding stoploss exit order of the entry order in this variable\n</code></pre> We initialize the variables with a None value.     !!! Note             There could be more strategy variables required as per the strategy requirement. </p>"},{"location":"python_build/strategy_guides/common_options_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <pre><code>self.order_tag_manager = OrderTagManager\n</code></pre>"},{"location":"python_build/strategy_guides/common_options_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#add_order","title":"add_order","text":"<ul> <li>Stores the order object for the given tags. eg:</li> </ul> <pre><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])\n</code></pre> <ul> <li>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#get_orders","title":"get_orders","text":"<ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <pre><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)\n</code></pre> <ul> <li>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#remove_tags","title":"remove_tags","text":"<ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <pre><code>self.order_tag_manager.remove_tags(tags=entry_key)\n</code></pre> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#remove_order","title":"remove_order","text":"<ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><pre><code>self.order_tag_manager.remove_order(main_order)\n</code></pre> Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#get_internals","title":"get_internals","text":"<pre><code>Returns the values i.e. both the entry and exit orders stored inside the tags list.\n</code></pre>"},{"location":"python_build/strategy_guides/common_options_strategy/#5-child-instruments-calculation","title":"5. Child instruments calculation","text":""},{"location":"python_build/strategy_guides/common_options_strategy/#get_ltp","title":"get_ltp","text":"<p>Fetch the ltp of the base instrument (instrument in the YAML) <pre><code>ltp = self.broker.get_ltp(self.underlying_instrument)\n</code></pre></p>"},{"location":"python_build/strategy_guides/common_options_strategy/#options_instruments_set_up_local","title":"options_instruments_set_up_local","text":"<pre><code>Get the ATM ITM and OTM lists of the child instrument based on the LTP\n```\nself.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp)\n```\n</code></pre>"},{"location":"python_build/strategy_guides/common_options_strategy/#get_child_instrument_details","title":"get_child_instrument_details","text":"<pre><code>Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument\n```\nchild_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)\n```\n</code></pre>"},{"location":"python_build/strategy_guides/common_options_strategy/#6-entry-methods","title":"6. Entry Methods","text":""},{"location":"python_build/strategy_guides/common_options_strategy/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry","text":"<ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selectd_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#strategy_enter_position","title":"strategy_enter_position","text":"<ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#7-exit-methods","title":"7. Exit Methods","text":""},{"location":"python_build/strategy_guides/common_options_strategy/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit","text":"<ul> <li>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</li> <li>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#strategy_exit_position","title":"strategy_exit_position","text":"<ul> <li>Here is where we actually place the exit order for where we exit the order which was placed during entry. If the order is placed successfully we clear the order in a class variable such that we can add new orders to the vacant place in variable in the entry methods.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#8-other-common-methods","title":"8. Other common methods","text":"<p>There are other methods that are used in the strategy:</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#check_and_place_stoploss_order","title":"check_and_place_stoploss_order","text":"<p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#set_all_none","title":"set_all_none","text":"<p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#options_instruments_set_up_local_1","title":"options_instruments_set_up_local","text":"<p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. </p>"},{"location":"python_build/strategy_guides/common_options_strategy/#get_child_instrument_details_1","title":"get_child_instrument_details","text":"<p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch a single child instrument based on the no of strikes and strike direction.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#9-cleanup","title":"9. Cleanup","text":"<ol> <li> <p>Add comments and docstrings wherever possible to improve code readability.</p> </li> <li> <p>Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.**</p> </li> </ol> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/","title":"Regular Strategy Structure","text":"<p>Links</p> <ul> <li>Code Structure of Strategy (workflow of a strategy)</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#1-initial-steps","title":"1. Initial steps","text":""},{"location":"python_build/strategy_guides/common_regular_strategy/#create-a-new-strategy-file","title":"Create a new strategy file","text":"eg: strategy_<code>&lt;developer_initials&gt;</code>_futures_ema_crossover.py <p>Coding Conventions</p> <ul> <li>Keep a unique file name</li> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#naming-a-class","title":"Naming a Class","text":"<pre><code>eg: For the above strategy name the class name would be:\nStrategy```&lt;developer_initials&gt;```FuturesEMACrossover(StrategyBase)\n</code></pre> <p>Coding Conventions<ul> <li>Make a class with the same name as the file name</li> <li>Make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.</li> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy is a child class of the StrategyBase class.</li> </ul> </p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#strategy-info","title":"Strategy info","text":"<p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'FUTURES'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is FUTURES, REGULAR, or OPTIONS.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\\n                           '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may be different for different strategies.</li> </ul> </p> </li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#parameter-creation","title":"Parameter creation","text":"<p>Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#parameter-validation","title":"Parameter validation","text":"<p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument     Checks a single parameter passed in it.     Syntax:         check_argument(value to be checked, 'extern_function', validating condition or method, error_message)         eg: </p> <pre><code>check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk     Checks multiple parameters passed in a list     Syntax:         check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)         eg: </p> <pre><code>is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int     Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float    Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int    Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float    Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#start-time-and-end-time-creation","title":"Start time and End time creation","text":"<p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file. try: <pre><code>    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> try:  <pre><code>    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre></p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#strategy-variables","title":"Strategy variables","text":"<p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <code>self.order_tag_manager = None</code> </p> <p>We initialize the variables with a None value.</p> <p>Note<p>There could be more strategy variables required as per the strategy requirement. </p> </p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#add_order","title":"add_order","text":"<ul> <li>Stores the order object for the given tags. eg: <pre><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])\n</code></pre></li> <li>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#get_orders","title":"get_orders","text":"<ul> <li>Retrieve the order(s) for the given tags. eg: <pre><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)\n</code></pre></li> <li>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#remove_tags","title":"remove_tags","text":"<ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag eg: <pre><code>self.order_tag_manager.remove_tags(tags=entry_key)\n</code></pre></li> <li>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</li> </ul> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags.</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#remove_order","title":"remove_order","text":"<ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s). eg:</li> </ul> <pre><code>self.order_tag_manager.remove_order(main_order)\n</code></pre> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#get_internals","title":"get_internals","text":"<ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.   </li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#5-entry-methods","title":"5. Entry Methods","text":""},{"location":"python_build/strategy_guides/common_regular_strategy/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry","text":"<ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selected_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#strategy_enter_position","title":"strategy_enter_position","text":"<ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#6-exit-methods","title":"6. Exit Methods","text":""},{"location":"python_build/strategy_guides/common_regular_strategy/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit:","text":"<ul> <li>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</li> <li>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#strategy_exit_position","title":"strategy_exit_position","text":"<ul> <li>Here is where we actually place the exit order for where we exit the order which was placed during entry. If the order is placed successfully we clear the order in a class variable such that we can add new orders to the vacant place in variable in the entry methods.</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#7-other-common-methods","title":"7. Other common methods","text":"<p>There are other methods that are used in the strategy:</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#check_and_place_stoploss_order","title":"check_and_place_stoploss_order","text":"<p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#set_all_none","title":"set_all_none","text":"<pre><code>This method is called in the ```strategy_exit_position``` when our entry order has exited, and we want to remove the order object from the ```self.main_order``` variable.\n</code></pre>"},{"location":"python_build/strategy_guides/common_regular_strategy/#8-cleanup","title":"8. Cleanup","text":"<ol> <li> <p>Add comments and docstrings wherever possible to improve code readability.</p> </li> <li> <p>Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> </li> </ol> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"python_build/strategy_guides/structure/","title":"Code Structure of Strategy","text":""},{"location":"python_build/strategy_guides/structure/#previously","title":"Previously...","text":"<p>You now have the necessary prerequisites installed and ready.</p>"},{"location":"python_build/strategy_guides/structure/#now","title":"Now...","text":"<p>This page describes the methods you will use to create your strategy.</p>"},{"location":"python_build/strategy_guides/structure/#lets-start","title":"Let's Start...","text":"<p>You have the following methods.</p>"},{"location":"python_build/strategy_guides/structure/#methods","title":"Methods","text":"<ol> <li><code>strategy_select_instruments_for_entry()</code> - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy,  the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument,  allowing you to decide whether an order is to be punched for that particular instrument or not.</li> <li><code>strategy_enter_position()</code> - You can now punch your order in this method for each instrument that you have selected for entry in the previous method.</li> <li><code>strategy_select_instruments_for_exit()</code> - Once a position is entered for a particular instrument, the backend core calls this method for those  instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that  particular instrument is to be exited or not.</li> <li><code>strategy_exit_position()</code> - You can now exit positions in this method for each instrument that you have selected for exit in the previous method.</li> </ol>"},{"location":"python_build/strategy_guides/structure/#supporting-methods","title":"Supporting Methods","text":"<p>You have the following supporting methods:</p> <ol> <li><code>__init__()</code> - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy.   </li> <li><code>initialize()</code> - This method is called every time the strategy starts for the first time as well as the start of every trading day.  You may set initial values for the set of variables that you have declared in the previous method. </li> <li><code>name()</code> - This method sets a unique name for your strategy.</li> <li><code>versions_supported()</code> - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you.</li> </ol>"},{"location":"python_build/strategy_guides/structure/#utility-functions","title":"Utility Functions","text":"<p>You have the following utility function to be used in this strategy :</p> <ol> <li><code>get_crossover_value()</code> - A utility method available which calculates the crossover value. </li> </ol> <p>Links</p> <ul> <li>Strategy Structure (regular)</li> <li>Strategy Structure (options)</li> <li>List of Strategies</li> </ul>"},{"location":"python_build/strategy_guides/structure/#flowchart","title":"Flowchart","text":"<p>Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.</p> <p></p>"},{"location":"python_build/strategy_guides/structure/#whats-next","title":"What's Next...","text":"<p>Checkout the strategy guides for building a Regular Strategy or Options Strategy</p>"},{"location":"strategies/aroon_crossover/","title":"Aroon Crossover","text":"<p>This is a trading strategy called \"Aroon Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Aroon indicator crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/aroon_crossover/#aroon-indicator","title":"Aroon Indicator","text":"<ul> <li> <p>In the stock market, Aroon refers to the Aroon indicator, which is a technical analysis tool used to measure the strength and direction of a trend. It consists of two lines, the Aroon-Up line and the Aroon-Down line.</p> </li> <li> <p>The Aroon-Up line measures the number of periods since the highest price within a given period, while the Aroon-Down line measures the number of periods since the lowest price within a given period. The Aroon indicator ranges from 0 to 100, with values closer to 100 indicating a strong trend and values closer to 0 indicating a weak or non-existent trend.</p> </li> <li> <p>Traders and investors use the Aroon indicator to identify potential trend reversals, assess the strength of a trend, and generate buy or sell signals. For example, when the Aroon-Up line crosses above the Aroon-Down line, it may suggest a bullish trend, while a cross below may indicate a bearish trend.</p> </li> <li> <p>It is important to note that the Aroon indicator is just one of many tools used in technical analysis, and its effectiveness can vary depending on market conditions and other factors. It is often used in conjunction with other indicators and analysis techniques to make informed trading decisions.</p> </li> </ul> Fig.1 - SPY candle chart (top), Aroon Indicator for that chart (bottom)"},{"location":"strategies/aroon_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy, called Aroon Crossover, implements a crossover strategy using the Aroon indicator. It generates entry and exit signals based on the crossover of Aroon Up and Aroon Down values.</p>"},{"location":"strategies/aroon_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD None greater than 0 The period for which we calculate the Aroon Value"},{"location":"strategies/aroon_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the Aroon Up and Aroon Down values for a given instrument based on the historical data. It uses the <code>talib.AROON</code> function from the Talib library to calculate the values. The method then determines the crossover of Aroon Up and Aroon Down and returns the corresponding entry or exit action.</p>"},{"location":"strategies/bollinger_bands/","title":"Bollinger Bands","text":"<p>This is a trading strategy called \"Bollinger Bands\" implemented in Python using the PyAlgoTrading library. The strategy is based on the bollinger bands indicator values.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/bollinger_bands/#bollinger-bands-indicator","title":"Bollinger Bands Indicator","text":"<p>Bollinger Bands consists of a middle band (typically a 20-day Simple Moving Average) and two bands that represent the upper and lower price boundaries based on standard deviations. The bands adjust dynamically with market volatility.</p> <p>Key points about Bollinger Bands:</p> <ul> <li>The middle band is a moving average, while the upper and lower bands are calculated by adding/subtracting standard deviations from the middle band.</li> <li>Bollinger Bands help assess price volatility and identify potential overbought or oversold market conditions.</li> <li>A narrowing of the bands (Bollinger Squeeze) suggests low volatility, often followed by increased volatility and potential price breakout.</li> <li>Touching or exceeding the upper band may indicate an overbought market, while touching or falling below the lower band may suggest an oversold market.</li> <li>Price reversals can be observed when the price moves from one band to the other.</li> <li>The upper and lower bands can act as dynamic support and resistance levels.</li> <li>Bollinger Bands are used in combination with other indicators and analysis techniques to make trading decisions. They are not a standalone strategy but provide valuable insights when combined with other tools like the RSI.</li> </ul> Fig.1 - SPY candle chart (top) with Bollinger Bands (purple), 20 day standard deviation graph (bottom)"},{"location":"strategies/bollinger_bands/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy, called Bollinger Bands, is an implementation of the Bollinger Bands indicator. It uses the Bollinger Bands values to compare with previous candle's OPEN, HIGH, LOW and CLOSE values and generate entry and exit signals for trading instruments.</p>"},{"location":"strategies/bollinger_bands/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD None greater than 0 Period (number of candles) by which Bollinger Bands are calculated STANDARD_DEVIATION None between 0 to 10 Standard deviation (in percent) for upper and lower band from the signal bands"},{"location":"strategies/bollinger_bands/#decision-calculation","title":"Decision Calculation","text":"<p>The <code>get_decision</code> method calculates the Bollinger Bands values for a given instrument based on the OHLC (Open, High, Low, Close) historical data. It uses the <code>talib.BBANDS</code> function from the Talib library to calculate the upper and lower bands. The method compares the previous candle's open, low, and close values with the upper and lower bands to determine the entry or exit action. If the conditions for a buy or sell signal are met, the corresponding action is returned.</p>"},{"location":"strategies/ema_crossover/","title":"EMA Crossover","text":"<p>This is a trading strategy called \"EMA Regular Order Strategy\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/ema_crossover/#ema-indicator","title":"EMA indicator","text":"<p>Exponential Moving Averages (EMAs) are a popular technical analysis tool used in the stock market. They are similar to Simple Moving Averages (SMAs), but they place greater emphasis on recent price data.</p> <p>Here is a summary of Exponential Moving Averages:</p> <ul> <li>An Exponential Moving Average is a type of moving average that assigns more weight to recent prices, making it more responsive to current market conditions.</li> <li>Unlike the SMA, which gives equal weight to all data points, the EMA assigns exponentially decreasing weights to older data points.</li> <li>The formula for calculating an EMA involves using a smoothing factor or multiplier that determines the weight given to the previous EMA value and the current price.</li> <li>The most common period used for EMAs is 12 and 26 days, representing short-term and long-term trends, respectively.</li> <li>EMAs are commonly used to identify trend direction, support and resistance levels, and potential entry or exit points.</li> <li>When the price crosses above the EMA, it may signal a bullish trend, while a cross below the EMA may suggest a bearish trend.</li> <li>The EMA is more responsive to price changes compared to the SMA, making it useful for short-term trading strategies.</li> <li>EMAs are often used in conjunction with other technical indicators, such as the Moving Average Convergence Divergence (MACD), to generate trading signals.</li> <li>Traders and investors use Exponential Moving Averages to smooth out price fluctuations, identify trend reversals, and determine potential support and resistance levels. They provide a visual representation of the average price over a specific period, with greater weight given to recent prices.</li> </ul> Fig.1 - IBM candle chart (top) with EMA (green) and SMA (red) lines"},{"location":"strategies/ema_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy, called EMA Regular Order Strategy, implements a crossover strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the crossover of two EMAs.</p>"},{"location":"strategies/ema_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD1 None greater than 0 Period (number of candles) by which EMA-1 is calculated TIME_PERIOD2 None greater than 0 Period (number of candles) by which EMA-2 is calculated"},{"location":"strategies/ema_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover value based on the two EMAs of the closing prices. It uses the <code>talib.EMA</code> function from the Talib library to calculate the EMAs. The method then determines the crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).</p>"},{"location":"strategies/inverse_ema_scalping/","title":"Inverse EMA Scalping","text":"<p>This is a trading strategy called \"Inverse EMA Scalping Regular Order Strategy\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/inverse_ema_scalping/#what-is-inverse-ema","title":"What is Inverse EMA","text":"<p>Inverse EMA, also known as Reverse Exponential Moving Average (REMA), is a variation of the Exponential Moving Average (EMA) in the stock market. While the EMA gives more weight to recent price data, the Inverse EMA assigns more weight to older data points.</p> <p>Here is a summary of Inverse EMA:</p> <ul> <li>Inverse EMA is calculated by applying the EMA formula in reverse, giving greater weight to older data points and less weight to recent prices.</li> <li>Instead of smoothing out price fluctuations like the EMA, the Inverse EMA amplifies them, making it more responsive to historical data.</li> <li>The formula for calculating Inverse EMA is similar to the EMA, but it uses a different smoothing factor or multiplier that assigns higher weight to older data points.</li> <li>The Inverse EMA is primarily used to identify historical patterns and potential turning points in the market.</li> <li>When the price crosses above the Inverse EMA, it may suggest a potential reversal from a downtrend to an uptrend, and vice versa when the price crosses below the Inverse EMA.</li> <li>Inverse EMA is not as widely used as the EMA or other moving averages, and its applications may vary among traders and analysts.</li> <li>Inverse EMA is a less commonly used variation of the Exponential Moving Average. While the EMA is designed to provide a smoothed average of recent prices, the Inverse EMA emphasizes historical data, potentially highlighting significant turning points in the market. Traders and analysts who utilize the Inverse EMA may incorporate it into their technical analysis toolkit to complement other indicators and gain insights into price reversals and historical patterns.</li> </ul>"},{"location":"strategies/inverse_ema_scalping/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy implements a scalping strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the inverse crossover of two EMAs.</p>"},{"location":"strategies/inverse_ema_scalping/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description LARGER_TIME_PERIOD None greater than 0 Period (number of candles) by which large period EMA is calculated SMALLER_TIME_PERIOD None greater than 0 Period (number of candles) by which short period EMA is calculated"},{"location":"strategies/inverse_ema_scalping/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover value based on the inverse crossover of the two EMAs of the closing prices. It uses the <code>talib.EMA</code> function from the Talib library to calculate the EMAs. The method then determines the inverse crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).</p>"},{"location":"strategies/options_bear_call_ladder/","title":"Options Bear Call Ladder","text":""},{"location":"strategies/options_bear_call_ladder/#options-bear-call-ladder","title":"Options Bear Call Ladder","text":"<p>This class implements the Options Bear Call Ladder strategy.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bear_call_ladder/#bear-call-ladder","title":"Bear Call Ladder","text":"<ul> <li> <p>In the stock market, an options bear call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bearish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions.</p> </li> <li> <p>To create a bear call ladder, an investor typically does the following:</p> <ol> <li>Sells a lower strike call option.</li> <li>Buys two higher strike call options.</li> <li>Sells a final even higher strike call option.</li> </ol> </li> <li> <p>The bear call ladder aims to generate a limited profit if the price of the underlying asset remains below the middle strike price at expiration. The strategy benefits from time decay and a moderate decrease in the price of the underlying asset.</p> </li> <li> <p>The maximum profit potential of the bear call ladder is achieved when the price of the underlying asset is below the middle strike price at expiration. If the price declines further, the profit potential remains limited. However, if the price rises above the higher strike price, the strategy can result in losses.</p> </li> <li> <p>The key feature of the bear call ladder is the combination of short call options, which generate premium income, and long call options, which provide protection against unlimited losses in case the price of the underlying asset rises sharply.</p> </li> <li> <p>Traders implementing the bear call ladder strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> <li> <p>Please be aware that options trading can be complex and involves significant risks. It is always recommended to consult with a qualified financial advisor or broker before engaging in options trading activities.</p> </li> </ul>"},{"location":"strategies/options_bear_call_ladder/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 0 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bear_put_ladder/","title":"Options Bear Put Ladder","text":""},{"location":"strategies/options_bear_put_ladder/#options-bear-put-ladder","title":"Options Bear Put Ladder","text":"<p>This is a template for the Options Bear Put Ladder strategy. The strategy involves the combination of buying and selling put options to profit from a downward price movement in the underlying asset. It utilizes multiple legs with different strike prices and transaction types to create a ladder-like structure.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bear_put_ladder/#bear-put-ladder","title":"Bear Put Ladder","text":"<ul> <li> <p>In the stock market, an options bear put ladder is a strategy that combines buying and selling put options with different strike prices to profit from a moderate bearish view on the underlying asset. It involves a mix of long and short put positions.</p> </li> <li> <p>To implement a bear put ladder strategy, an investor generally follows these steps:</p> <ol> <li>Buys a put option with a lower strike price.</li> <li>Sells two put options with higher strike prices.</li> <li>Buys a final put option with an even higher strike price.</li> </ol> </li> <li> <p>The goal of the bear put ladder is to generate a limited profit if the price of the underlying asset remains below the middle strike price at expiration. The strategy benefits from time decay and a moderate decline in the price of the underlying asset.</p> </li> <li> <p>The maximum profit potential is reached when the price of the underlying asset is below the middle strike price at expiration. If the price continues to decrease, the profit potential remains limited. However, if the price rises above the higher strike price, the strategy can result in losses.</p> </li> <li> <p>The bear put ladder strategy combines short put options to generate premium income and long put options to provide protection against significant losses in case the price of the underlying asset declines substantially.</p> </li> <li> <p>Traders implementing the bear put ladder strategy should consider factors such as the strike prices, premium costs, and expiration date to assess the risk-reward profile. It's crucial to have a comprehensive understanding of options trading and associated risks before employing this strategy in the stock market.</p> </li> <li> <p>Keep in mind that options trading can be complex and involves substantial risks. It is advisable to consult with a qualified financial advisor or broker before engaging in options trading activities.</p> </li> </ul>"},{"location":"strategies/options_bear_put_ladder/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 0 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bull_call_ladder/","title":"Options Bull Call Ladder","text":""},{"location":"strategies/options_bull_call_ladder/#options-bull-call-ladder","title":"Options Bull Call Ladder","text":"<p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bull_call_ladder/#bull-call-ladder","title":"Bull Call Ladder","text":"<ul> <li> <p>In the stock market, an options bull call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions.</p> </li> <li> <p>To create a bull call ladder, an investor typically does the following:</p> <ol> <li>Buys a lower strike call option.</li> <li>Sells two higher strike call options.</li> <li>Buys a final even higher strike call option.</li> </ol> </li> <li> <p>The key feature of the bull call ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay.</p> </li> <li> <p>The profit potential of the bull call ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited.</p> </li> <li> <p>On the other hand, if the price of the underlying asset remains below the lower strike price or declines, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price.</p> </li> <li> <p>The bull call ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile.</p> </li> <li> <p>It is important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> </ul>"},{"location":"strategies/options_bull_call_ladder/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 4 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bull_put_ladder/","title":"Options Bull Put Ladder","text":""},{"location":"strategies/options_bull_put_ladder/#options-bull-put-ladder","title":"Options Bull Put Ladder","text":"<p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bull_put_ladder/#bull-put-ladder","title":"Bull Put ladder","text":"<ul> <li> <p>In the stock market, an options bull put ladder is a strategy that involves buying and selling put options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short put positions.</p> </li> <li> <p>To create a bull put ladder, an investor typically does the following:</p> <ol> <li>Sells a higher strike put option.</li> <li>Buys two lower strike put options.</li> <li>Sells a final even lower strike put option.</li> </ol> </li> <li> <p>The key feature of the bull put ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay.</p> </li> <li> <p>The profit potential of the bull put ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited.</p> </li> <li> <p>On the other hand, if the price of the underlying asset remains above the higher strike price or increases, the strategy can result in losses. The maximum loss occurs if the price rises above the higher strike price.</p> </li> <li> <p>The bull put ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile.</p> </li> <li> <p>It is important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> </ul>"},{"location":"strategies/options_bull_put_ladder/#initialization","title":"Initialization","text":"<p>The <code>__init__</code> method initializes the strategy and accepts parameters for configuring the strategy. The parameters are:</p> Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 4 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bull_put_ladder/#additional-notes","title":"Additional Notes","text":"<ul> <li> <p>The <code>transaction_type_map</code>, <code>tradingsymbol_suffix_map</code>, and <code>strike_direction_map</code> dictionaries are used for mapping transaction types, trading symbol suffixes, and strike directions, respectively.</p> </li> <li> <p>The strategy supports a single allowed expiry date, which can be modified for multiple expiry dates.</p> </li> <li> <p>The strategy uses the <code>get_options_instrument_with_strike_direction</code> method from the base class to fetch child instruments.</p> </li> <li> <p>The <code>initialize</code> method sets up the list of instruments processed for the day.</p> </li> <li> <p>The <code>options_instruments_set_up_local</code> method sets up the Call and Put Options instruments for a given base instrument.</p> </li> <li> <p>The <code>strategy_select_instruments_for_entry</code> method selects instruments for entry by setting up child instruments and appending them to the selected instruments list.</p> </li> <li> <p>The <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"strategies/options_long_iron_butterfly/","title":"Options Long Iron Butterfly","text":""},{"location":"strategies/options_long_iron_butterfly/#options-long-iron-butterfly","title":"Options Long Iron Butterfly","text":"<p>This is a template for implementing the Options Long Iron Butterfly strategy in Python.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_long_iron_butterfly/#long-iron-butterfly","title":"Long Iron Butterfly","text":"<ul> <li> <p>In the stock market, an options long iron butterfly is a complex strategy that involves buying two options with the same expiration date but different strike prices. It combines elements of both a bullish and bearish strategy and is designed to profit from low volatility in the underlying asset.</p> </li> <li> <p>To create a long iron butterfly, an investor typically does the following:</p> <ol> <li>Buys an at-the-money (ATM) put option.</li> <li>Buys an ATM call option.</li> <li>Sells an out-of-the-money (OTM) put option with a lower strike price.</li> <li>Sells an OTM call option with a higher strike price.</li> </ol> </li> <li> <p>The key feature of the long iron butterfly is that the sold options (OTM put and OTM call) help offset the cost of the purchased options (ATM put and ATM call). This results in a limited-risk, limited-reward strategy.</p> </li> <li> <p>The strategy profits when the price of the underlying asset remains within a specific range, known as the \"profit zone.\" The profit zone is determined by the strike prices of the options involved in the strategy. If the price of the underlying asset is within this range at expiration, the investor can achieve the maximum profit.</p> </li> <li> <p>However, if the price of the underlying asset moves significantly beyond the profit zone, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price or rises above the higher strike price.</p> </li> <li> <p>The long iron butterfly is commonly used when traders anticipate low volatility in the underlying asset. It is a neutral strategy that seeks to benefit from the passage of time and a decrease in implied volatility. Traders implementing this strategy should carefully analyze factors such as the strike prices, premium costs, and expiration date to determine their risk-reward profile.</p> </li> <li> <p>It is important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> </ul>"},{"location":"strategies/options_long_iron_butterfly/#strategy-parameters","title":"Strategy Parameters","text":"<p>The strategy accepts the following parameters:</p> Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_FOUR_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_FOUR_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_FOUR_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_FOUR_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_straddle/","title":"Options Straddle","text":""},{"location":"strategies/options_straddle/#options-straddle","title":"Options Straddle","text":"<p>This class represents the implementation of an options straddle trading strategy.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_straddle/#straddle-options","title":"Straddle Options","text":"<ul> <li> <p>In the stock market, an options straddle is a strategy where an investor simultaneously purchases a call option and a put option with the same strike price and expiration date on a particular underlying asset, such as a stock. The purpose of this strategy is to profit from significant price movements in the underlying asset, regardless of whether the price goes up or down.</p> </li> <li> <p>By using an options straddle, the investor is essentially betting on volatility rather than the direction of the price movement. If the price of the underlying asset experiences a substantial increase or decrease, either the call or put option will generate profits, offsetting any losses from the other option. The potential for profit is highest when there is a significant price swing, while the risk is limited to the cost of purchasing the options.</p> </li> <li> <p>This strategy is often employed when traders anticipate an upcoming event or announcement that could cause significant market volatility, such as earnings reports or regulatory decisions. The goal is to take advantage of the resulting price movement, regardless of whether it is upward or downward.</p> </li> <li> <p>It is important to note that options straddles can be risky as they require significant price movements to be profitable. If the price remains relatively stable, the trader may experience losses due to the cost of purchasing the options. Therefore, careful consideration of market conditions and risk management is crucial when implementing an options straddle strategy.</p> </li> </ul>"},{"location":"strategies/options_straddle/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description _leg_one_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_one_tradingsymbol_suffix 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_one_strike_direction 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_one_number_of_strikes 0 greater than 0 Number of strikes for leg one. _leg_two_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_two_tradingsymbol_suffix 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_two_strike_direction 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_two_number_of_strikes 0 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_strangle/","title":"Options Strangle","text":""},{"location":"strategies/options_strangle/#options-strangle","title":"Options Strangle","text":"<p>The <code>StrategyOptionsStrangle</code> class is a strategy template for trading options strangles. It is derived from the <code>StrategyOptionsBaseV2</code> class.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_strangle/#strangle-options","title":"Strangle Options","text":"<ul> <li> <p>In the stock market, an options strangle is a strategy where an investor simultaneously buys or sells a call option and a put option on the same underlying asset but with different strike prices and the same expiration date. The purpose of this strategy is to profit from significant price volatility in the underlying asset.</p> </li> <li> <p>Unlike an options straddle, which involves purchasing options at the same strike price, an options strangle involves selecting different strike prices. Typically, the investor buys an out-of-the-money call option (with a strike price above the current market price) and an out-of-the-money put option (with a strike price below the current market price).</p> </li> <li> <p>The strategy aims to benefit from a significant price movement in either direction. If the price of the underlying asset moves significantly upwards, the call option can generate profits. Conversely, if the price moves significantly downwards, the put option can generate profits. The investor is essentially betting on increased price volatility rather than predicting the direction of the price movement.</p> </li> <li> <p>Options strangles are commonly used when traders anticipate a substantial price movement but are unsure about the direction. This strategy allows for potential profits in either an upward or downward market scenario. However, it is important to note that options strangles can involve higher risks, as the underlying asset's price must move significantly to offset the cost of purchasing both options.</p> </li> <li> <p>Traders employing options strangles should carefully consider factors such as the expected price volatility, the expiration date, and the costs associated with purchasing the options. Implementing risk management techniques and monitoring market conditions are essential when utilizing an options strangle strategy.</p> </li> </ul>"},{"location":"strategies/options_strangle/#parameters","title":"Parameters","text":"<p>The following parameters can be set in the Parameters Configuration Pane:</p> Name Default Value Expected Value Description _leg_one_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_one_tradingsymbol_suffix 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_one_strike_direction 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_one_number_of_strikes 2 greater than 0 Number of strikes for leg one. _leg_two_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_two_tradingsymbol_suffix 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_two_strike_direction 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_two_number_of_strikes 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/reverse_rsi/","title":"Reverse RSI","text":"<p>This is a trading strategy called \"Reverse RSI\" implemented in Python using the PyAlgoTrading library. The strategy is based on the relative strength index indicator.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/reverse_rsi/#relative-strength-index","title":"Relative Strength Index","text":"<p>RSI stands for Relative Strength Index, and it is a popular technical indicator used in the stock market to analyze the strength and momentum of a price trend. The RSI provides insights into whether a stock is overbought or oversold and can help identify potential trend reversals.</p> <p>Here is a summary of RSI in the stock market:</p> <ul> <li>The Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements.</li> <li>It compares the magnitude of recent gains to recent losses over a specified period, typically 14 days, and generates a value between 0 and 100.</li> <li>The RSI is calculated using a formula that involves averaging the upward price movements (gains) and the downward price movements (losses) over the chosen period.</li> <li>A high RSI value (typically above 70) indicates that a stock is overbought, meaning it may have experienced a significant price increase and could be due for a correction or pullback.</li> <li>Conversely, a low RSI value (typically below 30) suggests that a stock is oversold, indicating it may have experienced a significant price decline and could be poised for a potential rebound or upward move.</li> <li>Traders often use RSI as a tool to identify potential trend reversals, as extreme RSI readings (above 70 or below 30) can signal a potential change in the direction of the price trend.</li> <li>Additionally, traders may look for bullish or bearish divergences between the RSI and the price chart, which can provide further indications of a potential trend reversal.</li> <li>The RSI is just one tool among many in technical analysis, and it is often used in conjunction with other indicators and analysis techniques to make more informed trading decisions.</li> </ul> <p>Overall, the Relative Strength Index (RSI) is a widely used indicator in the stock market to assess the strength and momentum of price movements. It helps traders identify overbought and oversold conditions, as well as potential trend reversals, which can assist in making trading decisions.</p> Fig.1 - MCD candle chart (top) and RSI plot (bottom)"},{"location":"strategies/reverse_rsi/#strategy-overview","title":"Strategy Overview","text":"<p>The Reverse RSI strategy is a trading strategy based on the Relative Strength Index (RSI) indicator. It generates entry and exit signals based on the reverse crossover of the RSI values from specified overbought and oversold levels.</p>"},{"location":"strategies/reverse_rsi/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD None greater than 0 Period (number of candles) by which RSI is calculated OVERBOUGHT_VALUE None greater than 0 RSI value above which stocks are considered over-bought OVERSOLD_VALUE None greater than 0 RSI value below which stocks are considered over-sold"},{"location":"strategies/reverse_rsi/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover values for the RSI indicator using historical data of the instrument. It compares the RSI values with the overbought and oversold levels to determine the entry and exit actions. The method returns the crossover values for oversold and overbought levels.</p>"},{"location":"strategies/stochastic_crossover/","title":"Stochastic Crossover","text":"<p>This is a trading strategy called \"Stochastic Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Stochastic indicator crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/stochastic_crossover/#stochastic-oscillator-indicator","title":"Stochastic Oscillator Indicator","text":"<p>In the stock market, Stochastic refers to the Stochastic Oscillator, which is a popular technical indicator used to analyze price momentum and identify potential trend reversals. The Stochastic Oscillator compares the closing price of a security to its price range over a specific period of time. It consists of two lines, %K and %D, and generates values between 0 and 100.</p> <p>Here is a summary of the Stochastic Oscillator in the stock market:</p> <ul> <li>The Stochastic Oscillator measures the relationship between a security's closing price and its price range over a chosen period.</li> <li>The indicator consists of two lines: %K and %D. %K represents the current closing price relative to the price range, while %D is a smoothed average of %K.</li> <li>The Stochastic Oscillator is bound between 0 and 100. Readings above 80 are typically considered overbought, suggesting a potential price decline or correction. Readings below 20 are often considered oversold, indicating a potential price increase or rebound.</li> <li>Traders use the Stochastic Oscillator to identify potential trend reversals, as overbought or oversold conditions can indicate a possible change in the direction of the price trend.</li> <li>The indicator also generates bullish or bearish divergences, where the price trend and the Stochastic lines move in opposite directions, which can signal a potential trend reversal.</li> <li>The Stochastic Oscillator has various trading strategies associated with it, such as crossovers, overbought/oversold levels, and divergences, which traders use to make buy or sell decisions.</li> <li>It is important to note that the Stochastic Oscillator is a lagging indicator, meaning it may not provide precise timing for trade entries or exits. Therefore, it is often used in conjunction with other indicators and analysis techniques to confirm signals and improve the accuracy of trading decisions.</li> <li>Overall, the Stochastic Oscillator is a widely used technical indicator in the stock market that helps traders assess price momentum, identify overbought and oversold conditions, and spot potential trend reversals. By analyzing the relationship between the closing price and price range, traders can gain insights into potential buying or selling opportunities.</li> </ul> Fig.1 - IBM candle chart (top) with Stochastic Fast (bottom)  Fig.2 - QQQQ candle chart (top) with Stochastic Fast (bottom 1), Stochastic Slow (bottom 2) and Full Stochastic (bottom 3)"},{"location":"strategies/stochastic_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>The strategy follows a simple rule based on the Stochastic indicator crossover. When the Stochastic indicator's %K line crosses above the %D line, a buy signal is generated. Conversely, when the %K line crosses below the %D line, a sell signal is generated. The strategy aims to capture potential trend reversals.</p>"},{"location":"strategies/stochastic_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description FASTK_PERIOD or PERIOD None greater than 0 The period for the fast %K line of the Stochastic indicator. SLOWK_PERIOD or SMOOTH_K_PERIOD None greater than 0 The period for the slow %K line of the Stochastic indicator. SLOWD_PERIOD or SMOOTH_D_PERIOD None greater than 0 The period for the slow %D line of the Stochastic indicator."},{"location":"strategies/stochastic_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover values for the Slow-K and Slow-D of Stochastic indicator using historical data of the instrument. The method returns the crossover values between slow-K and slow-D.</p>"},{"location":"strategies/vwap_crossover/","title":"VWAP Crossover","text":"<p>This is a trading strategy called \"VWAP Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the crossover of the VWAP (Volume Weighted Average Price) indicator.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/vwap_crossover/#vwap-indicator","title":"VWAP indicator","text":"<p>In the stock market, VWAP stands for Volume-Weighted Average Price. VWAP is a trading indicator that calculates the average price at which a particular stock or security has traded throughout the day, taking into account both the price and the volume of each trade.</p> <p>Here is a summary of VWAP in the stock market:</p> <ul> <li>VWAP is calculated by multiplying the price of each trade by the corresponding volume and then summing up these values over a specific time period. The total value is divided by the cumulative volume to obtain the average price.</li> <li>The volume-weighted aspect of VWAP gives more weight to trades with higher volume, reflecting the significance of larger trades in the overall average price calculation.</li> <li>VWAP is typically calculated on an intraday basis, such as the trading day or a specific session, and resets at the start of each new period.</li> <li>Traders and investors use VWAP as a benchmark to assess whether their own trades are executed at a better or worse price compared to the average market price. It helps evaluate the quality of their execution and determine if they are buying or selling at a favorable price.</li> <li>VWAP is commonly used by institutional traders who execute large orders as it helps them minimize market impact and avoid unfavorable executions. By comparing their execution price to VWAP, they can assess their performance and adjust their trading strategies accordingly.</li> <li>In addition to being used as a benchmark, VWAP is also employed as a trading strategy. Some traders use VWAP as a reference point for making buy or sell decisions. For example, if the current price is above VWAP, it may be considered bullish, while a price below VWAP could be seen as bearish.</li> <li>VWAP is often displayed as a line on intraday price charts, allowing traders to visually compare the current price to the average price. It can provide insights into the market's overall sentiment and potential support or resistance levels.</li> <li>It is important to note that VWAP is a lagging indicator since it is based on historical data. Therefore, it is often used in combination with other indicators and analysis techniques to validate trade signals and make informed trading decisions.</li> <li>Overall, VWAP is a widely used indicator in the stock market that provides a volume-weighted average price, serving as a benchmark for evaluating trade execution quality and as a reference point for trading decisions. By considering both price and volume, VWAP offers insights into market dynamics and helps traders assess their performance relative to the average market price.</li> </ul> Fig.1 - IBM candle chart (top) with VWAP line  (Blue), Volume chart with SMA line"},{"location":"strategies/vwap_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>The strategy follows a simple rule based on the crossover of the VWAP indicator. When the price crosses above the VWAP, a buy signal is generated, and when the price crosses below the VWAP, a sell signal is generated. The strategy aims to capture potential trend reversals based on the VWAP.</p>"},{"location":"strategies/vwap_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>No specific strategy parameters are mentioned in the code. </p>"},{"location":"strategies/vwap_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the VWAP from historical data and the crossover values for the VWAP of the instrument. The method returns the crossover values between close of hist data and vwap.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/","title":"Options Strategy Structure","text":"<p>Links</p> <ul> <li>Code Structure of Strategy (workflow of a strategy)</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#1-initial-steps","title":"1. Initial steps","text":""},{"location":"strategies/strategy_guides/common_options_strategy/#create-a-new-strategy-file","title":"Create a new strategy file","text":"<p>this is for pyalgotrading users</p> <p>eg: strategy_<code>&lt;unique_code_if_needed&gt;</code>_options_ema_crossover.py</p> <p>Coding Conventions</p> <ul> <li>Keep a unique file name</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#naming-a-class","title":"Naming a Class","text":"<p>eg: For the above strategy name the class name would be:     <pre><code>StrategyOptionsEMACrossover(StrategyOptionsBaseV2)\n</code></pre></p> <p>Coding Conventions<ul> <li>Make a class with the same name as the file name</li> <li>Make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.</li> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every options strategy is a child class of the StrategyOptionsBaseV2 class.</li> </ul> </p>"},{"location":"strategies/strategy_guides/common_options_strategy/#naming-your-strategy","title":"Naming your Strategy","text":"<p>This name will be displayed in your My Coded Strategies in Python Build Web, and it will also be the strategy_name when you are fetching all strategies in pyalgotrading. Inside your strategy class, you can write your first parameter as <code>name</code>.     <pre><code>name = 'options_ema_crossover'\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#strategy-info","title":"Strategy info","text":"<p>In the init method add the line given below <pre><code>super().__init__(*args, **kwargs)\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#parameter-creation","title":"Parameter creation","text":"<p>Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE']\nself.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE']\nself._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE']\nself._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>Note</p> <ul> <li>The parameter names and the number of parameters may change for different strategies.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#start-time-and-end-time-creation","title":"Start time and End time creation","text":"<p>Adding Start and End time is useful when you want to define a timerange between which the strategy will be running each day. Add the below code to calculate the strategy start time and end time, from the <code>strategy_parameters</code>.</p> <p>try: <pre><code>    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> try: <pre><code>    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#strategy-variables","title":"Strategy variables","text":"<p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <pre><code>self.main_order = None            # We save the entry order in this variable\nself.stoploss_order = None        # We save the corresponding stoploss exit order of the entry order in this variable\n</code></pre> We initialize the variables with a None value.     !!! Note             There could be more strategy variables required as per the strategy requirement. </p>"},{"location":"strategies/strategy_guides/common_options_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <pre><code>self.order_tag_manager = OrderTagManager\n</code></pre>"},{"location":"strategies/strategy_guides/common_options_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#add_order","title":"add_order","text":"<ul> <li>Stores the order object for the given tags. eg:</li> </ul> <pre><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])\n</code></pre> <ul> <li>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#get_orders","title":"get_orders","text":"<ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <pre><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)\n</code></pre> <ul> <li>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#remove_tags","title":"remove_tags","text":"<ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <pre><code>self.order_tag_manager.remove_tags(tags=entry_key)\n</code></pre> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#remove_order","title":"remove_order","text":"<ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><pre><code>self.order_tag_manager.remove_order(main_order)\n</code></pre> Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#get_internals","title":"get_internals","text":"<pre><code>Returns the values i.e. both the entry and exit orders stored inside the tags list.\n</code></pre>"},{"location":"strategies/strategy_guides/common_options_strategy/#5-child-instruments-calculation","title":"5. Child instruments calculation","text":""},{"location":"strategies/strategy_guides/common_options_strategy/#get_ltp","title":"get_ltp","text":"<p>Fetch the ltp of the base instrument (instrument set while executing strategy) <pre><code>ltp = self.broker.get_ltp(self.underlying_instrument)\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#options_instruments_set_up_local","title":"options_instruments_set_up_local","text":"<p>Get the ATM ITM and OTM lists of the child instrument based on the LTP     <pre><code>self.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp)\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#get_child_instrument_details","title":"get_child_instrument_details","text":"<p>Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument     <pre><code>child_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#6-entry-methods","title":"6. Entry Methods","text":""},{"location":"strategies/strategy_guides/common_options_strategy/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry","text":"<ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selectd_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#strategy_enter_position","title":"strategy_enter_position","text":"<ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#7-exit-methods","title":"7. Exit Methods","text":""},{"location":"strategies/strategy_guides/common_options_strategy/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit","text":"<ul> <li>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</li> <li>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#strategy_exit_position","title":"strategy_exit_position","text":"<ul> <li>Here is where we actually place the exit order for where we exit the order which was placed during entry. If the order is placed successfully we clear the order in a class variable such that we can add new orders to the vacant place in variable in the entry methods.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#8-other-common-methods","title":"8. Other common methods","text":"<p>There are other methods that are used in the strategy:</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#check_and_place_stoploss_order","title":"check_and_place_stoploss_order","text":"<p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#set_all_none","title":"set_all_none","text":"<p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#options_instruments_set_up_local_1","title":"options_instruments_set_up_local","text":"<p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. </p>"},{"location":"strategies/strategy_guides/common_options_strategy/#get_child_instrument_details_1","title":"get_child_instrument_details","text":"<p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch a single child instrument based on the no of strikes and strike direction.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#9-cleanup","title":"9. Cleanup","text":"<ol> <li> <p>Add comments and docstrings wherever possible to improve code readability.</p> </li> <li> <p>Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> </li> </ol> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> section</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/","title":"Regular Strategy Structure","text":"<p>Links</p> <ul> <li>Code Structure of Strategy (workflow of a strategy)</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#1-initial-steps","title":"1. Initial steps","text":""},{"location":"strategies/strategy_guides/common_regular_strategy/#create-a-new-strategy-file","title":"Create a new strategy file","text":"<p>this is for pyalgotrading users</p> <p>eg: strategy_<code>&lt;unique_code_if_needed&gt;</code>_futures_ema_crossover.py</p> <p>Coding Conventions</p> <ul> <li>Keep a unique file name</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#naming-a-class","title":"Naming a Class","text":"<p>eg: For the above strategy name the class name would be:     <pre><code>StrategyFuturesEMACrossover(StrategyBase)\n</code></pre>     !!! Tips \"Coding Conventions\"             * Make a class with the same name as the file name             * Make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.             * If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.             * Every strategy is a child class of the StrategyBase class.</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#naming-your-strategy","title":"Naming your Strategy","text":"<p>This name will be displayed in your My Coded Strategies in Python Build Web, and it will also be the strategy_name when you are fetching all strategies in pyalgotrading. Inside your strategy class, you can write your first parameter as <code>name</code>.     <pre><code>name = 'futures_ema_crossover'\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#strategy-info","title":"Strategy info","text":"<p>In the init method add the line given below <pre><code>super().__init__(*args, **kwargs)\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#parameter-creation","title":"Parameter creation","text":"<p>Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>Note</p> <ul> <li>The parameter names and the number of parameters may be different for different strategies.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#start-time-and-end-time-creation","title":"Start time and End time creation","text":"<p>Adding Start and End time is useful when you want to define a timerange between which the strategy will be running each day. Add the below code to calculate the strategy start time and end time, from the <code>strategy_parameters</code>.     try:     <pre><code>    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n</code></pre>     try:      <pre><code>    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre></p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#strategy-variables","title":"Strategy variables","text":"<p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <code>self.order_tag_manager = None</code> </p> <p>We initialize the variables with a None value.</p> <p>Note<p>There could be more strategy variables required as per the strategy requirement. </p> </p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <pre><code>self.order_tag_manager = OrderTagManager\n</code></pre>"},{"location":"strategies/strategy_guides/common_regular_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#add_order","title":"add_order","text":"<ul> <li>Stores the order object for the given tags. eg: <pre><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])\n</code></pre></li> <li>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#get_orders","title":"get_orders","text":"<ul> <li>Retrieve the order(s) for the given tags. eg: <pre><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)\n</code></pre></li> <li>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#remove_tags","title":"remove_tags","text":"<ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag eg: <pre><code>self.order_tag_manager.remove_tags(tags=entry_key)\n</code></pre></li> <li>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</li> </ul> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags.</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#remove_order","title":"remove_order","text":"<ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s). eg:</li> </ul> <pre><code>self.order_tag_manager.remove_order(main_order)\n</code></pre> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#get_internals","title":"get_internals","text":"<ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.   </li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#5-entry-methods","title":"5. Entry Methods","text":""},{"location":"strategies/strategy_guides/common_regular_strategy/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry","text":"<ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selected_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#strategy_enter_position","title":"strategy_enter_position","text":"<ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#6-exit-methods","title":"6. Exit Methods","text":""},{"location":"strategies/strategy_guides/common_regular_strategy/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit:","text":"<ul> <li>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</li> <li>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#strategy_exit_position","title":"strategy_exit_position","text":"<ul> <li>Here is where we actually place the exit order for where we exit the order which was placed during entry. If the order is placed successfully we clear the order in a class variable such that we can add new orders to the vacant place in variable in the entry methods.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#7-other-common-methods","title":"7. Other common methods","text":"<p>There are other methods that are used in the strategy:</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#check_and_place_stoploss_order","title":"check_and_place_stoploss_order","text":"<p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#set_all_none","title":"set_all_none","text":"<pre><code>This method is called in the ```strategy_exit_position``` when our entry order has exited, and we want to remove the order object from the ```self.main_order``` variable.\n</code></pre>"},{"location":"strategies/strategy_guides/common_regular_strategy/#8-cleanup","title":"8. Cleanup","text":"<ol> <li> <p>Add comments and docstrings wherever possible to improve code readability.</p> </li> <li> <p>Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> </li> </ol> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> section</p>"},{"location":"strategies/strategy_guides/structure/","title":"Code Structure of Strategy","text":""},{"location":"strategies/strategy_guides/structure/#previously","title":"Previously...","text":"<p>You now have the necessary prerequisites installed and ready.</p>"},{"location":"strategies/strategy_guides/structure/#now","title":"Now...","text":"<p>This page describes the methods you will use to create your strategy.</p>"},{"location":"strategies/strategy_guides/structure/#lets-start","title":"Let's Start...","text":"<p>You have the following methods.</p>"},{"location":"strategies/strategy_guides/structure/#methods","title":"Methods","text":""},{"location":"strategies/strategy_guides/structure/#strategy_select_instruments_for_entry","title":"strategy_select_instruments_for_entry()","text":"<p>This function helps you choose which trading instruments you want your strategy to work with. The system will use this function to go through each instrument one by one, at each candle's time. You get to write code that decides whether to place an order for a specific instrument or not.</p>"},{"location":"strategies/strategy_guides/structure/#strategy_enter_position","title":"strategy_enter_position()","text":"<p>This function is where you can place orders for the instruments you selected earlier. It's executed for each instrument you picked in the previous function.</p>"},{"location":"strategies/strategy_guides/structure/#strategy_select_instruments_for_exit","title":"strategy_select_instruments_for_exit()","text":"<p>After you've entered a position for an instrument, this function is called for each of those instruments at each candle interval. You can use it to decide whether an instrument should be exited from the position.</p>"},{"location":"strategies/strategy_guides/structure/#strategy_exit_position","title":"strategy_exit_position()","text":"<p>In this function, you can close or exit positions for the instruments you marked for exiting in the previous function. It's done instrument by instrument.</p>"},{"location":"strategies/strategy_guides/structure/#supporting-methods","title":"Supporting Methods","text":"<p>You have the following supporting methods:</p>"},{"location":"strategies/strategy_guides/structure/#init","title":"init()","text":"<p>This method is like a starter for your strategy. It checks if the values you give it make sense and sets up some useful information for your strategy to use.</p>"},{"location":"strategies/strategy_guides/structure/#initialize","title":"initialize()","text":"<p>This method is called when your strategy begins, both at the very start and at the beginning of each trading day. It's like setting up your strategy's workspace and giving your tools a starting position.</p>"},{"location":"strategies/strategy_guides/structure/#name","title":"name()","text":"<p>This method gives your strategy a special name. It's like giving your strategy a unique nickname.</p>"},{"location":"strategies/strategy_guides/structure/#versions_supported","title":"versions_supported()","text":"<p>This method lets you specify which version of the AlgoBulls Platform your strategy works well with. It's like saying, \"My strategy is ready for this specific version of the platform.\"</p>"},{"location":"strategies/strategy_guides/structure/#utility-functions","title":"Utility Functions","text":"<p>You have the following utility function to be used in this strategy :</p> <p>Links</p> <ul> <li>Strategy Structure (regular)</li> <li>Strategy Structure (options)</li> </ul>"},{"location":"strategies/strategy_guides/structure/#get_crossover_value","title":"get_crossover_value()","text":"This handy function calculates something called the \"crossover value\" for you. It's like having a calculator that figures out this specific value for your strategy."},{"location":"strategies/strategy_guides/structure/#flowchart","title":"Flowchart","text":"<p>Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.</p> <p></p>"},{"location":"strategies/strategy_guides/structure/#whats-next","title":"What's Next...","text":"<p>Checkout the strategy guides for building a Regular Strategy or Options Strategy</p>"}]}