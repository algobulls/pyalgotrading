{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Page \u00b6 Pyalgotrading \u00b6 Pyalgotrading is an official Python package that offers algorithmic trading APIs powered by AlgoBulls . It provides support for creating and uploading strategies on the AlgoBulls platform, as well as a pool of free strategies at pyalgostrategypool . It also supports over 150 technical indicators, multiple candlestick patterns and intervals, and different types of orders. Pyalgotrading allows for backtesting, paper trading, and real trading (subject to approval), and supports multiple brokers for real trading. Real-time logs and reports are available for all types of trading, and candlestick charts can be plotted using plotly.py . PythonBuild \u00b6 The PythonBuild service is a powerful platform that offers users the flexibility to create their own trading strategies from scratch or make modifications to existing templates. It provides them with the ability to leverage the AlgoBulls Core Trading Engine, an advanced trading system, and gain access to historical data for evaluating and improving the performance of their strategies. With PythonBuild, users have the freedom to write their trading algorithms from the ground up, allowing for complete customization and control over the logic and functionality of their strategies. Alternatively, they can modify pre-existing templates, which saves time and effort while still enabling them to tailor the strategy to their specific needs. One of the key advantages of the PythonBuild service is that it grants users the ability to tweak parameters, making it easy to fine-tune their strategies and observe the impact on performance in real-time. This feature empowers traders to optimize their algorithms for desired outcomes and increase the likelihood of successful trading. In addition to parameter tweaking, PythonBuild also provides users with the capability to view visual analytics. This feature allows for in-depth analysis and visualization of strategy performance, providing traders with valuable insights and enabling them to make data-driven decisions. By analyzing comprehensive data metrics and charts, users can identify patterns, uncover trends, and refine their strategies for enhanced profitability","title":"Home"},{"location":"#home-page","text":"","title":"Home Page"},{"location":"#pyalgotrading","text":"Pyalgotrading is an official Python package that offers algorithmic trading APIs powered by AlgoBulls . It provides support for creating and uploading strategies on the AlgoBulls platform, as well as a pool of free strategies at pyalgostrategypool . It also supports over 150 technical indicators, multiple candlestick patterns and intervals, and different types of orders. Pyalgotrading allows for backtesting, paper trading, and real trading (subject to approval), and supports multiple brokers for real trading. Real-time logs and reports are available for all types of trading, and candlestick charts can be plotted using plotly.py .","title":"Pyalgotrading"},{"location":"#pythonbuild","text":"The PythonBuild service is a powerful platform that offers users the flexibility to create their own trading strategies from scratch or make modifications to existing templates. It provides them with the ability to leverage the AlgoBulls Core Trading Engine, an advanced trading system, and gain access to historical data for evaluating and improving the performance of their strategies. With PythonBuild, users have the freedom to write their trading algorithms from the ground up, allowing for complete customization and control over the logic and functionality of their strategies. Alternatively, they can modify pre-existing templates, which saves time and effort while still enabling them to tailor the strategy to their specific needs. One of the key advantages of the PythonBuild service is that it grants users the ability to tweak parameters, making it easy to fine-tune their strategies and observe the impact on performance in real-time. This feature empowers traders to optimize their algorithms for desired outcomes and increase the likelihood of successful trading. In addition to parameter tweaking, PythonBuild also provides users with the capability to view visual analytics. This feature allows for in-depth analysis and visualization of strategy performance, providing traders with valuable insights and enabling them to make data-driven decisions. By analyzing comprehensive data metrics and charts, users can identify patterns, uncover trends, and refine their strategies for enhanced profitability","title":"PythonBuild"},{"location":"pyalgotrad/","text":"Welcome to pyalgotrading Documentation! \u00b6 Official Python Package for Algorithmic Trading APIs powered by AlgoBulls! \u00b6 Visit the Tutorial \u00b6 Tutorial: Introduction Prerequisites Basic Structure of a Strategy Hands On: Program Example Upload your Strategy Test your Strategy Features \u00b6 Powered by the AlgoBulls Platform Everything related to Algorithmic Trading Strategies! Create & upload strategies on the AlgoBulls Platform Free pool of Strategies are available separately at pyalgostrategypool ! Support for all 150+ Technical Indicators provided by TA-Lib Support for multiple candlesticks patterns - Japanese OHLC, Renko, Heikin-Ashi, Linebreak Support for multiple candle intervals - 1 minute, 3 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 1 day. Support for MARKET , LIMIT , STOPLOSS-MARKET , STOPLOSS-LIMIT orders Support for INTRADAY and DELIVERY orders Support for Backtesting , Paper Trading and Real Trading Currently supported brokers Real-time Logs for Backtesting, Paper Trading and Real Trading Multiple real-time Reports available for Backtesting, Paper Trading and Real Trading - Profit-n-Loss report (PnL report) Statistics of (PnL report) Order History for each order with state transitions & timestamps Plot Candlestick charts using plotly.py Backtesting, Paper Trading and Real Trading can be performed on the same strategy code base! Python \u00b6 Python Support: Python 3.10+ . Python Requirements: See requirements.txt . We recommend you to use the latest version of Python (v3.10+) to enjoy better performance benefits, especially for pandas (v1.5.3). Installation \u00b6 Package can be easily installed using pip - pip install pyalgotrading Support / Getting Help \u00b6 Bug Reporting / New Feature Request : Please create a new issue here on GitHub. Discussion Forum : Discuss with our developers on this forum Additional Support : If none of the above help, please contact pushpak@algobulls.com . Contribution Guidelines \u00b6 Here\u2019s how we suggest you go about proposing a change to this project: Fork this project to your account. Create a branch for the change you intend to make. Make your changes to your fork. Send a pull request from your fork\u2019s branch to our master branch. Changelog \u00b6 See CHANGELOG.md . License \u00b6 See LICENSE .","title":"Index"},{"location":"pyalgotrad/#welcome-to-pyalgotrading-documentation","text":"","title":"Welcome to pyalgotrading Documentation!"},{"location":"pyalgotrad/#official-python-package-for-algorithmic-trading-apis-powered-by-algobulls","text":"","title":"Official Python Package for Algorithmic Trading APIs powered by AlgoBulls!"},{"location":"pyalgotrad/#visit-the-tutorial","text":"Tutorial: Introduction Prerequisites Basic Structure of a Strategy Hands On: Program Example Upload your Strategy Test your Strategy","title":"Visit the Tutorial"},{"location":"pyalgotrad/#features","text":"Powered by the AlgoBulls Platform Everything related to Algorithmic Trading Strategies! Create & upload strategies on the AlgoBulls Platform Free pool of Strategies are available separately at pyalgostrategypool ! Support for all 150+ Technical Indicators provided by TA-Lib Support for multiple candlesticks patterns - Japanese OHLC, Renko, Heikin-Ashi, Linebreak Support for multiple candle intervals - 1 minute, 3 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 1 day. Support for MARKET , LIMIT , STOPLOSS-MARKET , STOPLOSS-LIMIT orders Support for INTRADAY and DELIVERY orders Support for Backtesting , Paper Trading and Real Trading Currently supported brokers Real-time Logs for Backtesting, Paper Trading and Real Trading Multiple real-time Reports available for Backtesting, Paper Trading and Real Trading - Profit-n-Loss report (PnL report) Statistics of (PnL report) Order History for each order with state transitions & timestamps Plot Candlestick charts using plotly.py Backtesting, Paper Trading and Real Trading can be performed on the same strategy code base!","title":"Features"},{"location":"pyalgotrad/#python","text":"Python Support: Python 3.10+ . Python Requirements: See requirements.txt . We recommend you to use the latest version of Python (v3.10+) to enjoy better performance benefits, especially for pandas (v1.5.3).","title":"Python"},{"location":"pyalgotrad/#installation","text":"Package can be easily installed using pip - pip install pyalgotrading","title":"Installation"},{"location":"pyalgotrad/#support-getting-help","text":"Bug Reporting / New Feature Request : Please create a new issue here on GitHub. Discussion Forum : Discuss with our developers on this forum Additional Support : If none of the above help, please contact pushpak@algobulls.com .","title":"Support / Getting Help"},{"location":"pyalgotrad/#contribution-guidelines","text":"Here\u2019s how we suggest you go about proposing a change to this project: Fork this project to your account. Create a branch for the change you intend to make. Make your changes to your fork. Send a pull request from your fork\u2019s branch to our master branch.","title":"Contribution Guidelines"},{"location":"pyalgotrad/#changelog","text":"See CHANGELOG.md .","title":"Changelog"},{"location":"pyalgotrad/#license","text":"See LICENSE .","title":"License"},{"location":"pyalgotrad/codeguide/","text":"Note This will be a frequently updated page. Keep visiting to know what's new! This page helps you to understand the best practices to create a good strategy. List of Guidelines \u00b6 The following Python packages/modules are available to you: Package / Module Version TA-Lib 0.4.25 pandas 1.5.3 numpy 1.24.2 The strategy class should not import any packages/modules. The entire strategy should be a single Python class. Note Pandas is available with limited functionality. Direct printing of dataframes is disabled. It is a good idea to include the version number while installing a package using pip . Example - pip install numpy==1.24.2 You may get the following message if the strategy fails to adhere to the guidelines. Strategy breached code of conduct. Please adjust your strategy to follow guidelines and run again. Halting strategy...","title":"Strategy Coding Guidelines"},{"location":"pyalgotrad/codeguide/#list-of-guidelines","text":"The following Python packages/modules are available to you: Package / Module Version TA-Lib 0.4.25 pandas 1.5.3 numpy 1.24.2 The strategy class should not import any packages/modules. The entire strategy should be a single Python class. Note Pandas is available with limited functionality. Direct printing of dataframes is disabled. It is a good idea to include the version number while installing a package using pip . Example - pip install numpy==1.24.2 You may get the following message if the strategy fails to adhere to the guidelines. Strategy breached code of conduct. Please adjust your strategy to follow guidelines and run again. Halting strategy...","title":"List of Guidelines"},{"location":"pyalgotrad/introduction/","text":"Introduction \u00b6 This tutorial aims to help users practice and get familiar with the Pyalgotrading package, which is a Python-based algorithmic trading library. It allows you to create and execute your trading strategies on various financial instruments such as equities, futures, options, and more. To follow this tutorial, you will need to have an active and working AlgoBulls account, which is a platform for creating and testing trading strategies. Prerequisites \u00b6 Before starting the tutorial, ensure that you have the following setup: An active and working AlgoBulls account Python IDE of your choice (if you want to code your own strategy) Jupyter Notebook (for points 2,3, and 4) Tutorial Steps \u00b6 Code your own simple strategy using the Pyalgotrading package: In this step, you will use your Python IDE to code your own trading strategy using Pyalgotrading package. You can also use the ready-made strategy provided by the pyalgostrategypool package if you don't want to code your own. Upload your strategy to the AlgoBulls platform: After coding your strategy, you will need to upload it to the AlgoBulls platform. This can be done by creating a new strategy on the platform and then uploading your strategy file. Run Backtest / Paper Trade / Real Trade using your strategy: Once you have uploaded your strategy, you can run backtests, paper trades or real trades to see how your strategy performs. These can be done from the AlgoBulls platform itself. Fetch logs during runtime, see reports, view statistics, and see your order history: You can fetch the logs during runtime to monitor your strategy's performance and view reports and statistics to analyze its effectiveness. You can also view your order history to see the trades executed by your strategy. Check out the basic structure of a strategy: Before coding your strategy, you can refer to the basic structure of a strategy provided by the Pyalgotrading package. This will give you an idea of the methods involved in the trading strategy and their flow. Reach out to AlgoBulls Support for any queries: If you face any issues during the tutorial, you can reach out to the AlgoBulls Support (mailto:support@algobulls.com) team for help. Conclusion \u00b6 In conclusion, this tutorial helps users get started with the Pyalgotrading package and create their own trading strategies. It also provides information on how to upload, run and monitor the strategies on the AlgoBulls platform. The tutorial aims to equip users with the necessary skills to create effective trading strategies using the Pyalgotrading package.","title":"Introduction"},{"location":"pyalgotrad/introduction/#introduction","text":"This tutorial aims to help users practice and get familiar with the Pyalgotrading package, which is a Python-based algorithmic trading library. It allows you to create and execute your trading strategies on various financial instruments such as equities, futures, options, and more. To follow this tutorial, you will need to have an active and working AlgoBulls account, which is a platform for creating and testing trading strategies.","title":"Introduction"},{"location":"pyalgotrad/introduction/#prerequisites","text":"Before starting the tutorial, ensure that you have the following setup: An active and working AlgoBulls account Python IDE of your choice (if you want to code your own strategy) Jupyter Notebook (for points 2,3, and 4)","title":"Prerequisites"},{"location":"pyalgotrad/introduction/#tutorial-steps","text":"Code your own simple strategy using the Pyalgotrading package: In this step, you will use your Python IDE to code your own trading strategy using Pyalgotrading package. You can also use the ready-made strategy provided by the pyalgostrategypool package if you don't want to code your own. Upload your strategy to the AlgoBulls platform: After coding your strategy, you will need to upload it to the AlgoBulls platform. This can be done by creating a new strategy on the platform and then uploading your strategy file. Run Backtest / Paper Trade / Real Trade using your strategy: Once you have uploaded your strategy, you can run backtests, paper trades or real trades to see how your strategy performs. These can be done from the AlgoBulls platform itself. Fetch logs during runtime, see reports, view statistics, and see your order history: You can fetch the logs during runtime to monitor your strategy's performance and view reports and statistics to analyze its effectiveness. You can also view your order history to see the trades executed by your strategy. Check out the basic structure of a strategy: Before coding your strategy, you can refer to the basic structure of a strategy provided by the Pyalgotrading package. This will give you an idea of the methods involved in the trading strategy and their flow. Reach out to AlgoBulls Support for any queries: If you face any issues during the tutorial, you can reach out to the AlgoBulls Support (mailto:support@algobulls.com) team for help.","title":"Tutorial Steps"},{"location":"pyalgotrad/introduction/#conclusion","text":"In conclusion, this tutorial helps users get started with the Pyalgotrading package and create their own trading strategies. It also provides information on how to upload, run and monitor the strategies on the AlgoBulls platform. The tutorial aims to equip users with the necessary skills to create effective trading strategies using the Pyalgotrading package.","title":"Conclusion"},{"location":"pyalgotrad/prerequisites/","text":"Prerequisites \u00b6 You will need the following to perform this tutorial: AlgoBulls Account ( Link ) - You will need this account to upload and test your strategies. The account needs to be setup with the proper risk management values and a bound broker before any trades can be executed. Make sure the account is properly setup or contact AlgoBulls Support for any help. Python 3.10 ( Link ) - The AlgoBulls platform can run all strategies that conform to Python 3.10. A Python IDE of your choice, like Pycharm ( Link ) - As mentioned in the [Introduction], this tutorial will demonstrate the pyalgotrading package by implementing the Simple Moving Average Crossover Strategy for Regular Orders. You will make this strategy as a separate python file, and the PyCharm Community Edition IDE is enough for this purpose. If you are already using a Python IDE of your choice, you may skip this step. TA-Lib Package ( Link ) - This package encompasses all Technical Indicators used in Technical Analysis by strategists. You will need this package to compute Moving Average (SMA) for the example. pyalgotrading Package ( Link ) - This package has all the necessary classes to create strategies. For the SMA strategy, you will subclass your class from the StrategyBase class which is present in this package. Jupyter Notebook ( Link ) - You will use a Jupyter Notebook to connect to the AlgoBulls platform. You will upload the strategy, test your strategy (Backtesting, Paper Trading or Real Trading), and fetch logs using the notebook. Tips It is a good idea to set up a virtual environment first Install Python 3.10 Once Python is installed, most packages are easily installed in your venv using pip install command pip install TA-Lib pip install pyalgotrading pip install jupyterlab","title":"Prerequisites"},{"location":"pyalgotrad/prerequisites/#prerequisites","text":"You will need the following to perform this tutorial: AlgoBulls Account ( Link ) - You will need this account to upload and test your strategies. The account needs to be setup with the proper risk management values and a bound broker before any trades can be executed. Make sure the account is properly setup or contact AlgoBulls Support for any help. Python 3.10 ( Link ) - The AlgoBulls platform can run all strategies that conform to Python 3.10. A Python IDE of your choice, like Pycharm ( Link ) - As mentioned in the [Introduction], this tutorial will demonstrate the pyalgotrading package by implementing the Simple Moving Average Crossover Strategy for Regular Orders. You will make this strategy as a separate python file, and the PyCharm Community Edition IDE is enough for this purpose. If you are already using a Python IDE of your choice, you may skip this step. TA-Lib Package ( Link ) - This package encompasses all Technical Indicators used in Technical Analysis by strategists. You will need this package to compute Moving Average (SMA) for the example. pyalgotrading Package ( Link ) - This package has all the necessary classes to create strategies. For the SMA strategy, you will subclass your class from the StrategyBase class which is present in this package. Jupyter Notebook ( Link ) - You will use a Jupyter Notebook to connect to the AlgoBulls platform. You will upload the strategy, test your strategy (Backtesting, Paper Trading or Real Trading), and fetch logs using the notebook. Tips It is a good idea to set up a virtual environment first Install Python 3.10 Once Python is installed, most packages are easily installed in your venv using pip install command pip install TA-Lib pip install pyalgotrading pip install jupyterlab","title":"Prerequisites"},{"location":"pyalgotrad/programexample/","text":"Create your Strategy \u00b6 Previously... \u00b6 You have covered the basic code structure of a strategy. Now... \u00b6 You can either follow this page to create a strategy, or you can pick up a ready strategy (shown below) and move to the next page. Before you start... \u00b6 If you want to use a ready strategy from the pyalgostrategypool package, then you can directly jump to the Upload section. Let's Start... \u00b6 Follow the steps given below to create a new strategy of your own. Create a python file called strategy_sma_regular_order.py . You will add the following code snippets into the file and then save it. Import statements \u00b6 from pyalgotrading.strategy.strategy_base import StrategyBase from pyalgotrading.constants import * Create the class StrategySMARegularOrder and subclass it from StrategyBase \u00b6 class StrategySMARegularOrder ( StrategyBase ): Now you can add the methods mentioned in the structure inside the class. First you can add the __init__ and the initialize methods. Constructor: def __init__() \u00b6 def __init__ ( self , * args , ** kwargs ): name = 'SMA Regular Order Strategy' super () . __init__ ( * args , ** kwargs ) self . timeperiod_x = self . strategy_parameters [ 'timeperiod1' ] self . timeperiod_y = self . strategy_parameters [ 'timeperiod2' ] self . main_order = None The init method does the following: name - variable which should store the name of your strategy super() - Calls the constructor of the superclass. self.strategy_parameters - Catches the parameters and saves them for local use - When you will submit a testing job for your SMA strategy, you will pass parameters that will be used inside the strategy. For SMA, we are calculating crossover for 2 SMA timeperiod values, example 5 and 12. These 2 parameters will be caught by self.strategy_parameters and stored for local use in self.timeperiod1 and self.timeperiod2 . self.main_order - Create an object that manages orders for you throughout the strategy. The init method is specific to Python's internal workings, and it is preceded and succeeded by double underscores ( _ _ ) joined together. def initialize() \u00b6 def initialize ( self ): self . main_order = {} The initialize method sets the self.main_order as an empty dictionary. This method is called at the start of every trading day. For instance, say you are submitting a backtesting job for 5 previous days starting at 10:30 every day, then the initialize method will be called every day for 5 days at 10:30. Now add the two static methods, name and versions_supprted . def name() (optional) \u00b6 If the name variable is defined in __init__() , this function is not needed. @staticmethod def name (): return 'SMA Regular Order Strategy' The name should be unique in your collection of strategies. def versions_supported() (optional) \u00b6 not required it will take the latest version of AlgoBullsEngine by default @staticmethod def versions_supported (): return AlgoBullsEngineVersion . VERSION_3_2_0 Mark both the above methods as @staticmethod . The versions_supported method does the following: It notifies the AlgoBulls platform that the strategy is working correctly for the platform version 3.2.0 Since the platform will be constantly upgraded to incorporate new features and improve efficiency, the version may change. If the version changes, and if you submit a job for this strategy, then the AlgoBulls platform will spawn a server having version 3.2.0 for your strategy. Having this method ensures that the AlgoBulls platform always provides the correct environment for your strategy. def strategy_select_instruments_for_entry() \u00b6 def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): instruments = [] meta = [] for instrument in instruments_bucket : crossover_value = self . get_crossover_value ( instrument ) if crossover_value == 1 : instruments . append ( instrument ) meta . append ({ 'action' : 'BUY' }) elif crossover_value == - 1 : if self . strategy_mode is StrategyMode . INTRADAY : instruments . append ( instrument ) meta . append ({ 'action' : 'SELL' }) return instruments , meta The strategy_select_instruments_for_entry method does the following: instruments and meta - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (while submitting the job) and will decide whether to set an entry position or not for it. crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If conditions - If the crossover value is 1, then the instrument is selected for entry position, with the position as 'BUY'. If the crossover value is -1, then the instrument is selected for entry position, with the position as 'SELL'. The selected instrument is appended to the instruments , and the associated action (BUY/SELL) is appended to the meta . instruments and meta - Both the lists (whether populated or empty) are returned to the platform for further actions. Note SELL Entry positions are allowed only if the strategy is running for INTRADAY. DELIVERY strategies do not allow SELL as entry positions. This is taken care of in the elif part. The strategy_select_instruments_for_entry method is called once for every candle time. For Instance, if you submit a job with the candle time as 15 minutes, then this method will be called once for every 15 minute candle. The actual Entry position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the meta . The Entry position will be taken in the next method below. The meta contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. def strategy_enter_position() \u00b6 def strategy_enter_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'BUY' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . BuyOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) elif sideband_info [ 'action' ] == 'SELL' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . SellOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) else : raise SystemExit ( f 'Got invalid sideband_info value: { sideband_info } ' ) return self . main_order [ instrument ] or \u00b6 def strategy_enter_position ( self , candle , instrument , meta ): self . main_order_map [ instrument ] = _ = self . broker . OrderRegular ( intrument = instrument , order_transaction_type = meta [ 'action' ], # 'BUY' or 'SELL' quantity = self . number_of_lots * instrument . lot_size , # number of lots (int) price = None , trigger_price = None ) return _ The strategy_enter_position method does the following: If conditions - The conditions read the action from the sideband_info and perform the required action (BUY/SELL). qty - The quantity is calculated and stored here. The number of lots will be passed by you as a parameter while submitting a job. The parameter will be caught in self.number_of_lots . The instrument object has the 'lot size', which you can retrieve using instrument.lot_size . You can then use the formula as shown in the code to calculate the quantity. OrderRegular , BuyOrderRegular and SellOrderRegular - These execute the required action. You need to pass the instrument, order code, order variety and the quantity values. instrument - the instrument on which the BUY/SELL action will be performed. order_code - whether the order is for INTRADAY or DELIVERY. Possible values are: BrokerOrderCodeConstants.INTRADAY BrokerOrderCodeConstants.DELIVERY BrokerOrderCodeConstants.DELIVERY_T1 BrokerOrderCodeConstants.DELIVERY_T2 order_variety - the type of order variety. Possible values are: BrokerOrderVarietyConstants.MARKET BrokerOrderVarietyConstants.LIMIT BrokerOrderVarietyConstants.STOPLOSS_MARKET BrokerOrderVarietyConstants.STOPLOSS_LIMIT qty - the quantity to BUY/SELL. self.main_order - The main order (for that particular instrument) is now populated (BUY OR SELL) and is returned to the platform for further actions. You can also punch Bracket Orders instead of Regular Orders. A typical BUY Bracket Order will look like this: qty = self . number_of_lots * instrument . lot_size ltp = self . broker . get_ltp ( instrument ) self . main_order [ instrument ] = \\ self . broker . BuyOrderBracket ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . LIMIT , quantity = qty , price = ltp , stoploss_trigger = ltp - ( ltp * self . stoploss ), target_trigger = ltp + ( ltp * self . target ), trailing_stoploss_trigger = ltp * self . trailing_stoploss ) The additional parameters are: price - If you want to BUY at the market price (Last Traded Price) or LTP, then just fetch the LTP using get_ltp as shown in the code above. Store the value in ltp and pass it to price . stoploss_trigger , target_trigger and trailing_stoploss_trigger - You can calculate these using the ltp and the values you will pass through the job that you will submit. The parameters will be caught as self.stoploss , self.target and self.trailing_stoploss . Note If you plan to use Bracket Order instead of Regular Orders, then create a separate Python file for it, say strategy_sma_bracket_order.py . You can also change the class name as StrategySMABracketOrder . There will be changes in the entry and exit methods also. The strategy_enter_position method is called once for every instrument. For instance, you want to run this strategy for 5 instruments. Say that the strategy_select_instruments_for_entry method selects 3 instruments for ENTRY positions (BUY/SELL). Then, the strategy_enter_position method will be called thrice, once for each instrument respectively within the candle time frame (say, 15 minutes). def strategy_select_instruments_for_exit() \u00b6 def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): instruments = [] meta = [] for instrument in instruments_bucket : if self . main_order . get ( instrument ) is not None : crossover_value = self . get_crossover_value ( instrument ) if crossover_value in [ 1 , - 1 ]: instruments . append ( instrument ) meta . append ({ 'action' : 'EXIT' }) return instruments , meta The strategy_select_instruments_for_exit method does the following: instruments and meta - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (which are in Entry position (BUY/SELL)) and will decide whether to set an exit position or not for it. If condition - The exit steps are executed only if the instrument is holding at an ENTRY position (BUY/SELL). You can do this by checking if the self.main_order object is None or not, and proceed only if it is not None . crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If condition - If the crossover value is 1 or -1, then the instrument is selected for exit position. The selected instrument is appended to the instruments , and the associated action (EXIT) is appended to the meta . instruments and meta - Both the lists (whether populated or empty) are returned to the platform for further actions. Note The actual Exit position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the meta . The Exit position will be taken in the next method below. The meta contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. Whenever a new trading day starts, the strategy_select_instruments_for_exit is called first. This is very important for DELIVERY strategies. Many instruments might be holding in an Entry Position at the end of the previous trading day, and they might be eligible for exit at the start of the new trading day. def strategy_exit_position() \u00b6 def strategy_exit_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'EXIT' : self . main_order [ instrument ] . exit_position () self . main_order [ instrument ] = None return True return False The strategy_exit_position method does the following: If condition - checks whether the appropriate action is set in the sideband_info . self.main_order - calls exit_position method for the particular main order of the instrument. If the Entry Position was BUY, then the exit position is automatically taken as SELL and vice versa. The platform takes care of this automatically. self.main_order - set it to None , as the order has been exited and no longer holds anything. Return values - returns True to the platform if the exit steps were performed, else return False . def get_crossover_value() \u00b6 def get_crossover_value ( self , instrument ): hist_data = self . get_historical_data ( instrument ) sma_x = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_x ) sma_y = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_y ) crossover_value = self . utils . crossover ( sma_x , sma_y ) return crossover_value The get_crossover_value method does the following: hist_data - The historical data for the instrument is fetched using the get_historical_data method and stored here. The data is in the form of a table (Pandas DataFrame) having the following columns: timestamp - the data and time when the data was measured volume - the volume of that instrument open , high , low and close - the OHLC values of the instrument oi - the Open Interest of that instrument sma_x and sma_y - the SMA function from the talib package is used to calculate the Moving Average for both SMA time-periods. The candle close value is used for calculations, i.e. hist_data['close'] . crossover_value - calculates the crossover value using the crossover method from the utils package. Return value - return the crossover value to the caller method. Note The order of values passed to the crossover method of the utils package is very important. Example: you have 2 SMA values, 5 and 12. The strategy describes that there should be an BUY Entry Position when SMA(5) cuts SMA(12) upwards (crossover value should be 1). In this case, if you mistakenly pass SMA(12) value first and SMA(5) value next to the crossover function, the answer you will get is -1 (Cut downwards). Though, the crossover value is correct, the strategy is expecting to BUY at crossover 1 as per the code, which will not work now. Therefore, the strategy will work correctly only if you pass SMA(5) first and then SMA(12) to the crossover function, thus making the order of parameters passed an important point to be aware of, while coding the strategy. What's Next... \u00b6 Next, you upload the strategy into your AlgoBulls account.","title":"Create your Strategy"},{"location":"pyalgotrad/programexample/#create-your-strategy","text":"","title":"Create your Strategy"},{"location":"pyalgotrad/programexample/#previously","text":"You have covered the basic code structure of a strategy.","title":"Previously..."},{"location":"pyalgotrad/programexample/#now","text":"You can either follow this page to create a strategy, or you can pick up a ready strategy (shown below) and move to the next page.","title":"Now..."},{"location":"pyalgotrad/programexample/#before-you-start","text":"If you want to use a ready strategy from the pyalgostrategypool package, then you can directly jump to the Upload section.","title":"Before you start..."},{"location":"pyalgotrad/programexample/#lets-start","text":"Follow the steps given below to create a new strategy of your own. Create a python file called strategy_sma_regular_order.py . You will add the following code snippets into the file and then save it.","title":"Let's Start..."},{"location":"pyalgotrad/programexample/#import-statements","text":"from pyalgotrading.strategy.strategy_base import StrategyBase from pyalgotrading.constants import *","title":"Import statements"},{"location":"pyalgotrad/programexample/#create-the-class-strategysmaregularorder-and-subclass-it-from-strategybase","text":"class StrategySMARegularOrder ( StrategyBase ): Now you can add the methods mentioned in the structure inside the class. First you can add the __init__ and the initialize methods.","title":"Create the class StrategySMARegularOrder and subclass it from StrategyBase"},{"location":"pyalgotrad/programexample/#constructor-def-__init__","text":"def __init__ ( self , * args , ** kwargs ): name = 'SMA Regular Order Strategy' super () . __init__ ( * args , ** kwargs ) self . timeperiod_x = self . strategy_parameters [ 'timeperiod1' ] self . timeperiod_y = self . strategy_parameters [ 'timeperiod2' ] self . main_order = None The init method does the following: name - variable which should store the name of your strategy super() - Calls the constructor of the superclass. self.strategy_parameters - Catches the parameters and saves them for local use - When you will submit a testing job for your SMA strategy, you will pass parameters that will be used inside the strategy. For SMA, we are calculating crossover for 2 SMA timeperiod values, example 5 and 12. These 2 parameters will be caught by self.strategy_parameters and stored for local use in self.timeperiod1 and self.timeperiod2 . self.main_order - Create an object that manages orders for you throughout the strategy. The init method is specific to Python's internal workings, and it is preceded and succeeded by double underscores ( _ _ ) joined together.","title":"Constructor: def __init__()"},{"location":"pyalgotrad/programexample/#def-initialize","text":"def initialize ( self ): self . main_order = {} The initialize method sets the self.main_order as an empty dictionary. This method is called at the start of every trading day. For instance, say you are submitting a backtesting job for 5 previous days starting at 10:30 every day, then the initialize method will be called every day for 5 days at 10:30. Now add the two static methods, name and versions_supprted .","title":"def initialize()"},{"location":"pyalgotrad/programexample/#def-name-optional","text":"If the name variable is defined in __init__() , this function is not needed. @staticmethod def name (): return 'SMA Regular Order Strategy' The name should be unique in your collection of strategies.","title":"def name() (optional)"},{"location":"pyalgotrad/programexample/#def-versions_supported-optional","text":"not required it will take the latest version of AlgoBullsEngine by default @staticmethod def versions_supported (): return AlgoBullsEngineVersion . VERSION_3_2_0 Mark both the above methods as @staticmethod . The versions_supported method does the following: It notifies the AlgoBulls platform that the strategy is working correctly for the platform version 3.2.0 Since the platform will be constantly upgraded to incorporate new features and improve efficiency, the version may change. If the version changes, and if you submit a job for this strategy, then the AlgoBulls platform will spawn a server having version 3.2.0 for your strategy. Having this method ensures that the AlgoBulls platform always provides the correct environment for your strategy.","title":"def versions_supported() (optional)"},{"location":"pyalgotrad/programexample/#def-strategy_select_instruments_for_entry","text":"def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): instruments = [] meta = [] for instrument in instruments_bucket : crossover_value = self . get_crossover_value ( instrument ) if crossover_value == 1 : instruments . append ( instrument ) meta . append ({ 'action' : 'BUY' }) elif crossover_value == - 1 : if self . strategy_mode is StrategyMode . INTRADAY : instruments . append ( instrument ) meta . append ({ 'action' : 'SELL' }) return instruments , meta The strategy_select_instruments_for_entry method does the following: instruments and meta - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (while submitting the job) and will decide whether to set an entry position or not for it. crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If conditions - If the crossover value is 1, then the instrument is selected for entry position, with the position as 'BUY'. If the crossover value is -1, then the instrument is selected for entry position, with the position as 'SELL'. The selected instrument is appended to the instruments , and the associated action (BUY/SELL) is appended to the meta . instruments and meta - Both the lists (whether populated or empty) are returned to the platform for further actions. Note SELL Entry positions are allowed only if the strategy is running for INTRADAY. DELIVERY strategies do not allow SELL as entry positions. This is taken care of in the elif part. The strategy_select_instruments_for_entry method is called once for every candle time. For Instance, if you submit a job with the candle time as 15 minutes, then this method will be called once for every 15 minute candle. The actual Entry position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the meta . The Entry position will be taken in the next method below. The meta contains a very versatile dictionary object. You may use it to pass any other additional information that you wish.","title":"def strategy_select_instruments_for_entry()"},{"location":"pyalgotrad/programexample/#def-strategy_enter_position","text":"def strategy_enter_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'BUY' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . BuyOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) elif sideband_info [ 'action' ] == 'SELL' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . SellOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) else : raise SystemExit ( f 'Got invalid sideband_info value: { sideband_info } ' ) return self . main_order [ instrument ]","title":"def strategy_enter_position()"},{"location":"pyalgotrad/programexample/#or","text":"def strategy_enter_position ( self , candle , instrument , meta ): self . main_order_map [ instrument ] = _ = self . broker . OrderRegular ( intrument = instrument , order_transaction_type = meta [ 'action' ], # 'BUY' or 'SELL' quantity = self . number_of_lots * instrument . lot_size , # number of lots (int) price = None , trigger_price = None ) return _ The strategy_enter_position method does the following: If conditions - The conditions read the action from the sideband_info and perform the required action (BUY/SELL). qty - The quantity is calculated and stored here. The number of lots will be passed by you as a parameter while submitting a job. The parameter will be caught in self.number_of_lots . The instrument object has the 'lot size', which you can retrieve using instrument.lot_size . You can then use the formula as shown in the code to calculate the quantity. OrderRegular , BuyOrderRegular and SellOrderRegular - These execute the required action. You need to pass the instrument, order code, order variety and the quantity values. instrument - the instrument on which the BUY/SELL action will be performed. order_code - whether the order is for INTRADAY or DELIVERY. Possible values are: BrokerOrderCodeConstants.INTRADAY BrokerOrderCodeConstants.DELIVERY BrokerOrderCodeConstants.DELIVERY_T1 BrokerOrderCodeConstants.DELIVERY_T2 order_variety - the type of order variety. Possible values are: BrokerOrderVarietyConstants.MARKET BrokerOrderVarietyConstants.LIMIT BrokerOrderVarietyConstants.STOPLOSS_MARKET BrokerOrderVarietyConstants.STOPLOSS_LIMIT qty - the quantity to BUY/SELL. self.main_order - The main order (for that particular instrument) is now populated (BUY OR SELL) and is returned to the platform for further actions. You can also punch Bracket Orders instead of Regular Orders. A typical BUY Bracket Order will look like this: qty = self . number_of_lots * instrument . lot_size ltp = self . broker . get_ltp ( instrument ) self . main_order [ instrument ] = \\ self . broker . BuyOrderBracket ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . LIMIT , quantity = qty , price = ltp , stoploss_trigger = ltp - ( ltp * self . stoploss ), target_trigger = ltp + ( ltp * self . target ), trailing_stoploss_trigger = ltp * self . trailing_stoploss ) The additional parameters are: price - If you want to BUY at the market price (Last Traded Price) or LTP, then just fetch the LTP using get_ltp as shown in the code above. Store the value in ltp and pass it to price . stoploss_trigger , target_trigger and trailing_stoploss_trigger - You can calculate these using the ltp and the values you will pass through the job that you will submit. The parameters will be caught as self.stoploss , self.target and self.trailing_stoploss . Note If you plan to use Bracket Order instead of Regular Orders, then create a separate Python file for it, say strategy_sma_bracket_order.py . You can also change the class name as StrategySMABracketOrder . There will be changes in the entry and exit methods also. The strategy_enter_position method is called once for every instrument. For instance, you want to run this strategy for 5 instruments. Say that the strategy_select_instruments_for_entry method selects 3 instruments for ENTRY positions (BUY/SELL). Then, the strategy_enter_position method will be called thrice, once for each instrument respectively within the candle time frame (say, 15 minutes).","title":"or"},{"location":"pyalgotrad/programexample/#def-strategy_select_instruments_for_exit","text":"def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): instruments = [] meta = [] for instrument in instruments_bucket : if self . main_order . get ( instrument ) is not None : crossover_value = self . get_crossover_value ( instrument ) if crossover_value in [ 1 , - 1 ]: instruments . append ( instrument ) meta . append ({ 'action' : 'EXIT' }) return instruments , meta The strategy_select_instruments_for_exit method does the following: instruments and meta - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (which are in Entry position (BUY/SELL)) and will decide whether to set an exit position or not for it. If condition - The exit steps are executed only if the instrument is holding at an ENTRY position (BUY/SELL). You can do this by checking if the self.main_order object is None or not, and proceed only if it is not None . crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If condition - If the crossover value is 1 or -1, then the instrument is selected for exit position. The selected instrument is appended to the instruments , and the associated action (EXIT) is appended to the meta . instruments and meta - Both the lists (whether populated or empty) are returned to the platform for further actions. Note The actual Exit position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the meta . The Exit position will be taken in the next method below. The meta contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. Whenever a new trading day starts, the strategy_select_instruments_for_exit is called first. This is very important for DELIVERY strategies. Many instruments might be holding in an Entry Position at the end of the previous trading day, and they might be eligible for exit at the start of the new trading day.","title":"def strategy_select_instruments_for_exit()"},{"location":"pyalgotrad/programexample/#def-strategy_exit_position","text":"def strategy_exit_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'EXIT' : self . main_order [ instrument ] . exit_position () self . main_order [ instrument ] = None return True return False The strategy_exit_position method does the following: If condition - checks whether the appropriate action is set in the sideband_info . self.main_order - calls exit_position method for the particular main order of the instrument. If the Entry Position was BUY, then the exit position is automatically taken as SELL and vice versa. The platform takes care of this automatically. self.main_order - set it to None , as the order has been exited and no longer holds anything. Return values - returns True to the platform if the exit steps were performed, else return False .","title":"def strategy_exit_position()"},{"location":"pyalgotrad/programexample/#def-get_crossover_value","text":"def get_crossover_value ( self , instrument ): hist_data = self . get_historical_data ( instrument ) sma_x = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_x ) sma_y = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_y ) crossover_value = self . utils . crossover ( sma_x , sma_y ) return crossover_value The get_crossover_value method does the following: hist_data - The historical data for the instrument is fetched using the get_historical_data method and stored here. The data is in the form of a table (Pandas DataFrame) having the following columns: timestamp - the data and time when the data was measured volume - the volume of that instrument open , high , low and close - the OHLC values of the instrument oi - the Open Interest of that instrument sma_x and sma_y - the SMA function from the talib package is used to calculate the Moving Average for both SMA time-periods. The candle close value is used for calculations, i.e. hist_data['close'] . crossover_value - calculates the crossover value using the crossover method from the utils package. Return value - return the crossover value to the caller method. Note The order of values passed to the crossover method of the utils package is very important. Example: you have 2 SMA values, 5 and 12. The strategy describes that there should be an BUY Entry Position when SMA(5) cuts SMA(12) upwards (crossover value should be 1). In this case, if you mistakenly pass SMA(12) value first and SMA(5) value next to the crossover function, the answer you will get is -1 (Cut downwards). Though, the crossover value is correct, the strategy is expecting to BUY at crossover 1 as per the code, which will not work now. Therefore, the strategy will work correctly only if you pass SMA(5) first and then SMA(12) to the crossover function, thus making the order of parameters passed an important point to be aware of, while coding the strategy.","title":"def get_crossover_value()"},{"location":"pyalgotrad/programexample/#whats-next","text":"Next, you upload the strategy into your AlgoBulls account.","title":"What's Next..."},{"location":"pyalgotrad/structure/","text":"Code Structure of Strategy \u00b6 Previously... \u00b6 You now have the necessary prerequisites installed and ready. Now... \u00b6 This page describes the methods you will use to create your strategy. Let's Start... \u00b6 You have the following methods. Methods \u00b6 strategy_select_instruments_for_entry() - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy, the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether an order is to be punched for that particular instrument or not. strategy_enter_position() - You can now punch your order in this method for each instrument that you have selected for entry in the previous method. strategy_select_instruments_for_exit() - Once a position is entered for a particular instrument, the backend core calls this method for those instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that particular instrument is to be exited or not. strategy_exit_position() - You can now exit positions in this method for each instrument that you have selected for exit in the previous method. Supporting Methods \u00b6 You have the following supporting methods: __init__() - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy. initialize() - This method is called every time the strategy starts for the first time as well as the start of every trading day. You may set initial values for the set of variables that you have declared in the previous method. name() - This method sets a unique name for your strategy. versions_supported() - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you. Utility Functions \u00b6 You have the following utility function to be used in this strategy : get_crossover_value() - A utility method available which calculates the crossover value. Flowchart \u00b6 Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine. What's Next... \u00b6 Next, you code the actual strategy taken as an example in this tutorial. Alternatively, you can pick up a ready strategy and directly upload it.","title":"Code Structure of a Strategy"},{"location":"pyalgotrad/structure/#code-structure-of-strategy","text":"","title":"Code Structure of Strategy"},{"location":"pyalgotrad/structure/#previously","text":"You now have the necessary prerequisites installed and ready.","title":"Previously..."},{"location":"pyalgotrad/structure/#now","text":"This page describes the methods you will use to create your strategy.","title":"Now..."},{"location":"pyalgotrad/structure/#lets-start","text":"You have the following methods.","title":"Let's Start..."},{"location":"pyalgotrad/structure/#methods","text":"strategy_select_instruments_for_entry() - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy, the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether an order is to be punched for that particular instrument or not. strategy_enter_position() - You can now punch your order in this method for each instrument that you have selected for entry in the previous method. strategy_select_instruments_for_exit() - Once a position is entered for a particular instrument, the backend core calls this method for those instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that particular instrument is to be exited or not. strategy_exit_position() - You can now exit positions in this method for each instrument that you have selected for exit in the previous method.","title":"Methods"},{"location":"pyalgotrad/structure/#supporting-methods","text":"You have the following supporting methods: __init__() - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy. initialize() - This method is called every time the strategy starts for the first time as well as the start of every trading day. You may set initial values for the set of variables that you have declared in the previous method. name() - This method sets a unique name for your strategy. versions_supported() - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you.","title":"Supporting Methods"},{"location":"pyalgotrad/structure/#utility-functions","text":"You have the following utility function to be used in this strategy : get_crossover_value() - A utility method available which calculates the crossover value.","title":"Utility Functions"},{"location":"pyalgotrad/structure/#flowchart","text":"Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.","title":"Flowchart"},{"location":"pyalgotrad/structure/#whats-next","text":"Next, you code the actual strategy taken as an example in this tutorial. Alternatively, you can pick up a ready strategy and directly upload it.","title":"What's Next..."},{"location":"pyalgotrad/testing/","text":"Test your Strategy \u00b6 Previously... \u00b6 You have uploaded your strategy to the AlgoBulls platform. Now... \u00b6 Using the uploaded strategy, you can now try: * Backtesting * Paper Trading * Real Trading Before you start... \u00b6 Open a Jupyter Notebook. The steps you will follow are: Establish a connection to the AlgoBulls Platform. Display all Strategies you have in your account. Select the SMA strategy. Optionally, print the strategy once. Select instrument(s). Submit/Run a Backtest, Paper Trade or Real Trade job. Check Job Status. Fetch Logs (even while the job is running). Fetch Reports. (PnL, Statistics, Order History) Let's Start... \u00b6 Run the following code snippets into the Jupyter Notebook one by one (or all together). Import statements \u00b6 from pyalgotrading.algobulls import AlgoBullsConnection from datetime import datetime as dt from pyalgotrading.constants import * Establish a connection to the AlgoBulls Platform \u00b6 algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () The output of the above step is: Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login You will need to log in to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options ( See How ) Once you have the access token, set it in the code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) Replace the token you have copied with the token in the code above. Display all strategies in your account \u00b6 all_strategies = algobulls_connection . get_all_strategies () all_strategies An example of the output will be: Select the SMA strategy \u00b6 Select the last entry of the strategyCode column and display it. strategy_code = all_strategies . iloc [ - 1 ][ 'strategyCode' ] strategy_code Print your Strategy code \u00b6 You can print your strategy code once to verify if this is the correct code. This step is optional. strategy_details1 = algobulls_connection . get_strategy_details ( strategy_code ) print ( strategy_details1 ) Search for instruments (based on a search query) \u00b6 Now display a few instruments with some keyword. The example below uses 'SBIN' as the keyword. instruments = algobulls_connection . search_instrument ( 'SBIN' ) instruments Select an instrument \u00b6 From the output, select the instrument on which you wish to test your strategy. For this example, select the first one. instrument = instruments [ 0 ][ 'value' ] instrument Submit a Job \u00b6 Delete previous trades algobulls_connection . delete_previous_trades ( strategy = strategy ) Set the parameters for the strategy parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 } Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . backtest ( strategy = strategy_code , # strategy code start = '2020-7-1 | 09:15' , # start date-time of strategy ('YYYY-MM-DD | HH:MM') end = '2020-7-7 | 15:30' , # end date-time of strategy ('YYYY-MM-DD | HH:MM') instruments = 'NSE:SBIN' , # name of the instrument lots = 1 , # number of lots per trade parameters = parameters , # parameters required for the strategy candle = '15 minutes' , # candle size eg : '1 Day', '1 hour', '3 minutes' delete_previous_trades = True , # delete the previous trades for papertrading (default is true), initial_funds_virtual = 10000 # virtual funds allotted before the paper trading starts (default is 1e9) ) Paper Trading algobulls_connection . papertrade ( strategy = strategy_code , # strategy code start = '09:15' , # start time of strategy (HH:MM) end = '15:30' , # end time of strategy (HH:MM) instruments = 'NSE:SBIN' , # name of the instrument lots = 1 , # number of lots per trade parameters = parameters , # parameters required for the strategy candle = '15 minutes' , # candle size eg : '1 Day', '1 hour', '3 minutes' delete_previous_trades = True , # delete the previous trades for papertrading (default is true) initial_funds_virtual = 10000 # virtual funds allotted before the paper trading starts (default is 1e9) ) Real Trading algobulls_connection . realtrade ( strategy = strategy_code , # strategy code start = '09:15' , # start time of strategy (HH:MM) end = '15:30' , # end time of strategy (HH:MM) instruments = 'NSE:SBIN' , # name of the instrument lots = 1 , # number of lots per trade parameters = parameters , # parameters required for the strategy candle = '15 minutes' , # candle size eg : '1 Day', '1 hour', '3 minutes' brokerId = 53 # ID of the broker for real trade ) Fetch Job Status \u00b6 Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . get_backtesting_job_status ( strategy_code ) Paper Trading algobulls_connection . get_papertrading_job_status ( strategy_code ) Real Trading algobulls_connection . get_realtrading_job_status ( strategy_code ) You can stop a submitted job anytime. Stop a Job \u00b6 Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . stop_backtesting_job ( strategy_code ) Paper Trading algobulls_connection . stop_papertrading_job ( strategy_code ) Real Trading algobulls_connection . stop_realtrading_job ( strategy_code ) You can fetch the logs in the middle of a job to monitor the progress. Fetch logs of an ongoing/stopped/completed job \u00b6 Click on each of the tabs to see the relevant code snippet. Backtesting logs = algobulls_connection . get_backtesting_logs ( strategy_code ) print ( logs ) Paper Trading logs = algobulls_connection . get_papertrading_logs ( strategy_code ) print ( logs ) Real Trading logs = algobulls_connection . get_realtrading_logs ( strategy_code ) print ( logs ) You can fetch the PnL report, statistics and order history for a job. Fetch PnL Reports \u00b6 Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . get_backtesting_report_pnl_table ( strategy_code , show_all_rows = True ) Paper Trading algobulls_connection . get_papertrading_report_pnl_table ( strategy_code , show_all_rows = True ) Real Trading algobulls_connection . get_realtrading_report_pnl_table ( strategy_code , show_all_rows = True ) Fetch Report Statistics \u00b6 Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . get_backtesting_report_statistics ( strategy_code , # strategy code mode = 'quantstats' , # package used to generate statistics report = 'full' , # format of the report html_dump = True # save report as html file ) Paper Trading algobulls_connection . get_papertrading_report_statistics ( strategy_code , # strategy code mode = 'quantstats' , # package used to generate statistics report = 'full' , # format of the report html_dump = True # save report as html file ) Real Trading algobulls_connection . get_realtrading_report_statistics ( strategy_code , # strategy code mode = 'quantstats' , # package used to generate statistics report = 'full' , # format of the report html_dump = True # save report as html file ) Fetch Order History \u00b6 Click on each of the tabs to see the relevant code snippet. Backtesting order_history = algobulls_connection . get_backtesting_report_order_history ( strategy_code ) print ( order_history ) Paper Trading order_history = algobulls_connection . get_papertrading_report_order_history ( strategy_code ) print ( order_history ) Real Trading order_history = algobulls_connection . get_realtrading_report_order_history ( strategy_code ) print ( order_history ) Note Order History for Real Trading is not supported by brokers. Order History for Backtesting, Paper Trading and Real Trading is supported by the AlgoBulls Virtual Brokers . What's Next... \u00b6 You can now explore more by creating and uploading more complex strategies. You can also check out the Strategy Coding Guidelines .","title":"Test your Strategy"},{"location":"pyalgotrad/testing/#test-your-strategy","text":"","title":"Test your Strategy"},{"location":"pyalgotrad/testing/#previously","text":"You have uploaded your strategy to the AlgoBulls platform.","title":"Previously..."},{"location":"pyalgotrad/testing/#now","text":"Using the uploaded strategy, you can now try: * Backtesting * Paper Trading * Real Trading","title":"Now..."},{"location":"pyalgotrad/testing/#before-you-start","text":"Open a Jupyter Notebook. The steps you will follow are: Establish a connection to the AlgoBulls Platform. Display all Strategies you have in your account. Select the SMA strategy. Optionally, print the strategy once. Select instrument(s). Submit/Run a Backtest, Paper Trade or Real Trade job. Check Job Status. Fetch Logs (even while the job is running). Fetch Reports. (PnL, Statistics, Order History)","title":"Before you start..."},{"location":"pyalgotrad/testing/#lets-start","text":"Run the following code snippets into the Jupyter Notebook one by one (or all together).","title":"Let's Start..."},{"location":"pyalgotrad/testing/#import-statements","text":"from pyalgotrading.algobulls import AlgoBullsConnection from datetime import datetime as dt from pyalgotrading.constants import *","title":"Import statements"},{"location":"pyalgotrad/testing/#establish-a-connection-to-the-algobulls-platform","text":"algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () The output of the above step is: Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login You will need to log in to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options ( See How ) Once you have the access token, set it in the code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) Replace the token you have copied with the token in the code above.","title":"Establish a connection to the AlgoBulls Platform"},{"location":"pyalgotrad/testing/#display-all-strategies-in-your-account","text":"all_strategies = algobulls_connection . get_all_strategies () all_strategies An example of the output will be:","title":"Display all strategies in your account"},{"location":"pyalgotrad/testing/#select-the-sma-strategy","text":"Select the last entry of the strategyCode column and display it. strategy_code = all_strategies . iloc [ - 1 ][ 'strategyCode' ] strategy_code","title":"Select the SMA strategy"},{"location":"pyalgotrad/testing/#print-your-strategy-code","text":"You can print your strategy code once to verify if this is the correct code. This step is optional. strategy_details1 = algobulls_connection . get_strategy_details ( strategy_code ) print ( strategy_details1 )","title":"Print your Strategy code"},{"location":"pyalgotrad/testing/#search-for-instruments-based-on-a-search-query","text":"Now display a few instruments with some keyword. The example below uses 'SBIN' as the keyword. instruments = algobulls_connection . search_instrument ( 'SBIN' ) instruments","title":"Search for instruments (based on a search query)"},{"location":"pyalgotrad/testing/#select-an-instrument","text":"From the output, select the instrument on which you wish to test your strategy. For this example, select the first one. instrument = instruments [ 0 ][ 'value' ] instrument","title":"Select an instrument"},{"location":"pyalgotrad/testing/#submit-a-job","text":"Delete previous trades algobulls_connection . delete_previous_trades ( strategy = strategy ) Set the parameters for the strategy parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 } Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . backtest ( strategy = strategy_code , # strategy code start = '2020-7-1 | 09:15' , # start date-time of strategy ('YYYY-MM-DD | HH:MM') end = '2020-7-7 | 15:30' , # end date-time of strategy ('YYYY-MM-DD | HH:MM') instruments = 'NSE:SBIN' , # name of the instrument lots = 1 , # number of lots per trade parameters = parameters , # parameters required for the strategy candle = '15 minutes' , # candle size eg : '1 Day', '1 hour', '3 minutes' delete_previous_trades = True , # delete the previous trades for papertrading (default is true), initial_funds_virtual = 10000 # virtual funds allotted before the paper trading starts (default is 1e9) ) Paper Trading algobulls_connection . papertrade ( strategy = strategy_code , # strategy code start = '09:15' , # start time of strategy (HH:MM) end = '15:30' , # end time of strategy (HH:MM) instruments = 'NSE:SBIN' , # name of the instrument lots = 1 , # number of lots per trade parameters = parameters , # parameters required for the strategy candle = '15 minutes' , # candle size eg : '1 Day', '1 hour', '3 minutes' delete_previous_trades = True , # delete the previous trades for papertrading (default is true) initial_funds_virtual = 10000 # virtual funds allotted before the paper trading starts (default is 1e9) ) Real Trading algobulls_connection . realtrade ( strategy = strategy_code , # strategy code start = '09:15' , # start time of strategy (HH:MM) end = '15:30' , # end time of strategy (HH:MM) instruments = 'NSE:SBIN' , # name of the instrument lots = 1 , # number of lots per trade parameters = parameters , # parameters required for the strategy candle = '15 minutes' , # candle size eg : '1 Day', '1 hour', '3 minutes' brokerId = 53 # ID of the broker for real trade )","title":"Submit a Job"},{"location":"pyalgotrad/testing/#fetch-job-status","text":"Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . get_backtesting_job_status ( strategy_code ) Paper Trading algobulls_connection . get_papertrading_job_status ( strategy_code ) Real Trading algobulls_connection . get_realtrading_job_status ( strategy_code ) You can stop a submitted job anytime.","title":"Fetch Job Status"},{"location":"pyalgotrad/testing/#stop-a-job","text":"Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . stop_backtesting_job ( strategy_code ) Paper Trading algobulls_connection . stop_papertrading_job ( strategy_code ) Real Trading algobulls_connection . stop_realtrading_job ( strategy_code ) You can fetch the logs in the middle of a job to monitor the progress.","title":"Stop a Job"},{"location":"pyalgotrad/testing/#fetch-logs-of-an-ongoingstoppedcompleted-job","text":"Click on each of the tabs to see the relevant code snippet. Backtesting logs = algobulls_connection . get_backtesting_logs ( strategy_code ) print ( logs ) Paper Trading logs = algobulls_connection . get_papertrading_logs ( strategy_code ) print ( logs ) Real Trading logs = algobulls_connection . get_realtrading_logs ( strategy_code ) print ( logs ) You can fetch the PnL report, statistics and order history for a job.","title":"Fetch logs of an ongoing/stopped/completed job"},{"location":"pyalgotrad/testing/#fetch-pnl-reports","text":"Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . get_backtesting_report_pnl_table ( strategy_code , show_all_rows = True ) Paper Trading algobulls_connection . get_papertrading_report_pnl_table ( strategy_code , show_all_rows = True ) Real Trading algobulls_connection . get_realtrading_report_pnl_table ( strategy_code , show_all_rows = True )","title":"Fetch PnL Reports"},{"location":"pyalgotrad/testing/#fetch-report-statistics","text":"Click on each of the tabs to see the relevant code snippet. Backtesting algobulls_connection . get_backtesting_report_statistics ( strategy_code , # strategy code mode = 'quantstats' , # package used to generate statistics report = 'full' , # format of the report html_dump = True # save report as html file ) Paper Trading algobulls_connection . get_papertrading_report_statistics ( strategy_code , # strategy code mode = 'quantstats' , # package used to generate statistics report = 'full' , # format of the report html_dump = True # save report as html file ) Real Trading algobulls_connection . get_realtrading_report_statistics ( strategy_code , # strategy code mode = 'quantstats' , # package used to generate statistics report = 'full' , # format of the report html_dump = True # save report as html file )","title":"Fetch Report Statistics"},{"location":"pyalgotrad/testing/#fetch-order-history","text":"Click on each of the tabs to see the relevant code snippet. Backtesting order_history = algobulls_connection . get_backtesting_report_order_history ( strategy_code ) print ( order_history ) Paper Trading order_history = algobulls_connection . get_papertrading_report_order_history ( strategy_code ) print ( order_history ) Real Trading order_history = algobulls_connection . get_realtrading_report_order_history ( strategy_code ) print ( order_history ) Note Order History for Real Trading is not supported by brokers. Order History for Backtesting, Paper Trading and Real Trading is supported by the AlgoBulls Virtual Brokers .","title":"Fetch Order History"},{"location":"pyalgotrad/testing/#whats-next","text":"You can now explore more by creating and uploading more complex strategies. You can also check out the Strategy Coding Guidelines .","title":"What's Next..."},{"location":"pyalgotrad/upload/","text":"Upload your Strategy \u00b6 Previously... \u00b6 You have created a strategy by: Coding the complete strategy from the Create page. OR Picking up a ready strategy from the pyalgostrategypool package. Now... \u00b6 You are now ready to upload your strategy into your AlgoBulls account for Backtesting, Paper Trading and/or Real Trading. Before you start... \u00b6 Make sure you have an active working AlgoBulls account ready to go! Open a Jupyter Notebook. If you have coded the strategy yourself and not used a ready strategy from the pyalgostrategypool package, then make sure your strategy file (.py) and the Jupyter Notebook are in the same folder . Let's Start... \u00b6 Run the following code snippets into the Jupyter Notebook one by one (or all together). Import statements \u00b6 import inspect from pyalgotrading.algobulls import AlgoBullsConnection Import the strategy class \u00b6 Perform the below step either to import a ready strategy OR to import your own created strategy. Import a ready strategy from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder Import your own strategy from strategy_sma_regular_order import StrategySMARegularOrder Establish a connection to the AlgoBulls Platform \u00b6 algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () The output of the above step is: Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login You will need to log in to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options ( See How ) Once you have the access token, set it in the code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) Replace the token you have copied with the token in the code above. Print your Strategy code \u00b6 You can print your strategy code once to verify if this is the correct code before uploading it to the platform. This step is optional. print ( inspect . getsource ( StrategySMARegularOrder )) Upload your Strategy \u00b6 Upload your strategy as shown in the code below. algobulls_connection . create_strategy ( StrategySMARegularOrder ) Re-upload your Strategy after modifications \u00b6 If you are re-uploading your strategy after some changes, then use the overwrite switch as shown here. algobulls_connection . create_strategy ( StrategySMARegularOrder , overwrite = True ) What's Next... \u00b6 You are now ready to test your uploaded strategy and perform Backtesting, Paper Trading and/or Real Trading with it.","title":"Upload your Strategy"},{"location":"pyalgotrad/upload/#upload-your-strategy","text":"","title":"Upload your Strategy"},{"location":"pyalgotrad/upload/#previously","text":"You have created a strategy by: Coding the complete strategy from the Create page. OR Picking up a ready strategy from the pyalgostrategypool package.","title":"Previously..."},{"location":"pyalgotrad/upload/#now","text":"You are now ready to upload your strategy into your AlgoBulls account for Backtesting, Paper Trading and/or Real Trading.","title":"Now..."},{"location":"pyalgotrad/upload/#before-you-start","text":"Make sure you have an active working AlgoBulls account ready to go! Open a Jupyter Notebook. If you have coded the strategy yourself and not used a ready strategy from the pyalgostrategypool package, then make sure your strategy file (.py) and the Jupyter Notebook are in the same folder .","title":"Before you start..."},{"location":"pyalgotrad/upload/#lets-start","text":"Run the following code snippets into the Jupyter Notebook one by one (or all together).","title":"Let's Start..."},{"location":"pyalgotrad/upload/#import-statements","text":"import inspect from pyalgotrading.algobulls import AlgoBullsConnection","title":"Import statements"},{"location":"pyalgotrad/upload/#import-the-strategy-class","text":"Perform the below step either to import a ready strategy OR to import your own created strategy. Import a ready strategy from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder Import your own strategy from strategy_sma_regular_order import StrategySMARegularOrder","title":"Import the strategy class"},{"location":"pyalgotrad/upload/#establish-a-connection-to-the-algobulls-platform","text":"algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () The output of the above step is: Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login You will need to log in to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options ( See How ) Once you have the access token, set it in the code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) Replace the token you have copied with the token in the code above.","title":"Establish a connection to the AlgoBulls Platform"},{"location":"pyalgotrad/upload/#print-your-strategy-code","text":"You can print your strategy code once to verify if this is the correct code before uploading it to the platform. This step is optional. print ( inspect . getsource ( StrategySMARegularOrder ))","title":"Print your Strategy code"},{"location":"pyalgotrad/upload/#upload-your-strategy_1","text":"Upload your strategy as shown in the code below. algobulls_connection . create_strategy ( StrategySMARegularOrder )","title":"Upload your Strategy"},{"location":"pyalgotrad/upload/#re-upload-your-strategy-after-modifications","text":"If you are re-uploading your strategy after some changes, then use the overwrite switch as shown here. algobulls_connection . create_strategy ( StrategySMARegularOrder , overwrite = True )","title":"Re-upload your Strategy after modifications"},{"location":"pyalgotrad/upload/#whats-next","text":"You are now ready to test your uploaded strategy and perform Backtesting, Paper Trading and/or Real Trading with it.","title":"What's Next..."},{"location":"python_build/","text":"Welcome to pythonbuild Documentation! \u00b6 Index \u00b6 Introduction: \u00b6 Introduction Overview Get Started Code: \u00b6 Code Ready Templates Code New Strategy Configure Parameters Features: \u00b6 View Results","title":"Index"},{"location":"python_build/#welcome-to-pythonbuild-documentation","text":"","title":"Welcome to pythonbuild Documentation!"},{"location":"python_build/#index","text":"","title":"Index"},{"location":"python_build/#introduction","text":"Introduction Overview Get Started","title":"Introduction:"},{"location":"python_build/#code","text":"Code Ready Templates Code New Strategy Configure Parameters","title":"Code:"},{"location":"python_build/#features","text":"View Results","title":"Features:"},{"location":"python_build/python-build-code-new/","text":"How to code a new strategy? \u00b6 If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section. A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section. Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view & edit the strategy parameters. To test the behaviour and performance of the strategy, click on Save & Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section. You can rename a strategy by clicking the edit symbol besides the strategy name.","title":"Code New Strategy"},{"location":"python_build/python-build-code-new/#how-to-code-a-new-strategy","text":"If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section. A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section. Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view & edit the strategy parameters. To test the behaviour and performance of the strategy, click on Save & Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section. You can rename a strategy by clicking the edit symbol besides the strategy name.","title":"How to code a new strategy?"},{"location":"python_build/python-build-code-ready-templates/","text":"How to code strategies using Ready Templates? \u00b6 Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates click on More . Click on the Code button placed in the bottom right corner of the selected template to view the strategy code. You should now see the code editor , where you can start modifying the code as required. To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies . Follow these simple steps to test the strategy's performance Step 1 After clicking Save & Start , a pop-up window will appear. Step 2 In the customizations section choose Backtesting to back test or Paper Trading to Paper Trade a strategy. Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting you will need to put the start date and end date along with time. In Paper Trading you only need to add the start and end time. Step 3 Once you scroll below, you will see the P&L tracker. Switch the P&L tracker ON and enter your desired profit and risk appetite. To keep things simple, you can also leave it turned off. Step 4 In the Configuration section, you can check the parameters added or modified by you. Step 5 To begin testing the strategy, click on Execute. Step 6 Go to the Results section to see how the strategy has performed. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. You can rename a strategy by clicking the edit symbol besides the strategy name. Note: The Analytics & Graph sections are only visible to premium plan users. If you are using a free plan, switch to a premium developer plan now .","title":"Code Ready Templates"},{"location":"python_build/python-build-code-ready-templates/#how-to-code-strategies-using-ready-templates","text":"Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates click on More . Click on the Code button placed in the bottom right corner of the selected template to view the strategy code. You should now see the code editor , where you can start modifying the code as required. To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies . Follow these simple steps to test the strategy's performance Step 1 After clicking Save & Start , a pop-up window will appear. Step 2 In the customizations section choose Backtesting to back test or Paper Trading to Paper Trade a strategy. Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting you will need to put the start date and end date along with time. In Paper Trading you only need to add the start and end time. Step 3 Once you scroll below, you will see the P&L tracker. Switch the P&L tracker ON and enter your desired profit and risk appetite. To keep things simple, you can also leave it turned off. Step 4 In the Configuration section, you can check the parameters added or modified by you. Step 5 To begin testing the strategy, click on Execute. Step 6 Go to the Results section to see how the strategy has performed. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. You can rename a strategy by clicking the edit symbol besides the strategy name. Note: The Analytics & Graph sections are only visible to premium plan users. If you are using a free plan, switch to a premium developer plan now .","title":"How to code strategies using Ready Templates?"},{"location":"python_build/python-build-config-parameters/","text":"How to Configure Strategy Parameters? \u00b6 You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can view a strategy\u2019s parameters or edit these parameters too. To know more about the parameters, click here . User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.","title":"Configure Parameters"},{"location":"python_build/python-build-config-parameters/#how-to-configure-strategy-parameters","text":"You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can view a strategy\u2019s parameters or edit these parameters too. To know more about the parameters, click here . User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.","title":"How to Configure Strategy Parameters?"},{"location":"python_build/python-build-getstarted/","text":"How to get started with Python Build? \u00b6 To start developing your own strategy, you must first activate a plan from the Plans & Wallet section. Select the Developers option in the Explore Plans section and select a plan of your choice. There are currently two developer plans available: Premium Developer Plan : Develop your own Algorithmic Trading Strategy with Analytics support, concurrent Strategy Executions, Professional Support, and more. Free Developer Plan : Develop your own Algorithmic Trading Strategy for Free. After selecting your preferred plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use My Coded Strategies section to create your own strategies","title":"Python build getstarted"},{"location":"python_build/python-build-getstarted/#how-to-get-started-with-python-build","text":"To start developing your own strategy, you must first activate a plan from the Plans & Wallet section. Select the Developers option in the Explore Plans section and select a plan of your choice. There are currently two developer plans available: Premium Developer Plan : Develop your own Algorithmic Trading Strategy with Analytics support, concurrent Strategy Executions, Professional Support, and more. Free Developer Plan : Develop your own Algorithmic Trading Strategy for Free. After selecting your preferred plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use My Coded Strategies section to create your own strategies","title":"How to get started with Python Build?"},{"location":"python_build/python-build-introduction/","text":"Python Build \u00b6 Introduction \u00b6 Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infra so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak till you are satisfied with the performance. Get your strategy approved for live Trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic. Go to Build Strategy in the sidebar navigation and select Python Build to know more.","title":"Python Build"},{"location":"python_build/python-build-introduction/#python-build","text":"","title":"Python Build"},{"location":"python_build/python-build-introduction/#introduction","text":"Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infra so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak till you are satisfied with the performance. Get your strategy approved for live Trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic. Go to Build Strategy in the sidebar navigation and select Python Build to know more.","title":"Introduction"},{"location":"python_build/python-build-overview/","text":"An overview \u00b6 Running Strategies: This section shows how many strategies are currently active and running in your account. Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users. Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. Active Plan: This section displays the current plan active on your AlgoBulls account. Ready Templates: Ready-to-use templates that you can modify and test. My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you. Quick Help: Resources to help you code better.","title":"Overview"},{"location":"python_build/python-build-overview/#an-overview","text":"Running Strategies: This section shows how many strategies are currently active and running in your account. Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users. Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. Active Plan: This section displays the current plan active on your AlgoBulls account. Ready Templates: Ready-to-use templates that you can modify and test. My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you. Quick Help: Resources to help you code better.","title":"An overview"},{"location":"python_build/python-build-view-results/","text":"How to view the Results? \u00b6 Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results. Only Premium developer plans users will be able to view the strategy analytics values & graphs. Statistics: In the statistics section, you can view a strategy\u2019s Stats & various other metrics in the form of graphs like P&L. i. Stats: In this section you can see the hit ratio, number of trades, average trades per day . ii. P&L (INR): The trade by trade P&L in INR. iii. P&L %: The trade by trade P&L in percentage form. iv. The Graph Tool v. P&L Book: View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit & Loss, Trading Volume & Total number of Trades. vi. User Log: Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance. vii. Order History: View the order state transition for every order placed by your strategy in depth.","title":"View Results"},{"location":"python_build/python-build-view-results/#how-to-view-the-results","text":"Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results. Only Premium developer plans users will be able to view the strategy analytics values & graphs. Statistics: In the statistics section, you can view a strategy\u2019s Stats & various other metrics in the form of graphs like P&L. i. Stats: In this section you can see the hit ratio, number of trades, average trades per day . ii. P&L (INR): The trade by trade P&L in INR. iii. P&L %: The trade by trade P&L in percentage form. iv. The Graph Tool v. P&L Book: View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit & Loss, Trading Volume & Total number of Trades. vi. User Log: Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance. vii. Order History: View the order state transition for every order placed by your strategy in depth.","title":"How to view the Results?"},{"location":"python_build/python-build/","text":"Python Build \u00b6 1. Introduction \u00b6 Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infra so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak till you are satisfied with the performance. Get your strategy approved for live Trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic. Go to Build Strategy in the sidebar navigation and select Python Build to know more. 2. An overview \u00b6 Running Strategies: This section shows how many strategies are currently active and running in your account. Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users. Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. Active Plan: This section displays the current plan active on your AlgoBulls account. Ready Templates: Ready-to-use templates that you can modify and test. My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you. Quick Help: Resources to help you code better. 3. How to get started with Python Build? \u00b6 To start developing your own strategy, you must first activate a plan from the Plans & Wallet section. Select the Developers option in the Explore Plans section and select a plan of your choice. There are currently two developer plans available: Premium Developer Plan : Develop your own Algorithmic Trading Strategy with Analytics support, concurrent Strategy Executions, Professional Support, and more. Free Developer Plan : Develop your own Algorithmic Trading Strategy for Free. After selecting your preferred plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use My Coded Strategies section to create your own strategies 4. How to code strategies using Ready Templates? \u00b6 Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates click on More . Click on the Code button placed in the bottom right corner of the selected template to view the strategy code. You should now see the code editor , where you can start modifying the code as required. To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies . Follow these simple steps to test the strategy's performance Step 1 After clicking Save & Start , a pop-up window will appear. Step 2 In the customizations section choose Backtesting to back test or Paper Trading to Paper Trade a strategy. Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting you will need to put the start date and end date along with time. In Paper Trading you only need to add the start and end time. Step 3 Once you scroll below, you will see the P&L tracker. Switch the P&L tracker ON and enter your desired profit and risk appetite. To keep things simple, you can also leave it turned off. Step 4 In the Configuration section, you can check the parameters added or modified by you. Step 5 To begin testing the strategy, click on Execute. Step 6 Go to the Results section to see how the strategy has performed. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. You can rename a strategy by clicking the edit symbol besides the strategy name. Note: The Analytics & Graph sections are only visible to premium plan users. If you are using a free plan, switch to a premium developer plan now . 5. How to view the Results? \u00b6 Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results. Only Premium developer plans users will be able to view the strategy analytics values & graphs. Statistics: In the statistics section, you can view a strategy\u2019s Stats & various other metrics in the form of graphs like P&L. i. Stats: In this section you can see the hit ratio, number of trades, average trades per day . ii. P&L (INR): The trade by trade P&L in INR. iii. P&L %: The trade by trade P&L in percentage form. iv. The Graph Tool v. P&L Book: View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit & Loss, Trading Volume & Total number of Trades. vi. User Log: Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance. vii. Order History: View the order state transition for every order placed by your strategy in depth. 6. How to code a new strategy? \u00b6 If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section. A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section. Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view & edit the strategy parameters. To test the behaviour and performance of the strategy, click on Save & Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section. You can rename a strategy by clicking the edit symbol besides the strategy name. 7. How to Configure Strategy Parameters? \u00b6 You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can view a strategy\u2019s parameters or edit these parameters too. To know more about the parameters, click here . User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.","title":"Python Build"},{"location":"python_build/python-build/#python-build","text":"","title":"Python Build"},{"location":"python_build/python-build/#1-introduction","text":"Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infra so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak till you are satisfied with the performance. Get your strategy approved for live Trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic. Go to Build Strategy in the sidebar navigation and select Python Build to know more.","title":"1. Introduction"},{"location":"python_build/python-build/#2-an-overview","text":"Running Strategies: This section shows how many strategies are currently active and running in your account. Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users. Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. Active Plan: This section displays the current plan active on your AlgoBulls account. Ready Templates: Ready-to-use templates that you can modify and test. My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you. Quick Help: Resources to help you code better.","title":"2. An overview"},{"location":"python_build/python-build/#3-how-to-get-started-with-python-build","text":"To start developing your own strategy, you must first activate a plan from the Plans & Wallet section. Select the Developers option in the Explore Plans section and select a plan of your choice. There are currently two developer plans available: Premium Developer Plan : Develop your own Algorithmic Trading Strategy with Analytics support, concurrent Strategy Executions, Professional Support, and more. Free Developer Plan : Develop your own Algorithmic Trading Strategy for Free. After selecting your preferred plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use My Coded Strategies section to create your own strategies","title":"3. How to get started with Python Build?"},{"location":"python_build/python-build/#4-how-to-code-strategies-using-ready-templates","text":"Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates click on More . Click on the Code button placed in the bottom right corner of the selected template to view the strategy code. You should now see the code editor , where you can start modifying the code as required. To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies . Follow these simple steps to test the strategy's performance Step 1 After clicking Save & Start , a pop-up window will appear. Step 2 In the customizations section choose Backtesting to back test or Paper Trading to Paper Trade a strategy. Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting you will need to put the start date and end date along with time. In Paper Trading you only need to add the start and end time. Step 3 Once you scroll below, you will see the P&L tracker. Switch the P&L tracker ON and enter your desired profit and risk appetite. To keep things simple, you can also leave it turned off. Step 4 In the Configuration section, you can check the parameters added or modified by you. Step 5 To begin testing the strategy, click on Execute. Step 6 Go to the Results section to see how the strategy has performed. Note: The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy & analyse the strategy results 24x7. You can rename a strategy by clicking the edit symbol besides the strategy name. Note: The Analytics & Graph sections are only visible to premium plan users. If you are using a free plan, switch to a premium developer plan now .","title":"4. How to code strategies using Ready Templates?"},{"location":"python_build/python-build/#5-how-to-view-the-results","text":"Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy. Even if the strategy execution is not complete, you will still see intermediate results. Only Premium developer plans users will be able to view the strategy analytics values & graphs. Statistics: In the statistics section, you can view a strategy\u2019s Stats & various other metrics in the form of graphs like P&L. i. Stats: In this section you can see the hit ratio, number of trades, average trades per day . ii. P&L (INR): The trade by trade P&L in INR. iii. P&L %: The trade by trade P&L in percentage form. iv. The Graph Tool v. P&L Book: View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit & Loss, Trading Volume & Total number of Trades. vi. User Log: Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance. vii. Order History: View the order state transition for every order placed by your strategy in depth.","title":"5. How to view the Results?"},{"location":"python_build/python-build/#6-how-to-code-a-new-strategy","text":"If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section. A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section. Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view & edit the strategy parameters. To test the behaviour and performance of the strategy, click on Save & Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section. You can rename a strategy by clicking the edit symbol besides the strategy name.","title":"6. How to code a new strategy?"},{"location":"python_build/python-build/#7-how-to-configure-strategy-parameters","text":"You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can view a strategy\u2019s parameters or edit these parameters too. To know more about the parameters, click here . User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.","title":"7. How to Configure Strategy Parameters?"},{"location":"strategies/aroon_crossover/","text":"Aroon Crossover \u00b6 This is a trading strategy called \"Aroon Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Aroon indicator crossover. Aroon Indicator \u00b6 In the stock market, Aroon refers to the Aroon indicator, which is a technical analysis tool used to measure the strength and direction of a trend. It consists of two lines, the Aroon-Up line and the Aroon-Down line. The Aroon-Up line measures the number of periods since the highest price within a given period, while the Aroon-Down line measures the number of periods since the lowest price within a given period. The Aroon indicator ranges from 0 to 100, with values closer to 100 indicating a strong trend and values closer to 0 indicating a weak or non-existent trend. Traders and investors use the Aroon indicator to identify potential trend reversals, assess the strength of a trend, and generate buy or sell signals. For example, when the Aroon-Up line crosses above the Aroon-Down line, it may suggest a bullish trend, while a cross below may indicate a bearish trend. It's important to note that the Aroon indicator is just one of many tools used in technical analysis, and its effectiveness can vary depending on market conditions and other factors. It is often used in conjunction with other indicators and analysis techniques to make informed trading decisions. Strategy Overview \u00b6 This strategy, called Aroon Crossover v2, implements a crossover strategy using the Aroon indicator. It generates entry and exit signals based on the crossover of Aroon Up and Aroon Down values. Strategy Parameters \u00b6 The following parameters can be configured for the strategy: TIME_PERIOD The period for which we calculate the Aroon Value Crossover Calculation \u00b6 The get_crossover_value method calculates the Aroon Up and Aroon Down values for a given instrument based on the historical data. It uses the talib.AROON function from the Talib library to calculate the values. The method then determines the crossover of Aroon Up and Aroon Down and returns the corresponding entry or exit action.","title":"Aroon Crossover"},{"location":"strategies/aroon_crossover/#aroon-crossover","text":"This is a trading strategy called \"Aroon Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Aroon indicator crossover.","title":"Aroon Crossover"},{"location":"strategies/aroon_crossover/#aroon-indicator","text":"In the stock market, Aroon refers to the Aroon indicator, which is a technical analysis tool used to measure the strength and direction of a trend. It consists of two lines, the Aroon-Up line and the Aroon-Down line. The Aroon-Up line measures the number of periods since the highest price within a given period, while the Aroon-Down line measures the number of periods since the lowest price within a given period. The Aroon indicator ranges from 0 to 100, with values closer to 100 indicating a strong trend and values closer to 0 indicating a weak or non-existent trend. Traders and investors use the Aroon indicator to identify potential trend reversals, assess the strength of a trend, and generate buy or sell signals. For example, when the Aroon-Up line crosses above the Aroon-Down line, it may suggest a bullish trend, while a cross below may indicate a bearish trend. It's important to note that the Aroon indicator is just one of many tools used in technical analysis, and its effectiveness can vary depending on market conditions and other factors. It is often used in conjunction with other indicators and analysis techniques to make informed trading decisions.","title":"Aroon Indicator"},{"location":"strategies/aroon_crossover/#strategy-overview","text":"This strategy, called Aroon Crossover v2, implements a crossover strategy using the Aroon indicator. It generates entry and exit signals based on the crossover of Aroon Up and Aroon Down values.","title":"Strategy Overview"},{"location":"strategies/aroon_crossover/#strategy-parameters","text":"The following parameters can be configured for the strategy: TIME_PERIOD The period for which we calculate the Aroon Value","title":"Strategy Parameters"},{"location":"strategies/aroon_crossover/#crossover-calculation","text":"The get_crossover_value method calculates the Aroon Up and Aroon Down values for a given instrument based on the historical data. It uses the talib.AROON function from the Talib library to calculate the values. The method then determines the crossover of Aroon Up and Aroon Down and returns the corresponding entry or exit action.","title":"Crossover Calculation"},{"location":"strategies/bollinger_bands/","text":"Bollinger Bands \u00b6 This is a trading strategy called \"Bollinger Bands v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the bollinger bands indicator values. Bollinger Bands Indicator \u00b6 Bollinger Bands consists of a middle band (typically a 20-day Simple Moving Average) and two bands that represent the upper and lower price boundaries based on standard deviations. The bands adjust dynamically with market volatility. Key points about Bollinger Bands: The middle band is a moving average, while the upper and lower bands are calculated by adding/subtracting standard deviations from the middle band. Bollinger Bands help assess price volatility and identify potential overbought or oversold market conditions. A narrowing of the bands (Bollinger Squeeze) suggests low volatility, often followed by increased volatility and potential price breakout. Touching or exceeding the upper band may indicate an overbought market, while touching or falling below the lower band may suggest an oversold market. Price reversals can be observed when the price moves from one band to the other. The upper and lower bands can act as dynamic support and resistance levels. Bollinger Bands are used in combination with other indicators and analysis techniques to make trading decisions. They are not a standalone strategy but provide valuable insights when combined with other tools like the RSI. Strategy Overview \u00b6 This strategy, called Bollinger Bands v2, is an implementation of the Bollinger Bands indicator. It uses the Bollinger Bands values to compare with previous candle's OPEN, HIGH, LOW and CLOSE values and generate entry and exit signals for trading instruments. Strategy Parameters \u00b6 The following parameters can be configured for the strategy: TIME_PERIOD : Period (number of candles) by which Bollinger Bands are calculated STANDARD_DEVIATION : Standard deviation (in percent) for upper and lower band from the signal bands Decision Calculation \u00b6 The get_decision method calculates the Bollinger Bands values for a given instrument based on the OHLC (Open, High, Low, Close) historical data. It uses the talib.BBANDS function from the Talib library to calculate the upper and lower bands. The method compares the previous candle's open, low, and close values with the upper and lower bands to determine the entry or exit action. If the conditions for a buy or sell signal are met, the corresponding action is returned.","title":"Bollinger Bands"},{"location":"strategies/bollinger_bands/#bollinger-bands","text":"This is a trading strategy called \"Bollinger Bands v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the bollinger bands indicator values.","title":"Bollinger Bands"},{"location":"strategies/bollinger_bands/#bollinger-bands-indicator","text":"Bollinger Bands consists of a middle band (typically a 20-day Simple Moving Average) and two bands that represent the upper and lower price boundaries based on standard deviations. The bands adjust dynamically with market volatility. Key points about Bollinger Bands: The middle band is a moving average, while the upper and lower bands are calculated by adding/subtracting standard deviations from the middle band. Bollinger Bands help assess price volatility and identify potential overbought or oversold market conditions. A narrowing of the bands (Bollinger Squeeze) suggests low volatility, often followed by increased volatility and potential price breakout. Touching or exceeding the upper band may indicate an overbought market, while touching or falling below the lower band may suggest an oversold market. Price reversals can be observed when the price moves from one band to the other. The upper and lower bands can act as dynamic support and resistance levels. Bollinger Bands are used in combination with other indicators and analysis techniques to make trading decisions. They are not a standalone strategy but provide valuable insights when combined with other tools like the RSI.","title":"Bollinger Bands Indicator"},{"location":"strategies/bollinger_bands/#strategy-overview","text":"This strategy, called Bollinger Bands v2, is an implementation of the Bollinger Bands indicator. It uses the Bollinger Bands values to compare with previous candle's OPEN, HIGH, LOW and CLOSE values and generate entry and exit signals for trading instruments.","title":"Strategy Overview"},{"location":"strategies/bollinger_bands/#strategy-parameters","text":"The following parameters can be configured for the strategy: TIME_PERIOD : Period (number of candles) by which Bollinger Bands are calculated STANDARD_DEVIATION : Standard deviation (in percent) for upper and lower band from the signal bands","title":"Strategy Parameters"},{"location":"strategies/bollinger_bands/#decision-calculation","text":"The get_decision method calculates the Bollinger Bands values for a given instrument based on the OHLC (Open, High, Low, Close) historical data. It uses the talib.BBANDS function from the Talib library to calculate the upper and lower bands. The method compares the previous candle's open, low, and close values with the upper and lower bands to determine the entry or exit action. If the conditions for a buy or sell signal are met, the corresponding action is returned.","title":"Decision Calculation"},{"location":"strategies/common_options_strategy/","text":"1. Initial steps \u00b6 i. Create a new strategy file with a unique file name. eg: strategy_ <developer_initials> _options_ema_crossover.py !!!Note * Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name. * Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above. ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well. eg: For the above strategy name the class name would be: Strategy <developer_initials> OptionsEMACrossover(StrategyOptionsBaseV2) !!! Note * If the class name includes indicator names like EMA , SMA , and VWAP the name should be in uppercase in the class name but not in the file name . * Every strategy class is a child class of the StrategyBase . 2. Init method \u00b6 This method gets called only once when the strategy is started. i. Strategy info: In the init method add the super().__init__(*args, **kwargs) and add the below lines. VERSION = strategy_version CLIENT = client_name STRATEGY_TYPE = 'OPTIONS' self.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}') self.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}') VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on. CLIENT: Name of the client. STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy. We print this information in the next line, so whenever we run the strategy this information is displayed in the logs. We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file. eg: parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED' check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) >= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}') parameter_string: This string contains all the strategy parameters as shown above. We check if the number of parameters matches those in the strategy YAML file. Note The parameter names and the number of parameters may change for different strategies. ii. Parameter creation: Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below: eg: self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE'] self.start_time_hours = self.strategy_parameters['START_TIME_HOURS'] self.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES'] self.end_time_hours = self.strategy_parameters['END_TIME_HOURS'] self.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES'] self.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE'] self.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE'] self._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE'] self._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE'] self.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE'] self.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO'] self.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE'] self.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE'] self.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE'] self.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED'] iii. Parameter validation We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values: check_argument: Checks a single parameter passed in it. Syntax: check_argument(value to be checked, 'extern_function', validating condition or method, error_message) eg : check_argument ( self . strategy_parameters , 'extern_function' , lambda x : len ( x ) >= 11 , err_message = f 'Need 11 parameters for this strategy: {parameter_string}' ) check_argument_bulk: Checks multiple parameters passed in a list Syntax: check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message) eg : is_nonnegative_int_arg_list = [ self . start_time_hours , self . start_time_minutes , self . end_time_hours , self . end_time_minutes ] check_argument_bulk ( is_nonnegative_int_arg_list , 'extern_function' , is_nonnegative_int , 'Value should be >=0' ) is_nonnegative_int: Checks whether the value is greater than or equal to zero. is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value. is_positive_int: Checks whether the value is greater than zero and is an integer value. is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value. No of the strikes values are validated as follows: no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')] for no_of_strikes, text in no_of_strikes_list: check_argument(no_of_strikes, 'extern_function', lambda x: 0 <= x <= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50') Strike direction values are validated as follows: strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')] for strike_direction, text in strikes_direction_list: check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM') Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file. We define the below dictionary for strike_direction . strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value} Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value. self.strike_direction_ce = strike_direction_map[self._strike_direction_ce] self.strike_direction_pe = strike_direction_map[self._strike_direction_pe] iv. Start time and End time creation: Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file. try: self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes) except ValueError: self.logger.fatal('Error converting start hours and minutes... EXITING') raise SystemExit try: self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes) except ValueError: self.logger.fatal('Error converting end time hours and minutes... EXITING') raise SystemExit v. Strategy variables: We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy. eg: self.main_order = None # We save the entry order in this variable self.stoploss_order = None # We save the corresponding stoploss exit order of the entry order in this variable We initialize the variables with a None value. !!! Note There could be more strategy variables required as per the strategy requirement . 3. Initialize method \u00b6 Unlike the init method , this method gets called every day at the beginning of the day once the strategy is started. Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the self.order_tag_manager . Create a reference for OrderTagManager as shown below: self.order_tag_manager = OrderTagManager 4. OrderTagManager \u00b6 The self.order_tag_manager is used to store/remove the entry/exit orders. The self.order_tag_manager has following methods: i. add_order : Stores the order object for the given tags. eg: self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key]) Here the _order is the order object stored inside the OrderTagManager for the tags base_inst_str and entry_key . ii. get_orders : Retrieve the order(s) for the given tags. eg: self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True) Here the order object retrieved from the OrderTagManager for the tags base_inst_str, BrokerExistingOrderPositionConstants.ENTER and entry_key iii. remove_tags : Removes the tags stored in the OrderTagManager along with the orders related stored in that tag eg: self.order_tag_manager.remove_tags(tags=entry_key) Here the entry_key tag is removed from the OrderTagManager . Note When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags. iv. remove_order : Remove the order(s) from the OrderTagManager for the given tag(s). eg: self.order_tag_manager.remove_order(main_order) Here the main_order order object is removed from the OrderTagManager . Note The order object will be removed from all the tags ta v. get_internals : Returns the values i.e both the entry and exit orders stored inside the tags list. 5. Child instruments calculation \u00b6 i. Fetch the LTP of the base instrument (instrument in the YAML). ltp = self.broker.get_ltp(self.underlying_instrument) ii. Get the ATM ITM and OTM lists of the child instrument based on the LTP: self.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp) iii. Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument. child_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes) 6. Entry Methods \u00b6 i. strategy_select_instruments_for_entry: In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a get_entry_decision method that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data. When the order has to be placed we add the instrument to selectd_instruments_bucket and additional data related to the instrument that will be required while placing to the sideband_info . This information is passed to the strategy_enter_position method ii. strategy_enter_position: Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods. 7. Exit Methods \u00b6 i. strategy_select_instruments_for_exit: This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders. Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders. 8. Other common methods \u00b6 There are other methods that are used in the strategy: i. check_and_place_stoploss_order: This method is called in the strategy_select_instruments_for_exit when our entry order is open and we want to place a stoploss exit order for the same. ii. set_all_none: This method is called in the strategy_exit_position when our entry order has exited and we want to remove the order object from the self.main_order variable. iii. options_instruments_set_up_local This method is called in the strategy_select_instruments_for_entry to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. iv. get_child_instrument_details This method is called in the strategy_select_instruments_for_entry to fetch a single child instrument based on the no of strikes and strike direction. 9. Cleanup \u00b6 i. Add comments and docstrings wherever possible to improve code readability. ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.** To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in Strategies Section","title":"Options Strategy"},{"location":"strategies/common_options_strategy/#1-initial-steps","text":"i. Create a new strategy file with a unique file name. eg: strategy_ <developer_initials> _options_ema_crossover.py !!!Note * Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name. * Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above. ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well. eg: For the above strategy name the class name would be: Strategy <developer_initials> OptionsEMACrossover(StrategyOptionsBaseV2) !!! Note * If the class name includes indicator names like EMA , SMA , and VWAP the name should be in uppercase in the class name but not in the file name . * Every strategy class is a child class of the StrategyBase .","title":"1. Initial steps"},{"location":"strategies/common_options_strategy/#2-init-method","text":"This method gets called only once when the strategy is started. i. Strategy info: In the init method add the super().__init__(*args, **kwargs) and add the below lines. VERSION = strategy_version CLIENT = client_name STRATEGY_TYPE = 'OPTIONS' self.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}') self.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}') VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on. CLIENT: Name of the client. STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy. We print this information in the next line, so whenever we run the strategy this information is displayed in the logs. We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file. eg: parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED' check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) >= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}') parameter_string: This string contains all the strategy parameters as shown above. We check if the number of parameters matches those in the strategy YAML file. Note The parameter names and the number of parameters may change for different strategies. ii. Parameter creation: Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below: eg: self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE'] self.start_time_hours = self.strategy_parameters['START_TIME_HOURS'] self.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES'] self.end_time_hours = self.strategy_parameters['END_TIME_HOURS'] self.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES'] self.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE'] self.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE'] self._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE'] self._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE'] self.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE'] self.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO'] self.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE'] self.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE'] self.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE'] self.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED'] iii. Parameter validation We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values: check_argument: Checks a single parameter passed in it. Syntax: check_argument(value to be checked, 'extern_function', validating condition or method, error_message) eg : check_argument ( self . strategy_parameters , 'extern_function' , lambda x : len ( x ) >= 11 , err_message = f 'Need 11 parameters for this strategy: {parameter_string}' ) check_argument_bulk: Checks multiple parameters passed in a list Syntax: check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message) eg : is_nonnegative_int_arg_list = [ self . start_time_hours , self . start_time_minutes , self . end_time_hours , self . end_time_minutes ] check_argument_bulk ( is_nonnegative_int_arg_list , 'extern_function' , is_nonnegative_int , 'Value should be >=0' ) is_nonnegative_int: Checks whether the value is greater than or equal to zero. is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value. is_positive_int: Checks whether the value is greater than zero and is an integer value. is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value. No of the strikes values are validated as follows: no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')] for no_of_strikes, text in no_of_strikes_list: check_argument(no_of_strikes, 'extern_function', lambda x: 0 <= x <= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50') Strike direction values are validated as follows: strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')] for strike_direction, text in strikes_direction_list: check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM') Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file. We define the below dictionary for strike_direction . strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value} Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value. self.strike_direction_ce = strike_direction_map[self._strike_direction_ce] self.strike_direction_pe = strike_direction_map[self._strike_direction_pe] iv. Start time and End time creation: Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file. try: self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes) except ValueError: self.logger.fatal('Error converting start hours and minutes... EXITING') raise SystemExit try: self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes) except ValueError: self.logger.fatal('Error converting end time hours and minutes... EXITING') raise SystemExit v. Strategy variables: We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy. eg: self.main_order = None # We save the entry order in this variable self.stoploss_order = None # We save the corresponding stoploss exit order of the entry order in this variable We initialize the variables with a None value. !!! Note There could be more strategy variables required as per the strategy requirement .","title":"2. Init method"},{"location":"strategies/common_options_strategy/#3-initialize-method","text":"Unlike the init method , this method gets called every day at the beginning of the day once the strategy is started. Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the self.order_tag_manager . Create a reference for OrderTagManager as shown below: self.order_tag_manager = OrderTagManager","title":"3. Initialize method"},{"location":"strategies/common_options_strategy/#4-ordertagmanager","text":"The self.order_tag_manager is used to store/remove the entry/exit orders. The self.order_tag_manager has following methods: i. add_order : Stores the order object for the given tags. eg: self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key]) Here the _order is the order object stored inside the OrderTagManager for the tags base_inst_str and entry_key . ii. get_orders : Retrieve the order(s) for the given tags. eg: self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True) Here the order object retrieved from the OrderTagManager for the tags base_inst_str, BrokerExistingOrderPositionConstants.ENTER and entry_key iii. remove_tags : Removes the tags stored in the OrderTagManager along with the orders related stored in that tag eg: self.order_tag_manager.remove_tags(tags=entry_key) Here the entry_key tag is removed from the OrderTagManager . Note When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags. iv. remove_order : Remove the order(s) from the OrderTagManager for the given tag(s). eg: self.order_tag_manager.remove_order(main_order) Here the main_order order object is removed from the OrderTagManager . Note The order object will be removed from all the tags ta v. get_internals : Returns the values i.e both the entry and exit orders stored inside the tags list.","title":"4. OrderTagManager"},{"location":"strategies/common_options_strategy/#5-child-instruments-calculation","text":"i. Fetch the LTP of the base instrument (instrument in the YAML). ltp = self.broker.get_ltp(self.underlying_instrument) ii. Get the ATM ITM and OTM lists of the child instrument based on the LTP: self.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp) iii. Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument. child_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)","title":"5. Child instruments calculation"},{"location":"strategies/common_options_strategy/#6-entry-methods","text":"i. strategy_select_instruments_for_entry: In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a get_entry_decision method that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data. When the order has to be placed we add the instrument to selectd_instruments_bucket and additional data related to the instrument that will be required while placing to the sideband_info . This information is passed to the strategy_enter_position method ii. strategy_enter_position: Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.","title":"6. Entry Methods"},{"location":"strategies/common_options_strategy/#7-exit-methods","text":"i. strategy_select_instruments_for_exit: This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders. Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.","title":"7. Exit Methods"},{"location":"strategies/common_options_strategy/#8-other-common-methods","text":"There are other methods that are used in the strategy: i. check_and_place_stoploss_order: This method is called in the strategy_select_instruments_for_exit when our entry order is open and we want to place a stoploss exit order for the same. ii. set_all_none: This method is called in the strategy_exit_position when our entry order has exited and we want to remove the order object from the self.main_order variable. iii. options_instruments_set_up_local This method is called in the strategy_select_instruments_for_entry to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. iv. get_child_instrument_details This method is called in the strategy_select_instruments_for_entry to fetch a single child instrument based on the no of strikes and strike direction.","title":"8. Other common methods"},{"location":"strategies/common_options_strategy/#9-cleanup","text":"i. Add comments and docstrings wherever possible to improve code readability. ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.** To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in Strategies Section","title":"9. Cleanup"},{"location":"strategies/common_regular_strategy/","text":"1. Initial steps \u00b6 i. Create a new strategy file with a unique file name. eg: strategy_ <developer_initials> _futures_ema_crossover.py Note Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name. Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above. ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well. eg: For the above strategy name the class name would be: Strategy <developer_initials> FuturesEMACrossover(StrategyBase) Note If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name. Every strategy is a child class of the StrategyBase class. 2. Init method \u00b6 This method gets called only once when the strategy is started. i. Strategy info: In the init method add the super().__init__(*args, **kwargs) and add the below lines. VERSION = strategy_version CLIENT = client_name STRATEGY_TYPE = 'FUTURES' self.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}') self.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}') VERSION : This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on. CLIENT : Name of the client. STRATEGY_TYPE : Whether the strategy is FUTURES, REGULAR, or OPTIONS. We print this information in the next line, so whenever we run the strategy this information is displayed in the logs. We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file. eg: parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\ '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED' check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) >= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}') parameter_string: This string contains all the strategy parameters as shown above. We check if the number of parameters matches those in the strategy YAML file. Note The parameter names and the number of parameters may be different for different strategies. ii. Parameter creation: Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below: eg: self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE'] self.start_time_hours = self.strategy_parameters['START_TIME_HOURS'] self.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES'] self.end_time_hours = self.strategy_parameters['END_TIME_HOURS'] self.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES'] self.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE'] self.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO'] self.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE'] self.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE'] self.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE'] self.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED'] iii. Parameter validation We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values: check_argument: Checks a single parameter passed in it. Syntax: check_argument(value to be checked, 'extern_function', validating condition or method, error_message) eg : check_argument ( self . strategy_parameters , 'extern_function' , lambda x : len ( x ) >= 11 , err_message = f 'Need 11 parameters for this strategy: {parameter_string}' ) check_argument_bulk: Checks multiple parameters passed in a list Syntax: check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message) eg : is_nonnegative_int_arg_list = [ self . start_time_hours , self . start_time_minutes , self . end_time_hours , self . end_time_minutes ] check_argument_bulk ( is_nonnegative_int_arg_list , 'extern_function' , is_nonnegative_int , 'Value should be >=0' ) is_nonnegative_int: Checks whether the value is greater than or equal to zero. is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value. is_positive_int: Checks whether the value is greater than zero and is an integer value. is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value. iv. Start time and End time creation: Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file. try: self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes) except ValueError: self.logger.fatal('Error converting start hours and minutes... EXITING') raise SystemExit try: self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes) except ValueError: self.logger.fatal('Error converting end time hours and minutes... EXITING') raise SystemExit v. Strategy variables: We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy. eg: self.order_tag_manager = None We initialize the variables with a None value. Note There could be more strategy variables required as per the strategy requirement. 3. Initialize method \u00b6 Unlike the init method , this method gets called every day at the beginning of the day once the strategy is started. Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the self.order_tag_manager . Create a reference for OrderTagManager as shown below: self.order_tag_manager = OrderTagManager 4. OrderTagManager \u00b6 The self.order_tag_manager is used to store/remove the entry/exit orders. The self.order_tag_manager has following methods: i. add_order : Stores the order object for the given tags. eg: self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key]) Here the _order is the order object stored inside the OrderTagManager for the tags base_inst_str and entry_key . ii. get_orders : Retrieve the order(s) for the given tags. eg: self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True) Here the order object retrieved from the OrderTagManager for the tags base_inst_str, BrokerExistingOrderPositionConstants.ENTER and entry_key iii. remove_tags : Removes the tags stored in the OrderTagManager along with the orders related stored in that tag eg: self.order_tag_manager.remove_tags(tags=entry_key) Here the entry_key tag is removed from the OrderTagManager . Note When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags. iv. remove_order : Remove the order(s) from the OrderTagManager for the given tag(s). eg: self.order_tag_manager.remove_order(main_order) Here the main_order order object is removed from the OrderTagManager . Note The order object will be removed from all the tags ta v. get_internals : Returns the values i.e both the entry and exit orders stored inside the tags list. 5. Entry Methods \u00b6 i. strategy_select_instruments_for_entry: In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an get_entry_decision method that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data. When the order has to be placed we add the instrument to selected_instruments_bucket and additional data related to the instrument that will be required while placing to the sideband_info . This information is passed to the strategy_enter_position method ii. strategy_enter_position: Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods. 6. Exit Methods \u00b6 i. strategy_select_instruments_for_exit: This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders. Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders. 7. Other common methods \u00b6 There are other methods that are used in the strategy: i. check_and_place_stoploss_order: This method is called in the strategy_select_instruments_for_exit when our entry order is open and we want to place a stoploss exit order for the same. ii. set_all_none: This method is called in the strategy_exit_position when our entry order has exited and we want to remove the order object from the self.main_order variable. 8. Cleanup \u00b6 i. Add comments and docstrings wherever possible to improve code readability. ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code. To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in Strategies Section","title":"Regular Strategy"},{"location":"strategies/common_regular_strategy/#1-initial-steps","text":"i. Create a new strategy file with a unique file name. eg: strategy_ <developer_initials> _futures_ema_crossover.py Note Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name. Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above. ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well. eg: For the above strategy name the class name would be: Strategy <developer_initials> FuturesEMACrossover(StrategyBase) Note If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name. Every strategy is a child class of the StrategyBase class.","title":"1. Initial steps"},{"location":"strategies/common_regular_strategy/#2-init-method","text":"This method gets called only once when the strategy is started. i. Strategy info: In the init method add the super().__init__(*args, **kwargs) and add the below lines. VERSION = strategy_version CLIENT = client_name STRATEGY_TYPE = 'FUTURES' self.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}') self.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}') VERSION : This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on. CLIENT : Name of the client. STRATEGY_TYPE : Whether the strategy is FUTURES, REGULAR, or OPTIONS. We print this information in the next line, so whenever we run the strategy this information is displayed in the logs. We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file. eg: parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\ '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED' check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) >= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}') parameter_string: This string contains all the strategy parameters as shown above. We check if the number of parameters matches those in the strategy YAML file. Note The parameter names and the number of parameters may be different for different strategies. ii. Parameter creation: Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below: eg: self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE'] self.start_time_hours = self.strategy_parameters['START_TIME_HOURS'] self.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES'] self.end_time_hours = self.strategy_parameters['END_TIME_HOURS'] self.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES'] self.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE'] self.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO'] self.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE'] self.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE'] self.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE'] self.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED'] iii. Parameter validation We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values: check_argument: Checks a single parameter passed in it. Syntax: check_argument(value to be checked, 'extern_function', validating condition or method, error_message) eg : check_argument ( self . strategy_parameters , 'extern_function' , lambda x : len ( x ) >= 11 , err_message = f 'Need 11 parameters for this strategy: {parameter_string}' ) check_argument_bulk: Checks multiple parameters passed in a list Syntax: check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message) eg : is_nonnegative_int_arg_list = [ self . start_time_hours , self . start_time_minutes , self . end_time_hours , self . end_time_minutes ] check_argument_bulk ( is_nonnegative_int_arg_list , 'extern_function' , is_nonnegative_int , 'Value should be >=0' ) is_nonnegative_int: Checks whether the value is greater than or equal to zero. is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value. is_positive_int: Checks whether the value is greater than zero and is an integer value. is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value. iv. Start time and End time creation: Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file. try: self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes) except ValueError: self.logger.fatal('Error converting start hours and minutes... EXITING') raise SystemExit try: self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes) except ValueError: self.logger.fatal('Error converting end time hours and minutes... EXITING') raise SystemExit v. Strategy variables: We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy. eg: self.order_tag_manager = None We initialize the variables with a None value. Note There could be more strategy variables required as per the strategy requirement.","title":"2. Init method"},{"location":"strategies/common_regular_strategy/#3-initialize-method","text":"Unlike the init method , this method gets called every day at the beginning of the day once the strategy is started. Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the self.order_tag_manager . Create a reference for OrderTagManager as shown below: self.order_tag_manager = OrderTagManager","title":"3. Initialize method"},{"location":"strategies/common_regular_strategy/#4-ordertagmanager","text":"The self.order_tag_manager is used to store/remove the entry/exit orders. The self.order_tag_manager has following methods: i. add_order : Stores the order object for the given tags. eg: self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key]) Here the _order is the order object stored inside the OrderTagManager for the tags base_inst_str and entry_key . ii. get_orders : Retrieve the order(s) for the given tags. eg: self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True) Here the order object retrieved from the OrderTagManager for the tags base_inst_str, BrokerExistingOrderPositionConstants.ENTER and entry_key iii. remove_tags : Removes the tags stored in the OrderTagManager along with the orders related stored in that tag eg: self.order_tag_manager.remove_tags(tags=entry_key) Here the entry_key tag is removed from the OrderTagManager . Note When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags. iv. remove_order : Remove the order(s) from the OrderTagManager for the given tag(s). eg: self.order_tag_manager.remove_order(main_order) Here the main_order order object is removed from the OrderTagManager . Note The order object will be removed from all the tags ta v. get_internals : Returns the values i.e both the entry and exit orders stored inside the tags list.","title":"4. OrderTagManager"},{"location":"strategies/common_regular_strategy/#5-entry-methods","text":"i. strategy_select_instruments_for_entry: In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an get_entry_decision method that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data. When the order has to be placed we add the instrument to selected_instruments_bucket and additional data related to the instrument that will be required while placing to the sideband_info . This information is passed to the strategy_enter_position method ii. strategy_enter_position: Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.","title":"5. Entry Methods"},{"location":"strategies/common_regular_strategy/#6-exit-methods","text":"i. strategy_select_instruments_for_exit: This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders. Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.","title":"6. Exit Methods"},{"location":"strategies/common_regular_strategy/#7-other-common-methods","text":"There are other methods that are used in the strategy: i. check_and_place_stoploss_order: This method is called in the strategy_select_instruments_for_exit when our entry order is open and we want to place a stoploss exit order for the same. ii. set_all_none: This method is called in the strategy_exit_position when our entry order has exited and we want to remove the order object from the self.main_order variable.","title":"7. Other common methods"},{"location":"strategies/common_regular_strategy/#8-cleanup","text":"i. Add comments and docstrings wherever possible to improve code readability. ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code. To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in Strategies Section","title":"8. Cleanup"},{"location":"strategies/ema_crossover/","text":"EMA Regular Order Strategy \u00b6 This is a trading strategy called \"EMA Regular Order Strategy v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover. EMA indicator \u00b6 Exponential Moving Averages (EMAs) are a popular technical analysis tool used in the stock market. They are similar to Simple Moving Averages (SMAs), but they place greater emphasis on recent price data. Here's a summary of Exponential Moving Averages: An Exponential Moving Average is a type of moving average that assigns more weight to recent prices, making it more responsive to current market conditions. Unlike the SMA, which gives equal weight to all data points, the EMA assigns exponentially decreasing weights to older data points. The formula for calculating an EMA involves using a smoothing factor or multiplier that determines the weight given to the previous EMA value and the current price. The most common period used for EMAs is 12 and 26 days, representing short-term and long-term trends, respectively. EMAs are commonly used to identify trend direction, support and resistance levels, and potential entry or exit points. When the price crosses above the EMA, it may signal a bullish trend, while a cross below the EMA may suggest a bearish trend. The EMA is more responsive to price changes compared to the SMA, making it useful for short-term trading strategies. EMAs are often used in conjunction with other technical indicators, such as the Moving Average Convergence Divergence (MACD), to generate trading signals. Traders and investors use Exponential Moving Averages to smooth out price fluctuations, identify trend reversals, and determine potential support and resistance levels. They provide a visual representation of the average price over a specific period, with greater weight given to recent prices. Strategy Overview \u00b6 This strategy, called EMA Regular Order Strategy v2, implements a crossover strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the crossover of two EMAs. Strategy Parameters \u00b6 The following parameters can be configured for the strategy: TIMEPERIOD1 : Period (number of candles) by which EMA-1 is calculated TIMEPERIOD2 : Period (number of candles) by which EMA-2 is calculated Crossover Calculation \u00b6 The get_crossover_value method calculates the crossover value based on the two EMAs of the closing prices. It uses the talib.EMA function from the Talib library to calculate the EMAs. The method then determines the crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).","title":"EMA Crossover"},{"location":"strategies/ema_crossover/#ema-regular-order-strategy","text":"This is a trading strategy called \"EMA Regular Order Strategy v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover.","title":"EMA Regular Order Strategy"},{"location":"strategies/ema_crossover/#ema-indicator","text":"Exponential Moving Averages (EMAs) are a popular technical analysis tool used in the stock market. They are similar to Simple Moving Averages (SMAs), but they place greater emphasis on recent price data. Here's a summary of Exponential Moving Averages: An Exponential Moving Average is a type of moving average that assigns more weight to recent prices, making it more responsive to current market conditions. Unlike the SMA, which gives equal weight to all data points, the EMA assigns exponentially decreasing weights to older data points. The formula for calculating an EMA involves using a smoothing factor or multiplier that determines the weight given to the previous EMA value and the current price. The most common period used for EMAs is 12 and 26 days, representing short-term and long-term trends, respectively. EMAs are commonly used to identify trend direction, support and resistance levels, and potential entry or exit points. When the price crosses above the EMA, it may signal a bullish trend, while a cross below the EMA may suggest a bearish trend. The EMA is more responsive to price changes compared to the SMA, making it useful for short-term trading strategies. EMAs are often used in conjunction with other technical indicators, such as the Moving Average Convergence Divergence (MACD), to generate trading signals. Traders and investors use Exponential Moving Averages to smooth out price fluctuations, identify trend reversals, and determine potential support and resistance levels. They provide a visual representation of the average price over a specific period, with greater weight given to recent prices.","title":"EMA indicator"},{"location":"strategies/ema_crossover/#strategy-overview","text":"This strategy, called EMA Regular Order Strategy v2, implements a crossover strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the crossover of two EMAs.","title":"Strategy Overview"},{"location":"strategies/ema_crossover/#strategy-parameters","text":"The following parameters can be configured for the strategy: TIMEPERIOD1 : Period (number of candles) by which EMA-1 is calculated TIMEPERIOD2 : Period (number of candles) by which EMA-2 is calculated","title":"Strategy Parameters"},{"location":"strategies/ema_crossover/#crossover-calculation","text":"The get_crossover_value method calculates the crossover value based on the two EMAs of the closing prices. It uses the talib.EMA function from the Talib library to calculate the EMAs. The method then determines the crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).","title":"Crossover Calculation"},{"location":"strategies/inverse_ema_scalping/","text":"Inverse EMA Scalping Regular Order Strategy \u00b6 This is a trading strategy called \"Inverse EMA Scalping Regular Order Strategy v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover. What is Inverse EMA \u00b6 Inverse EMA, also known as Reverse Exponential Moving Average (REMA), is a variation of the Exponential Moving Average (EMA) in the stock market. While the EMA gives more weight to recent price data, the Inverse EMA assigns more weight to older data points. Here's a summary of Inverse EMA: Inverse EMA is calculated by applying the EMA formula in reverse, giving greater weight to older data points and less weight to recent prices. Instead of smoothing out price fluctuations like the EMA, the Inverse EMA amplifies them, making it more responsive to historical data. The formula for calculating Inverse EMA is similar to the EMA, but it uses a different smoothing factor or multiplier that assigns higher weight to older data points. The Inverse EMA is primarily used to identify historical patterns and potential turning points in the market. When the price crosses above the Inverse EMA, it may suggest a potential reversal from a downtrend to an uptrend, and vice versa when the price crosses below the Inverse EMA. Inverse EMA is not as widely used as the EMA or other moving averages, and its applications may vary among traders and analysts. Inverse EMA is a less commonly used variation of the Exponential Moving Average. While the EMA is designed to provide a smoothed average of recent prices, the Inverse EMA emphasizes historical data, potentially highlighting significant turning points in the market. Traders and analysts who utilize the Inverse EMA may incorporate it into their technical analysis toolkit to complement other indicators and gain insights into price reversals and historical patterns. Strategy Overview \u00b6 This strategy implements a scalping strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the inverse crossover of two EMAs. Strategy Parameters \u00b6 The following parameters can be configured for the strategy: LARGER_TIME_PERIOD : Period (number of candles) by which large period EMA is calculated SMALLER_TIME_PERIOD : Period (number of candles) by which short period EMA is calculated Crossover Calculation \u00b6 The get_crossover_value method calculates the crossover value based on the inverse crossover of the two EMAs of the closing prices. It uses the talib.EMA function from the Talib library to calculate the EMAs. The method then determines the inverse crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).","title":"Inverse EMA Scalping"},{"location":"strategies/inverse_ema_scalping/#inverse-ema-scalping-regular-order-strategy","text":"This is a trading strategy called \"Inverse EMA Scalping Regular Order Strategy v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover.","title":"Inverse EMA Scalping Regular Order Strategy"},{"location":"strategies/inverse_ema_scalping/#what-is-inverse-ema","text":"Inverse EMA, also known as Reverse Exponential Moving Average (REMA), is a variation of the Exponential Moving Average (EMA) in the stock market. While the EMA gives more weight to recent price data, the Inverse EMA assigns more weight to older data points. Here's a summary of Inverse EMA: Inverse EMA is calculated by applying the EMA formula in reverse, giving greater weight to older data points and less weight to recent prices. Instead of smoothing out price fluctuations like the EMA, the Inverse EMA amplifies them, making it more responsive to historical data. The formula for calculating Inverse EMA is similar to the EMA, but it uses a different smoothing factor or multiplier that assigns higher weight to older data points. The Inverse EMA is primarily used to identify historical patterns and potential turning points in the market. When the price crosses above the Inverse EMA, it may suggest a potential reversal from a downtrend to an uptrend, and vice versa when the price crosses below the Inverse EMA. Inverse EMA is not as widely used as the EMA or other moving averages, and its applications may vary among traders and analysts. Inverse EMA is a less commonly used variation of the Exponential Moving Average. While the EMA is designed to provide a smoothed average of recent prices, the Inverse EMA emphasizes historical data, potentially highlighting significant turning points in the market. Traders and analysts who utilize the Inverse EMA may incorporate it into their technical analysis toolkit to complement other indicators and gain insights into price reversals and historical patterns.","title":"What is Inverse EMA"},{"location":"strategies/inverse_ema_scalping/#strategy-overview","text":"This strategy implements a scalping strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the inverse crossover of two EMAs.","title":"Strategy Overview"},{"location":"strategies/inverse_ema_scalping/#strategy-parameters","text":"The following parameters can be configured for the strategy: LARGER_TIME_PERIOD : Period (number of candles) by which large period EMA is calculated SMALLER_TIME_PERIOD : Period (number of candles) by which short period EMA is calculated","title":"Strategy Parameters"},{"location":"strategies/inverse_ema_scalping/#crossover-calculation","text":"The get_crossover_value method calculates the crossover value based on the inverse crossover of the two EMAs of the closing prices. It uses the talib.EMA function from the Talib library to calculate the EMAs. The method then determines the inverse crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).","title":"Crossover Calculation"},{"location":"strategies/options_bear_call_ladder/","text":"StrategyOptionsBearCallLadder \u00b6 This class implements the Options Bear Call Ladder strategy. Bear Call Ladder \u00b6 In the stock market, an options bear call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bearish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions. To create a bear call ladder, an investor typically does the following: Sells a lower strike call option. Buys two higher strike call options. Sells a final even higher strike call option. The bear call ladder aims to generate a limited profit if the price of the underlying asset remains below the middle strike price at expiration. The strategy benefits from time decay and a moderate decrease in the price of the underlying asset. The maximum profit potential of the bear call ladder is achieved when the price of the underlying asset is below the middle strike price at expiration. If the price declines further, the profit potential remains limited. However, if the price rises above the higher strike price, the strategy can result in losses. The key feature of the bear call ladder is the combination of short call options, which generate premium income, and long call options, which provide protection against unlimited losses in case the price of the underlying asset rises sharply. Traders implementing the bear call ladder strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market. Please be aware that options trading can be complex and involves significant risks. It's always recommended to consult with a qualified financial advisor or broker before engaging in options trading activities. Parameters \u00b6 LEG_ONE_TRANSACTION_TYPE (int, default: 1): Transaction type for leg one. BUY: 1 | SELL: 2. LEG_ONE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg one. CE: 1 | PE: 2. LEG_ONE_STRIKE_DIRECTION (int, default: 1): Strike direction for leg one. ITM: 0 | ATM: 1 | OTM: 2. LEG_ONE_NUMBER_OF_STRIKES (int, default: 0): Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE (int, default: 1): Transaction type for leg two. BUY: 1 | SELL: 2. LEG_TWO_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg two. CE: 1 | PE: 2. LEG_TWO_STRIKE_DIRECTION (int, default: 2): Strike direction for leg two. ITM: 0 | ATM: 1 | OTM: 2. LEG_TWO_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg two. LEG_THREE_TRANSACTION_TYPE (int, default: 2): Transaction type for leg three. BUY: 1 | SELL: 2. LEG_THREE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg three. CE: 1 | PE: 2. LEG_THREE_STRIKE_DIRECTION (int, default: 0): Strike direction for leg three. ITM: 0 | ATM: 1 | OTM: 2. LEG_THREE_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg three.","title":"Options Bear Call Ladder"},{"location":"strategies/options_bear_call_ladder/#strategyoptionsbearcallladder","text":"This class implements the Options Bear Call Ladder strategy.","title":"StrategyOptionsBearCallLadder"},{"location":"strategies/options_bear_call_ladder/#bear-call-ladder","text":"In the stock market, an options bear call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bearish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions. To create a bear call ladder, an investor typically does the following: Sells a lower strike call option. Buys two higher strike call options. Sells a final even higher strike call option. The bear call ladder aims to generate a limited profit if the price of the underlying asset remains below the middle strike price at expiration. The strategy benefits from time decay and a moderate decrease in the price of the underlying asset. The maximum profit potential of the bear call ladder is achieved when the price of the underlying asset is below the middle strike price at expiration. If the price declines further, the profit potential remains limited. However, if the price rises above the higher strike price, the strategy can result in losses. The key feature of the bear call ladder is the combination of short call options, which generate premium income, and long call options, which provide protection against unlimited losses in case the price of the underlying asset rises sharply. Traders implementing the bear call ladder strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market. Please be aware that options trading can be complex and involves significant risks. It's always recommended to consult with a qualified financial advisor or broker before engaging in options trading activities.","title":"Bear Call Ladder"},{"location":"strategies/options_bear_call_ladder/#parameters","text":"LEG_ONE_TRANSACTION_TYPE (int, default: 1): Transaction type for leg one. BUY: 1 | SELL: 2. LEG_ONE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg one. CE: 1 | PE: 2. LEG_ONE_STRIKE_DIRECTION (int, default: 1): Strike direction for leg one. ITM: 0 | ATM: 1 | OTM: 2. LEG_ONE_NUMBER_OF_STRIKES (int, default: 0): Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE (int, default: 1): Transaction type for leg two. BUY: 1 | SELL: 2. LEG_TWO_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg two. CE: 1 | PE: 2. LEG_TWO_STRIKE_DIRECTION (int, default: 2): Strike direction for leg two. ITM: 0 | ATM: 1 | OTM: 2. LEG_TWO_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg two. LEG_THREE_TRANSACTION_TYPE (int, default: 2): Transaction type for leg three. BUY: 1 | SELL: 2. LEG_THREE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg three. CE: 1 | PE: 2. LEG_THREE_STRIKE_DIRECTION (int, default: 0): Strike direction for leg three. ITM: 0 | ATM: 1 | OTM: 2. LEG_THREE_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg three.","title":"Parameters"},{"location":"strategies/options_bear_put_ladder/","text":"Options Bear Put Ladder Template v2 \u00b6 Description \u00b6 This is a template for the Options Bear Put Ladder strategy. The strategy involves the combination of buying and selling put options to profit from a downward price movement in the underlying asset. It utilizes multiple legs with different strike prices and transaction types to create a ladder-like structure. Bear Put Ladder \u00b6 In the stock market, an options bull put ladder is a strategy that involves buying and selling put options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short put positions. To create a bull put ladder, an investor typically does the following: Sells a higher strike put option. Buys two lower strike put options. Sells a final even lower strike put option. The key feature of the bull put ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay. The profit potential of the bull put ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited. On the other hand, if the price of the underlying asset remains above the higher strike price or increases, the strategy can result in losses. The maximum loss occurs if the price rises above the higher strike price. The bull put ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market. Parameters \u00b6 LEG_ONE_TRANSACTION_TYPE (int, default: 1): Transaction type for leg one. BUY: 1 | SELL: 2. LEG_ONE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg one. CE: 1 | PE: 2. LEG_ONE_STRIKE_DIRECTION (int, default: 1): Strike direction for leg one. ITM: 0 | ATM: 1 | OTM: 2. LEG_ONE_NUMBER_OF_STRIKES (int, default: 0): Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE (int, default: 1): Transaction type for leg two. BUY: 1 | SELL: 2. LEG_TWO_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg two. CE: 1 | PE: 2. LEG_TWO_STRIKE_DIRECTION (int, default: 2): Strike direction for leg two. ITM: 0 | ATM: 1 | OTM: 2. LEG_TWO_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg two. LEG_THREE_TRANSACTION_TYPE (int, default: 2): Transaction type for leg three. BUY: 1 | SELL: 2. LEG_THREE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg three. CE: 1 | PE: 2. LEG_THREE_STRIKE_DIRECTION (int, default: 0): Strike direction for leg three. ITM: 0 | ATM: 1 | OTM: 2. LEG_THREE_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg three.","title":"Options Bear Put Ladder"},{"location":"strategies/options_bear_put_ladder/#options-bear-put-ladder-template-v2","text":"","title":"Options Bear Put Ladder Template v2"},{"location":"strategies/options_bear_put_ladder/#description","text":"This is a template for the Options Bear Put Ladder strategy. The strategy involves the combination of buying and selling put options to profit from a downward price movement in the underlying asset. It utilizes multiple legs with different strike prices and transaction types to create a ladder-like structure.","title":"Description"},{"location":"strategies/options_bear_put_ladder/#bear-put-ladder","text":"In the stock market, an options bull put ladder is a strategy that involves buying and selling put options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short put positions. To create a bull put ladder, an investor typically does the following: Sells a higher strike put option. Buys two lower strike put options. Sells a final even lower strike put option. The key feature of the bull put ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay. The profit potential of the bull put ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited. On the other hand, if the price of the underlying asset remains above the higher strike price or increases, the strategy can result in losses. The maximum loss occurs if the price rises above the higher strike price. The bull put ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.","title":"Bear Put Ladder"},{"location":"strategies/options_bear_put_ladder/#parameters","text":"LEG_ONE_TRANSACTION_TYPE (int, default: 1): Transaction type for leg one. BUY: 1 | SELL: 2. LEG_ONE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg one. CE: 1 | PE: 2. LEG_ONE_STRIKE_DIRECTION (int, default: 1): Strike direction for leg one. ITM: 0 | ATM: 1 | OTM: 2. LEG_ONE_NUMBER_OF_STRIKES (int, default: 0): Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE (int, default: 1): Transaction type for leg two. BUY: 1 | SELL: 2. LEG_TWO_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg two. CE: 1 | PE: 2. LEG_TWO_STRIKE_DIRECTION (int, default: 2): Strike direction for leg two. ITM: 0 | ATM: 1 | OTM: 2. LEG_TWO_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg two. LEG_THREE_TRANSACTION_TYPE (int, default: 2): Transaction type for leg three. BUY: 1 | SELL: 2. LEG_THREE_TRADING_SYMBOL_SUFFIX (int, default: 1): Trading symbol suffix for leg three. CE: 1 | PE: 2. LEG_THREE_STRIKE_DIRECTION (int, default: 0): Strike direction for leg three. ITM: 0 | ATM: 1 | OTM: 2. LEG_THREE_NUMBER_OF_STRIKES (int, default: 2): Number of strikes for leg three.","title":"Parameters"},{"location":"strategies/options_bull_call_ladder/","text":"Options Bull Call Ladder Template v2 \u00b6 Bull Call Ladder \u00b6 In the stock market, an options bull call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions. To create a bull call ladder, an investor typically does the following: Buys a lower strike call option. Sells two higher strike call options. Buys a final even higher strike call option. The key feature of the bull call ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay. The profit potential of the bull call ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited. On the other hand, if the price of the underlying asset remains below the lower strike price or declines, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price. The bull call ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market. Parameters \u00b6 LEG_ONE_TRANSACTION_TYPE : The transaction type for leg one (BUY: 1 | SELL: 2). LEG_ONE_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for leg one (CE: 1 | PE: 2). LEG_ONE_STRIKE_DIRECTION : The strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2). LEG_ONE_NUMBER_OF_STRIKES : The number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE : The transaction type for leg two (BUY: 1 | SELL: 2). LEG_TWO_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for leg two (CE: 1 | PE: 2). LEG_TWO_STRIKE_DIRECTION : The strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2). LEG_TWO_NUMBER_OF_STRIKES : The number of strikes for leg two. LEG_THREE_TRANSACTION_TYPE : The transaction type for leg three (BUY: 1 | SELL: 2). LEG_THREE_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for leg three (CE: 1 | PE: 2). LEG_THREE_STRIKE_DIRECTION : The strike direction for leg three (ITM: 0 | ATM: 1 | OTM: 2). LEG_THREE_NUMBER_OF_STRIKES : The number of strikes for leg three.","title":"Options Bull Call Ladder"},{"location":"strategies/options_bull_call_ladder/#options-bull-call-ladder-template-v2","text":"","title":"Options Bull Call Ladder Template v2"},{"location":"strategies/options_bull_call_ladder/#bull-call-ladder","text":"In the stock market, an options bull call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions. To create a bull call ladder, an investor typically does the following: Buys a lower strike call option. Sells two higher strike call options. Buys a final even higher strike call option. The key feature of the bull call ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay. The profit potential of the bull call ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited. On the other hand, if the price of the underlying asset remains below the lower strike price or declines, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price. The bull call ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.","title":"Bull Call Ladder"},{"location":"strategies/options_bull_call_ladder/#parameters","text":"LEG_ONE_TRANSACTION_TYPE : The transaction type for leg one (BUY: 1 | SELL: 2). LEG_ONE_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for leg one (CE: 1 | PE: 2). LEG_ONE_STRIKE_DIRECTION : The strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2). LEG_ONE_NUMBER_OF_STRIKES : The number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE : The transaction type for leg two (BUY: 1 | SELL: 2). LEG_TWO_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for leg two (CE: 1 | PE: 2). LEG_TWO_STRIKE_DIRECTION : The strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2). LEG_TWO_NUMBER_OF_STRIKES : The number of strikes for leg two. LEG_THREE_TRANSACTION_TYPE : The transaction type for leg three (BUY: 1 | SELL: 2). LEG_THREE_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for leg three (CE: 1 | PE: 2). LEG_THREE_STRIKE_DIRECTION : The strike direction for leg three (ITM: 0 | ATM: 1 | OTM: 2). LEG_THREE_NUMBER_OF_STRIKES : The number of strikes for leg three.","title":"Parameters"},{"location":"strategies/options_bull_put_ladder/","text":"Options Bull Put Ladder Template v2 \u00b6 Bull Put ladder \u00b6 In the stock market, an options bull put ladder is a strategy that involves buying and selling put options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short put positions. To create a bull put ladder, an investor typically does the following: Sells a higher strike put option. Buys two lower strike put options. Sells a final even lower strike put option. The key feature of the bull put ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay. The profit potential of the bull put ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited. On the other hand, if the price of the underlying asset remains above the higher strike price or increases, the strategy can result in losses. The maximum loss occurs if the price rises above the higher strike price. The bull put ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market. Initialization \u00b6 The __init__ method initializes the strategy and accepts parameters for configuring the strategy. The parameters are: LEG_ONE_TRANSACTION_TYPE : Transaction type for leg one (BUY: 1 | SELL: 2) LEG_ONE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg one (CE: 1 | PE: 2) LEG_ONE_STRIKE_DIRECTION : Strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2) LEG_ONE_NUMBER_OF_STRIKES : Number of strikes for leg one LEG_TWO_TRANSACTION_TYPE : Transaction type for leg two (BUY: 1 | SELL: 2) LEG_TWO_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg two (CE: 1 | PE: 2) LEG_TWO_STRIKE_DIRECTION : Strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2) LEG_TWO_NUMBER_OF_STRIKES : Number of strikes for leg two LEG_THREE_TRANSACTION_TYPE : Transaction type for leg three (BUY: 1 | SELL: 2) LEG_THREE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg three (CE: 1 | PE: 2) LEG_THREE_STRIKE_DIRECTION : Strike direction for leg three (ITM: 0 | ATM: 1 | OTM: 2) LEG_THREE_NUMBER_OF_STRIKES : Number of strikes for leg three Additional Notes \u00b6 The transaction_type_map , tradingsymbol_suffix_map , and strike_direction_map dictionaries are used for mapping transaction types, trading symbol suffixes, and strike directions, respectively. The strategy supports a single allowed expiry date, which can be modified for multiple expiry dates. The strategy uses the get_options_instrument_with_strike_direction method from the base class to fetch child instruments. The initialize method sets up the list of instruments processed for the day. The options_instruments_set_up_local method sets up the Call and Put Options instruments for a given base instrument. The strategy_select_instruments_for_entry method selects instruments for entry by setting up child instruments and appending them to the selected instruments list. The strategy_enter_position method","title":"Options Bull Put Ladder"},{"location":"strategies/options_bull_put_ladder/#options-bull-put-ladder-template-v2","text":"","title":"Options Bull Put Ladder Template v2"},{"location":"strategies/options_bull_put_ladder/#bull-put-ladder","text":"In the stock market, an options bull put ladder is a strategy that involves buying and selling put options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short put positions. To create a bull put ladder, an investor typically does the following: Sells a higher strike put option. Buys two lower strike put options. Sells a final even lower strike put option. The key feature of the bull put ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay. The profit potential of the bull put ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited. On the other hand, if the price of the underlying asset remains above the higher strike price or increases, the strategy can result in losses. The maximum loss occurs if the price rises above the higher strike price. The bull put ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.","title":"Bull Put ladder"},{"location":"strategies/options_bull_put_ladder/#initialization","text":"The __init__ method initializes the strategy and accepts parameters for configuring the strategy. The parameters are: LEG_ONE_TRANSACTION_TYPE : Transaction type for leg one (BUY: 1 | SELL: 2) LEG_ONE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg one (CE: 1 | PE: 2) LEG_ONE_STRIKE_DIRECTION : Strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2) LEG_ONE_NUMBER_OF_STRIKES : Number of strikes for leg one LEG_TWO_TRANSACTION_TYPE : Transaction type for leg two (BUY: 1 | SELL: 2) LEG_TWO_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg two (CE: 1 | PE: 2) LEG_TWO_STRIKE_DIRECTION : Strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2) LEG_TWO_NUMBER_OF_STRIKES : Number of strikes for leg two LEG_THREE_TRANSACTION_TYPE : Transaction type for leg three (BUY: 1 | SELL: 2) LEG_THREE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg three (CE: 1 | PE: 2) LEG_THREE_STRIKE_DIRECTION : Strike direction for leg three (ITM: 0 | ATM: 1 | OTM: 2) LEG_THREE_NUMBER_OF_STRIKES : Number of strikes for leg three","title":"Initialization"},{"location":"strategies/options_bull_put_ladder/#additional-notes","text":"The transaction_type_map , tradingsymbol_suffix_map , and strike_direction_map dictionaries are used for mapping transaction types, trading symbol suffixes, and strike directions, respectively. The strategy supports a single allowed expiry date, which can be modified for multiple expiry dates. The strategy uses the get_options_instrument_with_strike_direction method from the base class to fetch child instruments. The initialize method sets up the list of instruments processed for the day. The options_instruments_set_up_local method sets up the Call and Put Options instruments for a given base instrument. The strategy_select_instruments_for_entry method selects instruments for entry by setting up child instruments and appending them to the selected instruments list. The strategy_enter_position method","title":"Additional Notes"},{"location":"strategies/options_long_iron_butterfly/","text":"Options Long Iron Butterfly Template v2 \u00b6 This is a template for implementing the Options Long Iron Butterfly strategy in Python. Long Iron Butterfly \u00b6 In the stock market, an options long iron butterfly is a complex strategy that involves buying two options with the same expiration date but different strike prices. It combines elements of both a bullish and bearish strategy and is designed to profit from low volatility in the underlying asset. To create a long iron butterfly, an investor typically does the following: Buys an at-the-money (ATM) put option. Buys an ATM call option. Sells an out-of-the-money (OTM) put option with a lower strike price. Sells an OTM call option with a higher strike price. The key feature of the long iron butterfly is that the sold options (OTM put and OTM call) help offset the cost of the purchased options (ATM put and ATM call). This results in a limited-risk, limited-reward strategy. The strategy profits when the price of the underlying asset remains within a specific range, known as the \"profit zone.\" The profit zone is determined by the strike prices of the options involved in the strategy. If the price of the underlying asset is within this range at expiration, the investor can achieve the maximum profit. However, if the price of the underlying asset moves significantly beyond the profit zone, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price or rises above the higher strike price. The long iron butterfly is commonly used when traders anticipate low volatility in the underlying asset. It is a neutral strategy that seeks to benefit from the passage of time and a decrease in implied volatility. Traders implementing this strategy should carefully analyze factors such as the strike prices, premium costs, and expiration date to determine their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market. Strategy Parameters \u00b6 The strategy accepts the following parameters: LEG_ONE_TRANSACTION_TYPE : Transaction type for leg one (BUY: 1 | SELL: 2) LEG_ONE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg one (CE: 1 | PE: 2) LEG_ONE_STRIKE_DIRECTION : Strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2) LEG_ONE_NUMBER_OF_STRIKES : Number of strikes for leg one LEG_TWO_TRANSACTION_TYPE : Transaction type for leg two (BUY: 1 | SELL: 2) LEG_TWO_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg two (CE: 1 | PE: 2) LEG_TWO_STRIKE_DIRECTION : Strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2) LEG_TWO_NUMBER_OF_STRIKES : Number of strikes for leg two LEG_THREE_TRANSACTION_TYPE : Transaction type for leg three (BUY: 1 | SELL: 2) LEG_THREE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg three (CE: 1 | PE: 2) LEG_THREE_STRIKE_DIRECTION : Strike direction for leg three (ITM: 0 | ATM: 1 | OTM: 2) LEG_THREE_NUMBER_OF_STRIKES : Number of strikes for leg three LEG_FOUR_TRANSACTION_TYPE : Transaction type for leg four (BUY: 1 | SELL: 2) LEG_FOUR_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg four (CE: 1 | PE: 2) LEG_FOUR_STRIKE_DIRECTION : Strike direction for leg four (ITM: 0 | ATM: 1 | OTM: 2) LEG_FOUR_NUMBER_OF_STRIKES : Number of strikes for leg four","title":"Options Long Iron Butterfly"},{"location":"strategies/options_long_iron_butterfly/#options-long-iron-butterfly-template-v2","text":"This is a template for implementing the Options Long Iron Butterfly strategy in Python.","title":"Options Long Iron Butterfly Template v2"},{"location":"strategies/options_long_iron_butterfly/#long-iron-butterfly","text":"In the stock market, an options long iron butterfly is a complex strategy that involves buying two options with the same expiration date but different strike prices. It combines elements of both a bullish and bearish strategy and is designed to profit from low volatility in the underlying asset. To create a long iron butterfly, an investor typically does the following: Buys an at-the-money (ATM) put option. Buys an ATM call option. Sells an out-of-the-money (OTM) put option with a lower strike price. Sells an OTM call option with a higher strike price. The key feature of the long iron butterfly is that the sold options (OTM put and OTM call) help offset the cost of the purchased options (ATM put and ATM call). This results in a limited-risk, limited-reward strategy. The strategy profits when the price of the underlying asset remains within a specific range, known as the \"profit zone.\" The profit zone is determined by the strike prices of the options involved in the strategy. If the price of the underlying asset is within this range at expiration, the investor can achieve the maximum profit. However, if the price of the underlying asset moves significantly beyond the profit zone, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price or rises above the higher strike price. The long iron butterfly is commonly used when traders anticipate low volatility in the underlying asset. It is a neutral strategy that seeks to benefit from the passage of time and a decrease in implied volatility. Traders implementing this strategy should carefully analyze factors such as the strike prices, premium costs, and expiration date to determine their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.","title":"Long Iron Butterfly"},{"location":"strategies/options_long_iron_butterfly/#strategy-parameters","text":"The strategy accepts the following parameters: LEG_ONE_TRANSACTION_TYPE : Transaction type for leg one (BUY: 1 | SELL: 2) LEG_ONE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg one (CE: 1 | PE: 2) LEG_ONE_STRIKE_DIRECTION : Strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2) LEG_ONE_NUMBER_OF_STRIKES : Number of strikes for leg one LEG_TWO_TRANSACTION_TYPE : Transaction type for leg two (BUY: 1 | SELL: 2) LEG_TWO_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg two (CE: 1 | PE: 2) LEG_TWO_STRIKE_DIRECTION : Strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2) LEG_TWO_NUMBER_OF_STRIKES : Number of strikes for leg two LEG_THREE_TRANSACTION_TYPE : Transaction type for leg three (BUY: 1 | SELL: 2) LEG_THREE_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg three (CE: 1 | PE: 2) LEG_THREE_STRIKE_DIRECTION : Strike direction for leg three (ITM: 0 | ATM: 1 | OTM: 2) LEG_THREE_NUMBER_OF_STRIKES : Number of strikes for leg three LEG_FOUR_TRANSACTION_TYPE : Transaction type for leg four (BUY: 1 | SELL: 2) LEG_FOUR_TRADING_SYMBOL_SUFFIX : Trading symbol suffix for leg four (CE: 1 | PE: 2) LEG_FOUR_STRIKE_DIRECTION : Strike direction for leg four (ITM: 0 | ATM: 1 | OTM: 2) LEG_FOUR_NUMBER_OF_STRIKES : Number of strikes for leg four","title":"Strategy Parameters"},{"location":"strategies/options_straddle/","text":"Class: StrategyOptionsStraddle \u00b6 This class represents the implementation of a options straddle trading strategy. Straddle Options \u00b6 In the stock market, an options straddle is a strategy where an investor simultaneously purchases a call option and a put option with the same strike price and expiration date on a particular underlying asset, such as a stock. The purpose of this strategy is to profit from significant price movements in the underlying asset, regardless of whether the price goes up or down. By using an options straddle, the investor is essentially betting on volatility rather than the direction of the price movement. If the price of the underlying asset experiences a substantial increase or decrease, either the call or put option will generate profits, offsetting any losses from the other option. The potential for profit is highest when there is a significant price swing, while the risk is limited to the cost of purchasing the options. This strategy is often employed when traders anticipate an upcoming event or announcement that could cause significant market volatility, such as earnings reports or regulatory decisions. The goal is to take advantage of the resulting price movement, regardless of whether it is upward or downward. It's important to note that options straddles can be risky as they require significant price movements to be profitable. If the price remains relatively stable, the trader may experience losses due to the cost of purchasing the options. Therefore, careful consideration of market conditions and risk management is crucial when implementing an options straddle strategy. Parameters \u00b6 _leg_one_transaction_type : Specifies the transaction type for leg one (BUY: 1 | SELL: 2). _leg_one_tradingsymbol_suffix : Specifies the tradingsymbol suffix for leg one (CE: 1 | PE: 2). _leg_one_strike_direction : Specifies the strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2). _leg_one_number_of_strikes : Specifies the number of strikes for leg one. _leg_two_transaction_type : Specifies the transaction type for leg two (BUY: 1 | SELL: 2). _leg_two_tradingsymbol_suffix : Specifies the tradingsymbol suffix for leg two (CE: 1 | PE: 2). _leg_two_strike_direction : Specifies the strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2). _leg_two_number_of_strikes : Specifies the number of strikes for leg two.","title":"Options Straddle"},{"location":"strategies/options_straddle/#class-strategyoptionsstraddle","text":"This class represents the implementation of a options straddle trading strategy.","title":"Class: StrategyOptionsStraddle"},{"location":"strategies/options_straddle/#straddle-options","text":"In the stock market, an options straddle is a strategy where an investor simultaneously purchases a call option and a put option with the same strike price and expiration date on a particular underlying asset, such as a stock. The purpose of this strategy is to profit from significant price movements in the underlying asset, regardless of whether the price goes up or down. By using an options straddle, the investor is essentially betting on volatility rather than the direction of the price movement. If the price of the underlying asset experiences a substantial increase or decrease, either the call or put option will generate profits, offsetting any losses from the other option. The potential for profit is highest when there is a significant price swing, while the risk is limited to the cost of purchasing the options. This strategy is often employed when traders anticipate an upcoming event or announcement that could cause significant market volatility, such as earnings reports or regulatory decisions. The goal is to take advantage of the resulting price movement, regardless of whether it is upward or downward. It's important to note that options straddles can be risky as they require significant price movements to be profitable. If the price remains relatively stable, the trader may experience losses due to the cost of purchasing the options. Therefore, careful consideration of market conditions and risk management is crucial when implementing an options straddle strategy.","title":"Straddle Options"},{"location":"strategies/options_straddle/#parameters","text":"_leg_one_transaction_type : Specifies the transaction type for leg one (BUY: 1 | SELL: 2). _leg_one_tradingsymbol_suffix : Specifies the tradingsymbol suffix for leg one (CE: 1 | PE: 2). _leg_one_strike_direction : Specifies the strike direction for leg one (ITM: 0 | ATM: 1 | OTM: 2). _leg_one_number_of_strikes : Specifies the number of strikes for leg one. _leg_two_transaction_type : Specifies the transaction type for leg two (BUY: 1 | SELL: 2). _leg_two_tradingsymbol_suffix : Specifies the tradingsymbol suffix for leg two (CE: 1 | PE: 2). _leg_two_strike_direction : Specifies the strike direction for leg two (ITM: 0 | ATM: 1 | OTM: 2). _leg_two_number_of_strikes : Specifies the number of strikes for leg two.","title":"Parameters"},{"location":"strategies/options_strangle/","text":"Options Strangle Template v2 \u00b6 The StrategyOptionsStrangle class is a strategy template for trading options strangles. It is derived from the StrategyOptionsBaseV2 class. Strangle Options \u00b6 In the stock market, an options strangle is a strategy where an investor simultaneously buys or sells a call option and a put option on the same underlying asset but with different strike prices and the same expiration date. The purpose of this strategy is to profit from significant price volatility in the underlying asset. Unlike an options straddle, which involves purchasing options at the same strike price, an options strangle involves selecting different strike prices. Typically, the investor buys an out-of-the-money call option (with a strike price above the current market price) and an out-of-the-money put option (with a strike price below the current market price). The strategy aims to benefit from a significant price movement in either direction. If the price of the underlying asset moves significantly upwards, the call option can generate profits. Conversely, if the price moves significantly downwards, the put option can generate profits. The investor is essentially betting on increased price volatility rather than predicting the direction of the price movement. Options strangles are commonly used when traders anticipate a substantial price movement but are unsure about the direction. This strategy allows for potential profits in either an upward or downward market scenario. However, it's important to note that options strangles can involve higher risks, as the underlying asset's price must move significantly to offset the cost of purchasing both options. Traders employing options strangles should carefully consider factors such as the expected price volatility, the expiration date, and the costs associated with purchasing the options. Implementing risk management techniques and monitoring market conditions are essential when utilizing an options strangle strategy. Parameters \u00b6 The following parameters can be set in the Parameters Configuration Pane: LEG_ONE_TRANSACTION_TYPE : The transaction type for the first leg (BUY: 1 | SELL: 2). LEG_ONE_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for the first leg (CE: 1 | PE: 2). LEG_ONE_STRIKE_DIRECTION : The strike direction for the first leg (ITM: 0 | ATM: 1 | OTM: 2). LEG_ONE_NUMBER_OF_STRIKES : The number of strikes for the first leg. LEG_TWO_TRANSACTION_TYPE : The transaction type for the second leg (BUY: 1 | SELL: 2). LEG_TWO_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for the second leg (CE: 1 | PE: 2). LEG_TWO_STRIKE_DIRECTION : The strike direction for the second leg (ITM: 0 | ATM: 1 | OTM: 2). LEG_TWO_NUMBER_OF_STRIKES : The number of strikes for the second leg.","title":"Options Strangle"},{"location":"strategies/options_strangle/#options-strangle-template-v2","text":"The StrategyOptionsStrangle class is a strategy template for trading options strangles. It is derived from the StrategyOptionsBaseV2 class.","title":"Options Strangle Template v2"},{"location":"strategies/options_strangle/#strangle-options","text":"In the stock market, an options strangle is a strategy where an investor simultaneously buys or sells a call option and a put option on the same underlying asset but with different strike prices and the same expiration date. The purpose of this strategy is to profit from significant price volatility in the underlying asset. Unlike an options straddle, which involves purchasing options at the same strike price, an options strangle involves selecting different strike prices. Typically, the investor buys an out-of-the-money call option (with a strike price above the current market price) and an out-of-the-money put option (with a strike price below the current market price). The strategy aims to benefit from a significant price movement in either direction. If the price of the underlying asset moves significantly upwards, the call option can generate profits. Conversely, if the price moves significantly downwards, the put option can generate profits. The investor is essentially betting on increased price volatility rather than predicting the direction of the price movement. Options strangles are commonly used when traders anticipate a substantial price movement but are unsure about the direction. This strategy allows for potential profits in either an upward or downward market scenario. However, it's important to note that options strangles can involve higher risks, as the underlying asset's price must move significantly to offset the cost of purchasing both options. Traders employing options strangles should carefully consider factors such as the expected price volatility, the expiration date, and the costs associated with purchasing the options. Implementing risk management techniques and monitoring market conditions are essential when utilizing an options strangle strategy.","title":"Strangle Options"},{"location":"strategies/options_strangle/#parameters","text":"The following parameters can be set in the Parameters Configuration Pane: LEG_ONE_TRANSACTION_TYPE : The transaction type for the first leg (BUY: 1 | SELL: 2). LEG_ONE_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for the first leg (CE: 1 | PE: 2). LEG_ONE_STRIKE_DIRECTION : The strike direction for the first leg (ITM: 0 | ATM: 1 | OTM: 2). LEG_ONE_NUMBER_OF_STRIKES : The number of strikes for the first leg. LEG_TWO_TRANSACTION_TYPE : The transaction type for the second leg (BUY: 1 | SELL: 2). LEG_TWO_TRADING_SYMBOL_SUFFIX : The trading symbol suffix for the second leg (CE: 1 | PE: 2). LEG_TWO_STRIKE_DIRECTION : The strike direction for the second leg (ITM: 0 | ATM: 1 | OTM: 2). LEG_TWO_NUMBER_OF_STRIKES : The number of strikes for the second leg.","title":"Parameters"},{"location":"strategies/reverse_rsi/","text":"Reverse RSI \u00b6 This is a trading strategy called \"Reverse RSI v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the relative strength index indicator. What is RSI \u00b6 RSI stands for Relative Strength Index, and it is a popular technical indicator used in the stock market to analyze the strength and momentum of a price trend. The RSI provides insights into whether a stock is overbought or oversold and can help identify potential trend reversals. Here's a summary of RSI in the stock market: The Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements. It compares the magnitude of recent gains to recent losses over a specified period, typically 14 days, and generates a value between 0 and 100. The RSI is calculated using a formula that involves averaging the upward price movements (gains) and the downward price movements (losses) over the chosen period. A high RSI value (typically above 70) indicates that a stock is overbought, meaning it may have experienced a significant price increase and could be due for a correction or pullback. Conversely, a low RSI value (typically below 30) suggests that a stock is oversold, indicating it may have experienced a significant price decline and could be poised for a potential rebound or upward move. Traders often use RSI as a tool to identify potential trend reversals, as extreme RSI readings (above 70 or below 30) can signal a potential change in the direction of the price trend. Additionally, traders may look for bullish or bearish divergences between the RSI and the price chart, which can provide further indications of a potential trend reversal. The RSI is just one tool among many in technical analysis, and it is often used in conjunction with other indicators and analysis techniques to make more informed trading decisions. Overall, the Relative Strength Index (RSI) is a widely used indicator in the stock market to assess the strength and momentum of price movements. It helps traders identify overbought and oversold conditions, as well as potential trend reversals, which can assist in making trading decisions. Strategy Overview \u00b6 The Reverse RSI v2 strategy is a trading strategy based on the Relative Strength Index (RSI) indicator. It generates entry and exit signals based on the reverse crossover of the RSI values from specified overbought and oversold levels. Strategy Parameters \u00b6 The following parameters can be configured for the strategy: TIME_PERIOD : Period (number of candles) by which RSI is calculated OVERBOUGHT_VALUE : RSI value above which stocks are considered over-bought OVERSOLD_VALUE : RSI value below which stocks are considered over-sold Crossover Calculation \u00b6 The get_crossover_value method calculates the crossover values for the RSI indicator using historical data of the instrument. It compares the RSI values with the overbought and oversold levels to determine the entry and exit actions. The method returns the crossover values for oversold and overbought levels.","title":"Reverse RSI"},{"location":"strategies/reverse_rsi/#reverse-rsi","text":"This is a trading strategy called \"Reverse RSI v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the relative strength index indicator.","title":"Reverse RSI"},{"location":"strategies/reverse_rsi/#what-is-rsi","text":"RSI stands for Relative Strength Index, and it is a popular technical indicator used in the stock market to analyze the strength and momentum of a price trend. The RSI provides insights into whether a stock is overbought or oversold and can help identify potential trend reversals. Here's a summary of RSI in the stock market: The Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements. It compares the magnitude of recent gains to recent losses over a specified period, typically 14 days, and generates a value between 0 and 100. The RSI is calculated using a formula that involves averaging the upward price movements (gains) and the downward price movements (losses) over the chosen period. A high RSI value (typically above 70) indicates that a stock is overbought, meaning it may have experienced a significant price increase and could be due for a correction or pullback. Conversely, a low RSI value (typically below 30) suggests that a stock is oversold, indicating it may have experienced a significant price decline and could be poised for a potential rebound or upward move. Traders often use RSI as a tool to identify potential trend reversals, as extreme RSI readings (above 70 or below 30) can signal a potential change in the direction of the price trend. Additionally, traders may look for bullish or bearish divergences between the RSI and the price chart, which can provide further indications of a potential trend reversal. The RSI is just one tool among many in technical analysis, and it is often used in conjunction with other indicators and analysis techniques to make more informed trading decisions. Overall, the Relative Strength Index (RSI) is a widely used indicator in the stock market to assess the strength and momentum of price movements. It helps traders identify overbought and oversold conditions, as well as potential trend reversals, which can assist in making trading decisions.","title":"What is RSI"},{"location":"strategies/reverse_rsi/#strategy-overview","text":"The Reverse RSI v2 strategy is a trading strategy based on the Relative Strength Index (RSI) indicator. It generates entry and exit signals based on the reverse crossover of the RSI values from specified overbought and oversold levels.","title":"Strategy Overview"},{"location":"strategies/reverse_rsi/#strategy-parameters","text":"The following parameters can be configured for the strategy: TIME_PERIOD : Period (number of candles) by which RSI is calculated OVERBOUGHT_VALUE : RSI value above which stocks are considered over-bought OVERSOLD_VALUE : RSI value below which stocks are considered over-sold","title":"Strategy Parameters"},{"location":"strategies/reverse_rsi/#crossover-calculation","text":"The get_crossover_value method calculates the crossover values for the RSI indicator using historical data of the instrument. It compares the RSI values with the overbought and oversold levels to determine the entry and exit actions. The method returns the crossover values for oversold and overbought levels.","title":"Crossover Calculation"},{"location":"strategies/stochastic_crossover/","text":"Stochastic Crossover v2 \u00b6 This is a trading strategy called \"Stochastic Crossover v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Stochastic indicator crossover. Stochastic Oscillator Indicator \u00b6 In the stock market, Stochastic refers to the Stochastic Oscillator, which is a popular technical indicator used to analyze price momentum and identify potential trend reversals. The Stochastic Oscillator compares the closing price of a security to its price range over a specific period of time. It consists of two lines, %K and %D, and generates values between 0 and 100. Here's a summary of the Stochastic Oscillator in the stock market: The Stochastic Oscillator measures the relationship between a security's closing price and its price range over a chosen period. The indicator consists of two lines: %K and %D. %K represents the current closing price relative to the price range, while %D is a smoothed average of %K. The Stochastic Oscillator is bound between 0 and 100. Readings above 80 are typically considered overbought, suggesting a potential price decline or correction. Readings below 20 are often considered oversold, indicating a potential price increase or rebound. Traders use the Stochastic Oscillator to identify potential trend reversals, as overbought or oversold conditions can indicate a possible change in the direction of the price trend. The indicator also generates bullish or bearish divergences, where the price trend and the Stochastic lines move in opposite directions, which can signal a potential trend reversal. The Stochastic Oscillator has various trading strategies associated with it, such as crossovers, overbought/oversold levels, and divergences, which traders use to make buy or sell decisions. It's important to note that the Stochastic Oscillator is a lagging indicator, meaning it may not provide precise timing for trade entries or exits. Therefore, it is often used in conjunction with other indicators and analysis techniques to confirm signals and improve the accuracy of trading decisions. Overall, the Stochastic Oscillator is a widely used technical indicator in the stock market that helps traders assess price momentum, identify overbought and oversold conditions, and spot potential trend reversals. By analyzing the relationship between the closing price and price range, traders can gain insights into potential buying or selling opportunities. Strategy Overview \u00b6 The strategy follows a simple rule based on the Stochastic indicator crossover. When the Stochastic indicator's %K line crosses above the %D line, a buy signal is generated. Conversely, when the %K line crosses below the %D line, a sell signal is generated. The strategy aims to capture potential trend reversals. Strategy Parameters \u00b6 The following parameters can be configured for the strategy: FASTK_PERIOD or PERIOD : The period for the fast %K line of the Stochastic indicator. SLOWK_PERIOD or SMOOTH_K_PERIOD : The period for the slow %K line of the Stochastic indicator. SLOWD_PERIOD or SMOOTH_D_PERIOD : The period for the slow %D line of the Stochastic indicator. Crossover Calculation \u00b6 The get_crossover_value method calculates the crossover values for the Slow-K and Slow-D of Stochastic indicator using historical data of the instrument. The method returns the crossover values between slow-K and slow-D.","title":"Stochastic Crossover"},{"location":"strategies/stochastic_crossover/#stochastic-crossover-v2","text":"This is a trading strategy called \"Stochastic Crossover v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Stochastic indicator crossover.","title":"Stochastic Crossover v2"},{"location":"strategies/stochastic_crossover/#stochastic-oscillator-indicator","text":"In the stock market, Stochastic refers to the Stochastic Oscillator, which is a popular technical indicator used to analyze price momentum and identify potential trend reversals. The Stochastic Oscillator compares the closing price of a security to its price range over a specific period of time. It consists of two lines, %K and %D, and generates values between 0 and 100. Here's a summary of the Stochastic Oscillator in the stock market: The Stochastic Oscillator measures the relationship between a security's closing price and its price range over a chosen period. The indicator consists of two lines: %K and %D. %K represents the current closing price relative to the price range, while %D is a smoothed average of %K. The Stochastic Oscillator is bound between 0 and 100. Readings above 80 are typically considered overbought, suggesting a potential price decline or correction. Readings below 20 are often considered oversold, indicating a potential price increase or rebound. Traders use the Stochastic Oscillator to identify potential trend reversals, as overbought or oversold conditions can indicate a possible change in the direction of the price trend. The indicator also generates bullish or bearish divergences, where the price trend and the Stochastic lines move in opposite directions, which can signal a potential trend reversal. The Stochastic Oscillator has various trading strategies associated with it, such as crossovers, overbought/oversold levels, and divergences, which traders use to make buy or sell decisions. It's important to note that the Stochastic Oscillator is a lagging indicator, meaning it may not provide precise timing for trade entries or exits. Therefore, it is often used in conjunction with other indicators and analysis techniques to confirm signals and improve the accuracy of trading decisions. Overall, the Stochastic Oscillator is a widely used technical indicator in the stock market that helps traders assess price momentum, identify overbought and oversold conditions, and spot potential trend reversals. By analyzing the relationship between the closing price and price range, traders can gain insights into potential buying or selling opportunities.","title":"Stochastic Oscillator Indicator"},{"location":"strategies/stochastic_crossover/#strategy-overview","text":"The strategy follows a simple rule based on the Stochastic indicator crossover. When the Stochastic indicator's %K line crosses above the %D line, a buy signal is generated. Conversely, when the %K line crosses below the %D line, a sell signal is generated. The strategy aims to capture potential trend reversals.","title":"Strategy Overview"},{"location":"strategies/stochastic_crossover/#strategy-parameters","text":"The following parameters can be configured for the strategy: FASTK_PERIOD or PERIOD : The period for the fast %K line of the Stochastic indicator. SLOWK_PERIOD or SMOOTH_K_PERIOD : The period for the slow %K line of the Stochastic indicator. SLOWD_PERIOD or SMOOTH_D_PERIOD : The period for the slow %D line of the Stochastic indicator.","title":"Strategy Parameters"},{"location":"strategies/stochastic_crossover/#crossover-calculation","text":"The get_crossover_value method calculates the crossover values for the Slow-K and Slow-D of Stochastic indicator using historical data of the instrument. The method returns the crossover values between slow-K and slow-D.","title":"Crossover Calculation"},{"location":"strategies/vwap_crossover/","text":"VWAP Crossover v2 \u00b6 This is a trading strategy called \"VWAP Crossover v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the crossover of the VWAP (Volume Weighted Average Price) indicator. VWAP indicator \u00b6 In the stock market, VWAP stands for Volume-Weighted Average Price. VWAP is a trading indicator that calculates the average price at which a particular stock or security has traded throughout the day, taking into account both the price and the volume of each trade. Here's a summary of VWAP in the stock market: VWAP is calculated by multiplying the price of each trade by the corresponding volume and then summing up these values over a specific time period. The total value is divided by the cumulative volume to obtain the average price. The volume-weighted aspect of VWAP gives more weight to trades with higher volume, reflecting the significance of larger trades in the overall average price calculation. VWAP is typically calculated on an intraday basis, such as the trading day or a specific session, and resets at the start of each new period. Traders and investors use VWAP as a benchmark to assess whether their own trades are executed at a better or worse price compared to the average market price. It helps evaluate the quality of their execution and determine if they are buying or selling at a favorable price. VWAP is commonly used by institutional traders who execute large orders as it helps them minimize market impact and avoid unfavorable executions. By comparing their execution price to VWAP, they can assess their performance and adjust their trading strategies accordingly. In addition to being used as a benchmark, VWAP is also employed as a trading strategy. Some traders use VWAP as a reference point for making buy or sell decisions. For example, if the current price is above VWAP, it may be considered bullish, while a price below VWAP could be seen as bearish. VWAP is often displayed as a line on intraday price charts, allowing traders to visually compare the current price to the average price. It can provide insights into the market's overall sentiment and potential support or resistance levels. It's important to note that VWAP is a lagging indicator since it is based on historical data. Therefore, it is often used in combination with other indicators and analysis techniques to validate trade signals and make informed trading decisions. Overall, VWAP is a widely used indicator in the stock market that provides a volume-weighted average price, serving as a benchmark for evaluating trade execution quality and as a reference point for trading decisions. By considering both price and volume, VWAP offers insights into market dynamics and helps traders assess their performance relative to the average market price. Strategy Overview \u00b6 The strategy follows a simple rule based on the crossover of the VWAP indicator. When the price crosses above the VWAP, a buy signal is generated, and when the price crosses below the VWAP, a sell signal is generated. The strategy aims to capture potential trend reversals based on the VWAP. Strategy Parameters \u00b6 No specific strategy parameters are mentioned in the code. Crossover Calculation \u00b6 The get_crossover_value method calculates the VWAP from historical data and the crossover values for the VWAP of the instrument. The method returns the crossover values between close of hist data and vwap.","title":"VWAP Crossover"},{"location":"strategies/vwap_crossover/#vwap-crossover-v2","text":"This is a trading strategy called \"VWAP Crossover v2\" implemented in Python using the PyAlgoTrading library. The strategy is based on the crossover of the VWAP (Volume Weighted Average Price) indicator.","title":"VWAP Crossover v2"},{"location":"strategies/vwap_crossover/#vwap-indicator","text":"In the stock market, VWAP stands for Volume-Weighted Average Price. VWAP is a trading indicator that calculates the average price at which a particular stock or security has traded throughout the day, taking into account both the price and the volume of each trade. Here's a summary of VWAP in the stock market: VWAP is calculated by multiplying the price of each trade by the corresponding volume and then summing up these values over a specific time period. The total value is divided by the cumulative volume to obtain the average price. The volume-weighted aspect of VWAP gives more weight to trades with higher volume, reflecting the significance of larger trades in the overall average price calculation. VWAP is typically calculated on an intraday basis, such as the trading day or a specific session, and resets at the start of each new period. Traders and investors use VWAP as a benchmark to assess whether their own trades are executed at a better or worse price compared to the average market price. It helps evaluate the quality of their execution and determine if they are buying or selling at a favorable price. VWAP is commonly used by institutional traders who execute large orders as it helps them minimize market impact and avoid unfavorable executions. By comparing their execution price to VWAP, they can assess their performance and adjust their trading strategies accordingly. In addition to being used as a benchmark, VWAP is also employed as a trading strategy. Some traders use VWAP as a reference point for making buy or sell decisions. For example, if the current price is above VWAP, it may be considered bullish, while a price below VWAP could be seen as bearish. VWAP is often displayed as a line on intraday price charts, allowing traders to visually compare the current price to the average price. It can provide insights into the market's overall sentiment and potential support or resistance levels. It's important to note that VWAP is a lagging indicator since it is based on historical data. Therefore, it is often used in combination with other indicators and analysis techniques to validate trade signals and make informed trading decisions. Overall, VWAP is a widely used indicator in the stock market that provides a volume-weighted average price, serving as a benchmark for evaluating trade execution quality and as a reference point for trading decisions. By considering both price and volume, VWAP offers insights into market dynamics and helps traders assess their performance relative to the average market price.","title":"VWAP indicator"},{"location":"strategies/vwap_crossover/#strategy-overview","text":"The strategy follows a simple rule based on the crossover of the VWAP indicator. When the price crosses above the VWAP, a buy signal is generated, and when the price crosses below the VWAP, a sell signal is generated. The strategy aims to capture potential trend reversals based on the VWAP.","title":"Strategy Overview"},{"location":"strategies/vwap_crossover/#strategy-parameters","text":"No specific strategy parameters are mentioned in the code.","title":"Strategy Parameters"},{"location":"strategies/vwap_crossover/#crossover-calculation","text":"The get_crossover_value method calculates the VWAP from historical data and the crossover values for the VWAP of the instrument. The method returns the crossover values between close of hist data and vwap.","title":"Crossover Calculation"}]}