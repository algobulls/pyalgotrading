{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home Page","text":""},{"location":"#algobulls","title":"AlgoBulls:","text":"<p>Welcome to AlgoBulls, the AI-backed trading platform that unlocks new dimensions in algorithmic trading. With two dynamic platforms \u2013 pyalgotrading and Python Build \u2013 we're here to amplify your trading experience. AlgoBulls isn't just about platforms; it's about community. Share, learn, and collaborate with traders and developers. Code your strategies or explore ours \u2013 AlgoBulls is where innovation meets trading expertise.</p>"},{"location":"#pyalgotrading","title":"pyalgotrading","text":"<p>Pyalgotrading is an official Python package that offers algorithmic trading APIs powered by AlgoBulls. It provides support for creating and uploading strategies on the AlgoBulls platform, as well as a pool of free strategies at pyalgostrategypool. It also supports over 150 technical indicators, multiple candlestick patterns and intervals, and different types of orders. Pyalgotrading allows for backtesting, paper trading, and real trading (subject to approval), and supports multiple brokers for real trading. Real-time logs and reports are available for all types of trading, and candlestick charts can be plotted using plotly.py.</p>"},{"location":"#python-build","title":"Python Build","text":"<p>The Python Build service is a powerful platform that offers users the flexibility to create their own trading strategies from scratch or make modifications to existing templates. It provides them with the ability to leverage the AlgoBulls Core Trading Engine, an advanced trading system, and gain access to historical data for evaluating and improving the performance of their strategies. With Python Build, users have the freedom to write their trading algorithms from the ground up, allowing for complete customization and control over the logic and functionality of their strategies. Alternatively, they can modify pre-existing templates, which saves time and effort while still enabling them to tailor the strategy to their specific needs. One of the key advantages of the Python Build service is that it grants users the ability to tweak parameters, making it easy to fine-tune their strategies and observe the impact on performance in real-time. This feature empowers traders to optimize their algorithms for desired outcomes and increase the likelihood of successful trading. In addition to parameter tweaking, Python Build also provides users with the capability to view visual analytics. This feature allows for in-depth analysis and visualization of strategy performance, providing traders with valuable insights and enabling them to make data-driven decisions. By analyzing comprehensive data metrics and charts, users can identify patterns, uncover trends, and refine their strategies for enhanced profitability</p> <p>Join us on this journey as AlgoBulls revolutionizes algorithmic trading.</p>"},{"location":"broker_alpaca_guide/","title":"Alpaca","text":"<p>Alpaca is a technology company that offers a modern, developer-friendly trading platform designed for algorithmic and automated trading in the financial markets, particularly focused on equities and cryptocurrencies. The company provides APIs (Application Programming Interfaces) that allow developers and traders to access market data, execute trades, and build their own algorithmic trading strategies.</p> <p>Key features and offerings of Alpaca include:</p> <ol> <li> <p>APIs and SDKs: Alpaca offers APIs and software development kits (SDKs) that enable developers to programmatically access real-time and historical market data, as well as execute trades on various exchanges.</p> </li> <li> <p>Algorithmic Trading: Alpaca's platform is tailored for algorithmic trading strategies, where traders can automate trading decisions based on predefined conditions and rules.</p> </li> <li> <p>Paper Trading: Alpaca provides a simulated environment called \"paper trading,\" allowing traders to test their strategies in a risk-free setting before deploying them with real money.</p> </li> <li> <p>Market Data: The platform offers access to real-time and historical market data, which is crucial for building and testing trading strategies.</p> </li> <li> <p>Order Execution: Traders can use Alpaca's API to execute trades on supported exchanges. This includes submitting market, limit, and stop orders.</p> </li> <li> <p>Customizable Dashboards: Alpaca provides customizable dashboards and interfaces to monitor trading activity and portfolio performance.</p> </li> <li> <p>Brokerage Services: Alpaca acts as a brokerage, providing services that allow traders to execute their strategies on supported exchanges.</p> </li> <li> <p>Regulatory Compliance: Alpaca operates within the regulations of the financial industry, ensuring compliance with rules and requirements.</p> </li> </ol> <p>Alpaca's platform aims to democratize algorithmic trading by providing accessible tools and resources for both individual traders and developers. It's worth noting that the landscape of algorithmic trading and financial technology is constantly evolving, so it's a good idea to check Alpaca's official website for the most current information about their offerings and services.</p>"},{"location":"broker_alpaca_guide/#how-to-get-api-keys-for-trading-in-alpaca","title":"How to get API-keys for trading in Alpaca ?","text":""},{"location":"broker_alpaca_guide/#create-or-login-to-alpaca-account","title":"Create or Login to Alpaca Account","text":""},{"location":"broker_alpaca_guide/#go-to-home-page-of-your-account","title":"Go to Home Page of your Account","text":""},{"location":"broker_alpaca_guide/#view-api-keys-or-generate-api-keys","title":"View API keys or Generate API keys","text":""},{"location":"broker_alpaca_guide/#get-the-secret-key-and-api-key","title":"Get the <code>Secret-Key</code> and <code>API key</code>","text":""},{"location":"gen_ai_guide/","title":"Generative AI","text":"<p>Generative AI involves creating new content using machine learning. A key method is GANs, where a generator creates data and a discriminator evaluates its realism. Another method is VAEs, which encode and decode data. ChatGPT is a specific AI model using generative text, like a conversation. It can understand context, answer questions, and generate text in a human-like manner. It finds use in various fields, from text generation to customer service, but also raises concerns about accuracy and responsible use.</p> <p>ChatGPT can assist in generating code for algorithmic trading strategies. It can translate strategy ideas into code snippets, provide coding guidance, and help with customization. However, human expertise is essential to validate, optimize, and manage risks in the complex realm of algorithmic trading.</p>"},{"location":"gen_ai_guide/#get-chat-gpt-api-keys","title":"Get Chat-GPT API Keys","text":"<p>To get your chat GPT API keys, you can watch the video given below</p> <p></p>"},{"location":"analytics/pyalgotrading_analytics/","title":"Pyalgotrading Analytics","text":""},{"location":"analytics/pyalgotrading_analytics/#metric-values-and-statistics","title":"Metric Values and Statistics:","text":""},{"location":"analytics/pyalgotrading_analytics/#cumulative-returns","title":"Cumulative Returns:","text":"<ul> <li>The Cumulative Returns chart illustrates how our strategy's returns value has evolved over time in percentage. </li> <li>Positive values indicate gains, while negatives reflect losses. Bigger positive returns are more favourable. </li> <li>Keep in mind, this chart focuses on gains and losses, excluding risk and timing considerations.</li> <li>There are 2 sub categories of cumulative returns chart depending on the scale we are using. One is normal scaled and other is log scaled </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#end-of-year-returns-eoy","title":"End of Year Returns (EoY):","text":"<ul> <li>The End of Year Returns chart showcases our strategy's annual performance as a percentage. </li> <li>It quantifies its overall performance, considering gains or losses throughout each year.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#distributions-of-monthly-returns-histogram","title":"Distributions of Monthly Returns (Histogram)","text":"<ul> <li>In the Monthly Returns Distribution Histogram, we see the frequency distribution of different levels of returns over consecutive months. </li> <li>This histogram helps us understand the range and patterns in monthly returns, shedding light on our strategy's volatility and performance trends.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#daily-returns","title":"Daily Returns:","text":"<ul> <li>The Daily Returns Chart portrays the percentage change in our strategy's returns between trading days. </li> <li>It provides insights into short-term volatility, trend analysis, and risk assessment.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#rolling-volatility-6-months","title":"Rolling Volatility (6 months)","text":"<ul> <li>A Rolling Volatility (6 months) Plot showcases the changing volatility of an investment over time using a rolling window of six months. </li> <li>This plot reveals how the investment's price fluctuations vary as the window moves across the dataset. </li> <li>It provides insights into short-term volatility patterns, helping investors understand how the investment's risk level evolves in response to different market conditions.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#rolling-sharpe-6-months","title":"Rolling Sharpe (6 months)","text":"<ul> <li>A Rolling Sharpe (6 months) Plot illustrates the dynamic changes in the Sharpe ratio over time using a rolling window of six months. </li> <li>The plot shows how the risk-adjusted performance of an investment fluctuates as the window moves through the dataset. </li> <li>This visualization helps investors understand how the Sharpe ratio varies with changing market conditions and provides insights into the investment's consistency and risk-return trade-offs over short-term periods.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#rolling-sortino-6-months","title":"Rolling Sortino (6 months)","text":"<ul> <li>A Rolling Sortino (6 months) Plot visualizes the variation in the Sortino ratio over time using a rolling window of six months. </li> <li>This plot demonstrates how the investment's risk-adjusted performance, considering only downside volatility, changes as the window progresses through the data. </li> <li>It offers insights into how the Sortino ratio evolves with market conditions, helping investors assess the investment's ability to generate favorable risk-adjusted returns over short-term intervals.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#worst-5-drawdown-periods","title":"Worst 5 Drawdown Periods","text":"<ul> <li>A Worst 5 Drawdown Periods plot displays the top five periods during which the strategy experienced the largest declines from peak to trough. </li> <li>This visualization helps strategists understand the most significant loss-making episodes in the strategy's run. </li> <li>It shows the magnitude and duration of these drawdowns, providing insights into the strategy's risk and potential vulnerabilities.     </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#underwater-plot","title":"Underwater Plot:","text":"<ul> <li>The Underwater Plot visually narrates our strategy's performance concerning its past peaks. </li> <li>It showcases how much our returns value has dropped from its highest point over time. </li> <li>This aids in visualising periods of drawdown and recovery, offering insights into historical risk and resilience.    </li> </ul>"},{"location":"analytics/pyalgotrading_analytics/#monthly-returns-heatmap","title":"Monthly Returns (Heatmap):","text":"<ul> <li>The Monthly Returns Heatmap offers a colour-coded view of our strategy's performance across months. </li> <li>Shades of green indicate positive returns, while shades of red signify losses. </li> <li>This visual tool helps spot trends and patterns, aiding in identifying strong and weak performance periods.    </li> </ul>"},{"location":"analytics/python-build-view-results/","title":"Python build view results","text":""},{"location":"analytics/python-build-view-results/#how-to-view-the-results","title":"How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy.  Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Only Premium developer plans users will be able to view the strategy analytics values &amp; graphs.</p> <p>Analytics: In the analytics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p>"},{"location":"analytics/python-build-view-results/#stats","title":"Stats","text":"<p>In this section you can see the total returns, sharpe ratio, sortino ratio, volatility, Max Drawdown, Total wins or Loses, Total short or long trades, hit ratio, number of trades, average trades per day, max profit, max loss, average profit per winning trade, average loss per losing trade. </p>"},{"location":"analytics/python-build-view-results/#cummulative-returns","title":"Cummulative Returns","text":""},{"location":"analytics/python-build-view-results/#profit-loss-currency-or","title":"Profit &amp; Loss (Currency or %)","text":"<p>The trade by trade P&amp;L in Currency or Percentage.</p> <p></p>"},{"location":"analytics/python-build-view-results/#end-of-year-returns-plot","title":"End of Year Returns Plot (%)","text":""},{"location":"analytics/python-build-view-results/#monthly-returns-histogram","title":"Monthly Returns Histogram (%)","text":""},{"location":"analytics/python-build-view-results/#monthly-returns-heatmap","title":"Monthly Returns Heatmap (%)","text":""},{"location":"analytics/python-build-view-results/#daily-returns","title":"Daily Returns (%)","text":""},{"location":"analytics/python-build-view-results/#underwater-drawdown-plot","title":"Underwater Drawdown Plot (%)","text":""},{"location":"analytics/python-build-view-results/#pl-book","title":"P&amp;L Book","text":"<p>View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades.</p> <p></p>"},{"location":"analytics/python-build-view-results/#user-log","title":"User Log","text":"<p>Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance.</p> <p></p>"},{"location":"analytics/python-build-view-results/#order-history","title":"Order History","text":"<p>View the order state transition for every order placed by your strategy in depth. </p> <p></p>"},{"location":"pyalgotrad/","title":"Welcome to <code>pyalgotrading</code> Documentation!","text":""},{"location":"pyalgotrad/#official-python-package-for-algorithmic-trading-apis-powered-by-algobulls","title":"Official Python Package for Algorithmic Trading APIs powered by AlgoBulls!","text":""},{"location":"pyalgotrad/#index","title":"Index","text":""},{"location":"pyalgotrad/#pyalgotrading-comprehensive-guide","title":"Pyalgotrading Comprehensive Guide","text":""},{"location":"pyalgotrad/#introduction","title":"Introduction","text":""},{"location":"pyalgotrad/#setup-your-workspace","title":"Setup your workspace","text":"<ul> <li>Prerequisites</li> <li>Requirements</li> </ul>"},{"location":"pyalgotrad/#strategy-execution-and-creation","title":"Strategy Execution and Creation:","text":"<ul> <li>Basic Structure of a Strategy</li> <li>Create your Strategy<ul> <li>Regular Strategy</li> <li>Options Strategy</li> </ul> </li> <li>Execute and Test your Strategy</li> </ul>"},{"location":"pyalgotrad/#analytics","title":"Analytics:","text":"<ul> <li>pyalgotrading Analytics</li> <li>AlgoBulls Analytics</li> </ul>"},{"location":"pyalgotrad/codeguide/","title":"Codeguide","text":"<p>Note</p> <p>This will be a frequently updated page. Keep visiting to know what's new!</p> <p>This page helps you to understand the best practices to create a good strategy.</p>"},{"location":"pyalgotrad/codeguide/#list-of-guidelines","title":"List of Guidelines","text":"<ol> <li> <p>The following Python packages/modules are available to you:</p> Package / Module Version TA-Lib 0.4.25 pandas 1.5.3 numpy 1.24.2 </li> <li> <p>The strategy class should not import any packages/modules.</p> </li> <li>The entire strategy should be a single Python class.</li> </ol> <p>Note</p> <ul> <li>Pandas is available with limited functionality. Direct printing of dataframes is disabled.</li> <li>It is a good idea to include the version number while installing a package using <code>pip</code>.</li> <li>Example - <code>pip install numpy==1.24.2</code> </li> </ul> <p>You may get the following message if the strategy fails to adhere to the guidelines.</p> <pre><code>Strategy breached code of conduct. Please adjust your strategy to follow guidelines and run again. Halting strategy...\n</code></pre>"},{"location":"pyalgotrad/introduction/","title":"Introduction","text":"<p>This tutorial aims to help users practice and get familiar with the Pyalgotrading package, which is a Python-based algorithmic trading library. It allows you to create and execute your trading strategies on various financial instruments such as equities, futures, options, and more. To follow this tutorial, you will need to have an active and working AlgoBulls account, which is a platform for creating and testing trading strategies.</p>"},{"location":"pyalgotrad/introduction/#prerequisites","title":"Prerequisites","text":"<p>Before starting the tutorial, ensure that you have the following setup:</p> <ul> <li>An active and working AlgoBulls account</li> <li>Python IDE of your choice (if you want to code your own strategy)</li> <li>Jupyter Notebook (for points 2,3, and 4)</li> </ul>"},{"location":"pyalgotrad/introduction/#features","title":"Features","text":"<ul> <li>Powered by the AlgoBulls Platform</li> <li>Everything related to Algorithmic Trading Strategies!<ul> <li>Create &amp; upload strategies on the AlgoBulls Platform</li> <li>Free pool of Strategies are available separately at pyalgostrategypool!</li> <li>Support for all 150+ Technical Indicators provided by TA-Lib</li> <li>Support for multiple candlesticks patterns - Japanese OHLC, Renko, Heikin-Ashi, Linebreak</li> <li>Support for multiple candle intervals - 1 minute, 3 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 1 day. </li> <li>Support for MARKET, LIMIT, STOPLOSS-MARKET, STOPLOSS-LIMIT orders</li> <li>Support for INTRADAY and DELIVERY orders</li> </ul> </li> <li> <p>Support for Backtesting, Paper Trading and Real Trading</p> <ul> <li>Currently supported brokers </li> <li>Real-time Logs for Backtesting, Paper Trading and Real Trading</li> <li>Multiple real-time Reports available for Backtesting, Paper Trading and Real Trading - </li> <li>Profit-n-Loss report (PnL report)</li> <li>Statistics of (PnL report)</li> <li>Order History for each order with state transitions &amp; timestamps</li> <li>Plot Candlestick charts using plotly.py</li> </ul> </li> </ul> <p>Backtesting, Paper Trading and Real Trading can be performed on the same strategy code base!</p>"},{"location":"pyalgotrad/introduction/#python","title":"Python","text":"<ul> <li>Python Support: <code>Python 3.10+</code>.</li> <li>Python Requirements: See requirements.txt.</li> <li>We recommend you to use the latest version of Python (v3.10+) to enjoy better performance benefits, especially for pandas (v1.5.3). </li> </ul>"},{"location":"pyalgotrad/introduction/#installation","title":"Installation","text":"<p>Package can be easily installed using <code>pip</code> -  <pre><code>pip install pyalgotrading\n</code></pre></p>"},{"location":"pyalgotrad/introduction/#support-getting-help","title":"Support / Getting Help","text":"<ul> <li>Bug Reporting / New Feature Request: Please create a new issue here on GitHub.</li> <li>Discussion Forum: Discuss with our developers on this forum</li> <li>Additional Support: If none of the above help, please contact pushpak@algobulls.com.</li> </ul>"},{"location":"pyalgotrad/introduction/#tutorial-steps","title":"Tutorial Steps","text":"<ol> <li> <p>Code your own simple strategy using the Pyalgotrading package: In this step, you will use your Python IDE to code your own trading strategy using Pyalgotrading package. You can also use the ready-made strategy provided by the pyalgostrategypool package if you don't want to code your own.  </p> </li> <li> <p>Upload your strategy to the AlgoBulls platform: After coding your strategy, you will need to upload it to the AlgoBulls platform. This can be done by creating a new strategy on the platform and then uploading your strategy file.  </p> </li> <li> <p>Run Backtest / Paper Trade / Real Trade using your strategy: Once you have uploaded your strategy, you can run backtests, paper trades or real trades to see how your strategy performs. These can be done from the AlgoBulls platform itself.  </p> </li> <li> <p>Fetch logs during runtime, see reports, view statistics, and see your order history: You can fetch the logs during runtime to monitor your strategy's performance and view reports and statistics to analyze its effectiveness. You can also view your order history to see the trades executed by your strategy.  </p> </li> <li> <p>Check out the basic structure of a strategy: Before coding your strategy, you can refer to the basic structure of a strategy provided by the Pyalgotrading package. This will give you an idea of the methods involved in the trading strategy and their flow.  </p> </li> <li> <p>Reach out to AlgoBulls Support for any queries: If you face any issues during the tutorial, you can reach out to the AlgoBulls Support(mailto:support@algobulls.com) team for help.  </p> </li> </ol>"},{"location":"pyalgotrad/introduction/#conclusion","title":"Conclusion","text":"<p>In conclusion, this tutorial helps users get started with the Pyalgotrading package and create their own trading strategies. It also provides information on how to upload, run and monitor the strategies on the AlgoBulls platform. The tutorial aims to equip users with the necessary skills to create effective trading strategies using the Pyalgotrading package.</p>"},{"location":"pyalgotrad/introduction/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>Here\u2019s how we suggest you go about proposing a change to this project:</p> <ol> <li>Fork this project to your account.</li> <li>Create a branch for the change you intend to make.</li> <li>Make your changes to your fork.</li> <li>Send a pull request from your fork\u2019s branch to our <code>master</code> branch.</li> </ol>"},{"location":"pyalgotrad/introduction/#changelog","title":"Changelog","text":"<p>See CHANGELOG.md.</p>"},{"location":"pyalgotrad/introduction/#license","title":"License","text":"<p>See LICENSE.</p>"},{"location":"pyalgotrad/prerequisites/","title":"Prerequisites","text":"<p>You will need the following to perform this tutorial:</p> <ol> <li> <p>AlgoBulls Account (Link) - You will need this account to upload and test your strategies. The account needs to be setup with the proper risk management values and a bound broker before any trades can be executed. Make sure the account is properly setup or contact AlgoBulls Support for any help.</p> </li> <li> <p>Python 3.10 (Link) - The pyalgotrading platform can run all strategies that conform to Python 3.10. </p> </li> <li> <p>A Python IDE of your choice, like Pycharm (Link) - As mentioned in the [Introduction], this tutorial will demonstrate the pyalgotrading package by implementing the Simple Moving Average Crossover Strategy for Regular Orders. You will make this strategy as a separate python file, and the PyCharm Community Edition IDE is enough for this purpose. If you are already using a Python IDE of your choice, you may skip this step. </p> </li> <li> <p>Jupyter Notebook (Link) - You will use a Jupyter Notebook to connect to the AlgoBulls platform. You will upload the strategy, test your strategy (Backtesting, Paper Trading or Real Trading), and fetch logs using the notebook.</p> </li> </ol> <p>Tips</p> <ul> <li>It is a good idea to set up a virtual environment first</li> <li>Install Python 3.10</li> <li>Once Python is installed, most packages are easily installed in your venv using <code>pip install</code> command</li> <li><code>pip install TA-Lib</code></li> <li><code>pip install pyalgotrading</code></li> <li><code>pip install jupyterlab</code></li> </ul>"},{"location":"pyalgotrad/programexample/","title":"Create your Strategy","text":""},{"location":"pyalgotrad/programexample/#previously","title":"Previously...","text":"<p>You have covered the basic code structure of a strategy.</p>"},{"location":"pyalgotrad/programexample/#now","title":"Now...","text":"<p>You can either follow this page to create a strategy, or you can pick up a ready strategy (shown below) and move to the next page. </p>"},{"location":"pyalgotrad/programexample/#before-you-start","title":"Before you start...","text":"<p>If you want to use a ready strategy from the pyalgostrategypool package, then you can directly jump to the Upload section. </p>"},{"location":"pyalgotrad/programexample/#lets-start","title":"Let's Start...","text":"<p>Follow the steps given below to create a new strategy of your own.</p> <p>Create a python file called <code>strategy_sma_regular_order.py</code>.</p> <p>You will add the following code snippets into the file and then save it.</p>"},{"location":"pyalgotrad/programexample/#import-statements","title":"Import statements","text":"<pre><code>from pyalgotrading.strategy.strategy_base import StrategyBase\nfrom pyalgotrading.constants import *\n</code></pre>"},{"location":"pyalgotrad/programexample/#create-the-class-strategysmaregularorder-and-subclass-it-from-strategybase","title":"Create the class <code>StrategySMARegularOrder</code> and subclass it from <code>StrategyBase</code>","text":"<p><pre><code>class StrategySMARegularOrder(StrategyBase):\n</code></pre> Now you can add the methods mentioned in the structure inside the class. First you can add the <code>__init__</code> and the <code>initialize</code> methods.</p>"},{"location":"pyalgotrad/programexample/#constructor-def-__init__","title":"Constructor: <code>def __init__()</code>","text":"<pre><code>def __init__(self, *args, **kwargs):\n    name = 'SMA Regular Order Strategy'\n    super().__init__(*args, **kwargs)\n\n    self.timeperiod_x = self.strategy_parameters['timeperiod1']\n    self.timeperiod_y = self.strategy_parameters['timeperiod2']\n\n    self.main_order = None\n</code></pre> <p>The <code>init</code> method does the following:</p> <ol> <li><code>name</code> - variable which should store the name of your strategy</li> <li><code>super()</code> - Calls the constructor of the superclass.</li> <li><code>self.strategy_parameters</code> - Catches the parameters and saves them for local use - When you will submit a testing job for your SMA strategy,  you will pass parameters that will be used inside the strategy.  For SMA, we are calculating crossover for 2 SMA timeperiod values, example 5 and 12.  These 2 parameters will be caught by <code>self.strategy_parameters</code> and stored for local use in <code>self.timeperiod1</code> and <code>self.timeperiod2</code>.</li> <li><code>self.main_order</code> - Create an object that manages orders for you throughout the strategy.</li> </ol> <p>The <code>init</code> method is specific to Python's internal workings, and it is preceded and succeeded by double underscores ( _ _ ) joined together.</p>"},{"location":"pyalgotrad/programexample/#def-initialize","title":"<code>def initialize()</code>","text":"<pre><code>def initialize(self):\n    self.main_order = {}\n</code></pre> <p>The <code>initialize</code> method sets the <code>self.main_order</code> as an empty dictionary. This method is called at the start of every trading day.</p> <p>For instance, say you are submitting a backtesting job for 5 previous days starting at 10:30 every day, then the <code>initialize</code> method will be called every day for 5 days at 10:30.</p> <p>Now add the two static methods, <code>name</code> and <code>versions_supprted</code>.</p>"},{"location":"pyalgotrad/programexample/#def-name-optional","title":"<code>def name()</code> (optional)","text":"<p>If the <code>name</code> variable is defined in <code>__init__()</code>, this function is not needed. <pre><code>@staticmethod\ndef name():\n    return 'SMA Regular Order Strategy'\n</code></pre> The name should be unique in your collection of strategies.</p>"},{"location":"pyalgotrad/programexample/#def-versions_supported-optional","title":"<code>def versions_supported()</code> (optional)","text":"<p>not required it will take the latest version of AlgoBullsEngine by default <pre><code>@staticmethod\ndef versions_supported():\n    return AlgoBullsEngineVersion.VERSION_3_2_0\n</code></pre> Mark both the above methods as <code>@staticmethod</code>.</p> <p>The <code>versions_supported</code> method does the following:</p> <ol> <li>It notifies the AlgoBulls platform that the strategy is working correctly for the platform version 3.2.0</li> <li>Since the platform will be constantly upgraded to incorporate new features and improve efficiency, the version may change.</li> <li>If the version changes, and if you submit a job for this strategy, then the AlgoBulls platform will spawn a server having version 3.2.0 for your strategy.</li> <li>Having this method ensures that the AlgoBulls platform always provides the correct environment for your strategy.</li> </ol>"},{"location":"pyalgotrad/programexample/#def-strategy_select_instruments_for_entry","title":"<code>def strategy_select_instruments_for_entry()</code>","text":"<pre><code>def strategy_select_instruments_for_entry(self, candle, instruments_bucket):\n\n    instruments = []\n    meta = []\n\n    for instrument in instruments_bucket:\n        crossover_value = self.get_crossover_value(instrument)\n        if crossover_value == 1:\n            instruments.append(instrument)\n            meta.append({'action': 'BUY'})\n        elif crossover_value == -1:\n            if self.strategy_mode is StrategyMode.INTRADAY:\n                instruments.append(instrument)\n                meta.append({'action': 'SELL'})\n\n    return instruments, meta\n</code></pre> <p>The <code>strategy_select_instruments_for_entry</code> method does the following:</p> <ol> <li><code>instruments</code> and <code>meta</code> - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively.</li> <li>The Loop - The loop will iterate over each instrument name passed (while submitting the job) and will decide whether to set an entry position or not for it.</li> <li><code>crossover_value</code> - The crossover value is calculated and stored here. Crossover values are interpreted as:<ol> <li>Value 1 - Cut upwards</li> <li>Value -1 - Cut downwards</li> <li>Value 0 - No crossover</li> </ol> </li> <li>If conditions - If the crossover value is 1, then the instrument is selected for entry position, with the position as 'BUY'. If the crossover value is -1, then the instrument is selected for entry position, with the position as 'SELL'. The selected instrument is appended to the <code>instruments</code>, and the associated action (BUY/SELL) is appended to the <code>meta</code>.</li> <li><code>instruments</code> and <code>meta</code> - Both the lists (whether populated or empty) are returned to the platform for further actions.</li> </ol> <p>Note</p> <ul> <li>SELL Entry positions are allowed only if the strategy is running for INTRADAY. DELIVERY strategies do not allow SELL as entry positions. This is taken care of in the <code>elif</code> part.</li> <li>The <code>strategy_select_instruments_for_entry</code> method is called once for every candle time. For Instance, if you submit a job with the candle time as 15 minutes, then this method will be called once for every 15 minute candle.</li> <li>The actual Entry position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the <code>meta</code>. The Entry position will be taken in the next method below.</li> <li>The <code>meta</code> contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. </li> </ul>"},{"location":"pyalgotrad/programexample/#def-strategy_enter_position","title":"<code>def strategy_enter_position()</code>","text":"<pre><code>def strategy_enter_position(self, candle, instrument, sideband_info):\n    if sideband_info['action'] == 'BUY':\n        qty = self.number_of_lots * instrument.lot_size\n        self.main_order[instrument] = \\\n            self.broker.BuyOrderRegular(instrument=instrument,\n                order_code=BrokerOrderCodeConstants.INTRADAY,\n                order_variety=BrokerOrderVarietyConstants.MARKET,\n                quantity=qty)\n    elif sideband_info['action'] == 'SELL':\n        qty = self.number_of_lots * instrument.lot_size\n        self.main_order[instrument] = \\\n            self.broker.SellOrderRegular(instrument=instrument,\n                 order_code=BrokerOrderCodeConstants.INTRADAY,\n                 order_variety=BrokerOrderVarietyConstants.MARKET,\n                 quantity=qty)\n    else:\n        raise SystemExit(f'Got invalid sideband_info value: {sideband_info}')\n\n    return self.main_order[instrument]\n</code></pre>"},{"location":"pyalgotrad/programexample/#or","title":"or","text":"<pre><code>def strategy_enter_position(self, candle, instrument, meta):\n    self.main_order_map[instrument] = _ = self.broker.OrderRegular(\n        intrument=instrument,                           \n        order_transaction_type=meta['action'],              # 'BUY' or 'SELL'\n        quantity=self.number_of_lots * instrument.lot_size, # number of lots (int)\n        price=None,\n        trigger_price=None\n    )\n    return _\n</code></pre> <p>The <code>strategy_enter_position</code> method does the following:</p> <ol> <li>If conditions - The conditions read the action from the <code>sideband_info</code> and perform the required action (BUY/SELL).</li> <li><code>qty</code> - The quantity is calculated and stored here. The number of lots will be passed by you as a parameter while submitting a job. The parameter will be caught in <code>self.number_of_lots</code>. The instrument object has the 'lot size', which you can retrieve using <code>instrument.lot_size</code>. You can then use the formula as shown in the code to calculate the quantity.</li> <li><code>OrderRegular</code>,<code>BuyOrderRegular</code> and <code>SellOrderRegular</code> - These execute the required action. You need to pass the instrument, order code, order variety and the quantity values.<ul> <li><code>instrument</code> - the instrument on which the BUY/SELL action will be performed.</li> <li><code>order_code</code> - whether the order is for INTRADAY or DELIVERY. Possible values are:<ul> <li><code>BrokerOrderCodeConstants.INTRADAY</code></li> <li><code>BrokerOrderCodeConstants.DELIVERY</code></li> <li><code>BrokerOrderCodeConstants.DELIVERY_T1</code></li> <li><code>BrokerOrderCodeConstants.DELIVERY_T2</code></li> </ul> </li> <li><code>order_variety</code> - the type of order variety. Possible values are:<ul> <li><code>BrokerOrderVarietyConstants.MARKET</code></li> <li><code>BrokerOrderVarietyConstants.LIMIT</code></li> <li><code>BrokerOrderVarietyConstants.STOPLOSS_MARKET</code></li> <li><code>BrokerOrderVarietyConstants.STOPLOSS_LIMIT</code></li> </ul> </li> <li><code>qty</code> - the quantity to BUY/SELL.</li> </ul> </li> <li><code>self.main_order</code> - The main order (for that particular instrument) is now populated (BUY OR SELL) and is returned to the platform for further actions.</li> </ol> <p>You can also punch Bracket Orders instead of Regular Orders. A typical BUY Bracket Order will look like this: <pre><code>qty = self.number_of_lots * instrument.lot_size\nltp = self.broker.get_ltp(instrument)\nself.main_order[instrument] = \\\n            self.broker.BuyOrderBracket(instrument=instrument,\n                order_code=BrokerOrderCodeConstants.INTRADAY,\n                order_variety=BrokerOrderVarietyConstants.LIMIT,\n                quantity=qty,\n                price=ltp,\n                stoploss_trigger=ltp - (ltp * self.stoploss),\n                target_trigger=ltp + (ltp * self.target),\n                trailing_stoploss_trigger=ltp * self.trailing_stoploss)\n</code></pre></p> <p>The additional parameters are:</p> <ul> <li><code>price</code> - If you want to BUY at the market price (Last Traded Price) or LTP, then just fetch the LTP using <code>get_ltp</code> as shown in the code above. Store the value in <code>ltp</code> and pass it to <code>price</code>.</li> <li><code>stoploss_trigger</code>, <code>target_trigger</code> and <code>trailing_stoploss_trigger</code> - You can calculate these using the <code>ltp</code> and the values you will pass through  the job that you will submit. The parameters will be caught as <code>self.stoploss</code>, <code>self.target</code> and <code>self.trailing_stoploss</code>.</li> </ul> <p>Note</p> <ul> <li>If you plan to use Bracket Order instead of Regular Orders, then create a separate Python file for it, say <code>strategy_sma_bracket_order.py</code>.  You can also change the class name as <code>StrategySMABracketOrder</code>. There will be changes in the entry and exit methods also.</li> <li>The <code>strategy_enter_position</code> method is called once for every instrument. For instance, you want to run this strategy for 5 instruments. Say that the <code>strategy_select_instruments_for_entry</code> method selects 3 instruments for ENTRY positions (BUY/SELL). Then, the <code>strategy_enter_position</code> method will be called thrice, once for each instrument respectively within the candle time frame (say, 15 minutes). </li> </ul>"},{"location":"pyalgotrad/programexample/#def-strategy_select_instruments_for_exit","title":"<code>def strategy_select_instruments_for_exit()</code>","text":"<pre><code>def strategy_select_instruments_for_exit(self, candle, instruments_bucket):\n    instruments = []\n    meta = []\n\n    for instrument in instruments_bucket:\n        if self.main_order.get(instrument) is not None:\n            crossover_value = self.get_crossover_value(instrument)\n            if crossover_value in [1, -1]:\n                instruments.append(instrument)\n                meta.append({'action': 'EXIT'})\n    return instruments, meta\n</code></pre> <p>The <code>strategy_select_instruments_for_exit</code> method does the following:</p> <ol> <li><code>instruments</code> and <code>meta</code> - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively.</li> <li>The Loop - The loop will iterate over each instrument name passed (which are in Entry position (BUY/SELL)) and will decide whether to set an exit position or not for it.</li> <li>If condition - The exit steps are executed only if the instrument is holding at an ENTRY position (BUY/SELL). You can do this by checking if the <code>self.main_order</code> object is <code>None</code> or not, and proceed only if it is not <code>None</code>. </li> <li><code>crossover_value</code> - The crossover value is calculated and stored here. Crossover values are interpreted as:<ol> <li>Value 1 - Cut upwards</li> <li>Value -1 - Cut downwards</li> <li>Value 0 - No crossover</li> </ol> </li> <li>If condition - If the crossover value is 1 or -1, then the instrument is selected for exit position. The selected instrument is appended to the <code>instruments</code>, and the associated action (EXIT) is appended to the <code>meta</code>.</li> <li><code>instruments</code> and <code>meta</code> - Both the lists (whether populated or empty) are returned to the platform for further actions.</li> </ol> <p>Note</p> <ul> <li>The actual Exit position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the <code>meta</code>. The Exit position will be taken in the next method below.</li> <li>The <code>meta</code> contains a very versatile dictionary object. You may use it to pass any other additional information that you wish.</li> <li>Whenever a new trading day starts, the <code>strategy_select_instruments_for_exit</code> is called first. This is very important for DELIVERY strategies. Many instruments might be holding in an Entry Position at the end of the previous trading day, and they might be eligible for exit at the start of the new trading day.  </li> </ul>"},{"location":"pyalgotrad/programexample/#def-strategy_exit_position","title":"<code>def strategy_exit_position()</code>","text":"<pre><code>def strategy_exit_position(self, candle, instrument, sideband_info):\n    if sideband_info['action'] == 'EXIT':\n        self.main_order[instrument].exit_position()\n        self.main_order[instrument] = None\n        return True\n\n    return False\n</code></pre> <p>The <code>strategy_exit_position</code> method does the following:</p> <ol> <li>If condition - checks whether the appropriate action is set in the <code>sideband_info</code>.</li> <li><code>self.main_order</code> - calls <code>exit_position</code> method for the particular main order of the instrument. If the Entry Position was BUY, then the exit position is automatically taken as SELL and vice versa. The platform takes care of this automatically.</li> <li><code>self.main_order</code> - set it to <code>None</code>, as the order has been exited and no longer holds anything.</li> <li>Return values - returns <code>True</code> to the platform if the exit steps were performed, else return <code>False</code>.</li> </ol>"},{"location":"pyalgotrad/programexample/#def-get_crossover_value","title":"<code>def get_crossover_value()</code>","text":"<pre><code>def get_crossover_value(self, instrument):\n    hist_data = self.get_historical_data(instrument)\n    sma_x = talib.SMA(hist_data['close'], timeperiod=self.timeperiod_x)\n    sma_y = talib.SMA(hist_data['close'], timeperiod=self.timeperiod_y)\n    crossover_value = self.utils.crossover(sma_x, sma_y)\n    return crossover_value\n</code></pre> <p>The <code>get_crossover_value</code> method does the following:</p> <ol> <li><code>hist_data</code> - The historical data for the instrument is fetched using the <code>get_historical_data</code> method and stored here. The data is in the form of a table (Pandas DataFrame) having the following columns:<ul> <li><code>timestamp</code> - the data and time when the data was measured</li> <li><code>volume</code> - the volume of that instrument</li> <li><code>open</code>, <code>high</code>, <code>low</code> and <code>close</code> - the OHLC values of the instrument</li> <li><code>oi</code> - the Open Interest of that instrument</li> </ul> </li> <li><code>sma_x</code> and <code>sma_y</code> - the SMA function from the <code>talib</code> package is used to calculate the Moving Average for both SMA time-periods. The candle close value is used for calculations, i.e. <code>hist_data['close']</code>.</li> <li><code>crossover_value</code> - calculates the crossover value using the <code>crossover</code> method from the <code>utils</code> package.</li> <li>Return value - return the crossover value to the caller method.</li> </ol> <p>Note</p> <ul> <li>The order of values passed to the <code>crossover</code> method of the <code>utils</code> package is very important.</li> <li>Example: you have 2 SMA values, 5 and 12. The strategy describes that there should be an BUY Entry Position when SMA(5) cuts SMA(12) upwards (crossover value should be 1).</li> <li>In this case, if you mistakenly pass SMA(12) value first and SMA(5) value next to the <code>crossover</code> function, the answer you will get is -1 (Cut downwards).</li> <li>Though, the crossover value is correct, the strategy is expecting to BUY at crossover 1 as per the code, which will not work now.</li> <li>Therefore, the strategy will work correctly only if you pass SMA(5) first and then SMA(12) to the <code>crossover</code> function, thus making the order of parameters passed an important point to be aware of, while coding the strategy.</li> </ul>"},{"location":"pyalgotrad/programexample/#whats-next","title":"What's Next...","text":"<p>Next, you upload the strategy into your AlgoBulls account.</p>"},{"location":"pyalgotrad/pyalgotrading_analytics/","title":"Pyalgotrading Analytics","text":""},{"location":"pyalgotrad/pyalgotrading_analytics/#metric-values-and-statistics","title":"Metric Values and Statistics:","text":""},{"location":"pyalgotrad/pyalgotrading_analytics/#cumulative-returns","title":"Cumulative Returns:","text":"<ul> <li>The Cumulative Returns chart illustrates how our strategy's returns value has evolved over time in percentage. </li> <li>Positive values indicate gains, while negatives reflect losses. Bigger positive returns are more favourable. </li> <li>Keep in mind, this chart focuses on gains and losses, excluding risk and timing considerations.</li> <li>There are 2 sub categories of cumulative returns chart depending on the scale we are using. One is normal scaled and other is log scaled </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#end-of-year-returns-eoy","title":"End of Year Returns (EoY):","text":"<ul> <li>The End of Year Returns chart showcases our strategy's annual performance as a percentage. </li> <li>It quantifies its overall performance, considering gains or losses throughout each year.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#distributions-of-monthly-returns-histogram","title":"Distributions of Monthly Returns (Histogram)","text":"<ul> <li>In the Monthly Returns Distribution Histogram, we see the frequency distribution of different levels of returns over consecutive months. </li> <li>This histogram helps us understand the range and patterns in monthly returns, shedding light on our strategy's volatility and performance trends.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#daily-returns","title":"Daily Returns:","text":"<ul> <li>The Daily Returns Chart portrays the percentage change in our strategy's returns between trading days. </li> <li>It provides insights into short-term volatility, trend analysis, and risk assessment.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#rolling-volatility-6-months","title":"Rolling Volatility (6 months)","text":"<ul> <li>A Rolling Volatility (6 months) Plot showcases the changing volatility of an investment over time using a rolling window of six months. </li> <li>This plot reveals how the investment's price fluctuations vary as the window moves across the dataset. </li> <li>It provides insights into short-term volatility patterns, helping investors understand how the investment's risk level evolves in response to different market conditions.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#rolling-sharpe-6-months","title":"Rolling Sharpe (6 months)","text":"<ul> <li>A Rolling Sharpe (6 months) Plot illustrates the dynamic changes in the Sharpe ratio over time using a rolling window of six months. </li> <li>The plot shows how the risk-adjusted performance of an investment fluctuates as the window moves through the dataset. </li> <li>This visualization helps investors understand how the Sharpe ratio varies with changing market conditions and provides insights into the investment's consistency and risk-return trade-offs over short-term periods.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#rolling-sortino-6-months","title":"Rolling Sortino (6 months)","text":"<ul> <li>A Rolling Sortino (6 months) Plot visualizes the variation in the Sortino ratio over time using a rolling window of six months. </li> <li>This plot demonstrates how the investment's risk-adjusted performance, considering only downside volatility, changes as the window progresses through the data. </li> <li>It offers insights into how the Sortino ratio evolves with market conditions, helping investors assess the investment's ability to generate favorable risk-adjusted returns over short-term intervals.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#worst-5-drawdown-periods","title":"Worst 5 Drawdown Periods","text":"<ul> <li>A Worst 5 Drawdown Periods plot displays the top five periods during which the strategy experienced the largest declines from peak to trough. </li> <li>This visualization helps strategists understand the most significant loss-making episodes in the strategy's run. </li> <li>It shows the magnitude and duration of these drawdowns, providing insights into the strategy's risk and potential vulnerabilities.     </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#underwater-plot","title":"Underwater Plot:","text":"<ul> <li>The Underwater Plot visually narrates our strategy's performance concerning its past peaks. </li> <li>It showcases how much our returns value has dropped from its highest point over time. </li> <li>This aids in visualising periods of drawdown and recovery, offering insights into historical risk and resilience.    </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_analytics/#monthly-returns-heatmap","title":"Monthly Returns (Heatmap):","text":"<ul> <li>The Monthly Returns Heatmap offers a colour-coded view of our strategy's performance across months. </li> <li>Shades of green indicate positive returns, while shades of red signify losses. </li> <li>This visual tool helps spot trends and patterns, aiding in identifying strong and weak performance periods.    </li> </ul>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/","title":"Introducing pyalgotrading: Your Gateway to Algorithmic Trading","text":""},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#what-is-pyalgotrading","title":"What is pyalgotrading?","text":"<p>pyalgotrading is more than just a Python library; it serves as your comprehensive partner for crafting and executing trading strategies with the skill of a professional. It caters to both experienced traders and newcomers, providing a suite of tools that empower you to make well-informed decisions and trade confidently in the financial markets.</p> <p> </p> <p>When it comes to strategy development, pyalgotrading enables you to dive into coding, backtesting, and deploying your trading strategies with remarkable ease. Through an intuitive interface, you gain the power to precisely define when to enter and exit trades, manage multiple instruments, and execute actions based on informed insights.</p> <p> </p> <p>The versatility of pyalgotrading shines through its unified strategy format, applicable across various trading types. Whether you're engaging in backtesting, paper trading, or real trading, the library provides comparable functions for all three scenarios. This unified approach allows you to transition seamlessly between these modes, with no need for intricate adjustments. Additionally, the library facilitates the generation of progressive logs, allowing you to track your progress and anticipate completion times. You can also print live logs that update in real-time, enhancing transparency and control over your trading activities.</p> <p> </p> <p>pyalgotrading's strength lies in its ability to integrate seamlessly with real-time market data sources, historical data, and trading platforms. Its adaptable nature allows you to connect with a variety of data providers and broker APIs, enabling you to access the information you need to make well-informed trading decisions.</p> <p>By joining the thriving pyalgotrading community, you tap into a rich network of traders and developers. This community serves as a platform for collaboration, where you can seek guidance, share valuable insights, and collectively refine your trading strategies. The synergy of diverse perspectives helps you approach trading challenges from various angles, fostering growth and improvement.</p> <p> </p> <p>In the pursuit of successful trading, pyalgotrading equips you with advanced visual tools for strategy analytics. By harnessing these tools, you gain a deeper understanding of your strategies' performance. You can effectively manage risks and fine-tune your strategies to optimize their potential for success. These visualization tools facilitate data-driven decision-making and provide a clearer perspective on the intricacies of your trading activities.</p> <p>In summary, pyalgotrading is more than a mere library; it's your comprehensive gateway to mastering the art of algorithmic trading. Its user-friendly interface, diverse functionalities, and integration capabilities make it a valuable asset for traders at all levels of expertise. By simplifying the complexities of strategy development, deployment, integration, and analysis, pyalgotrading empowers you to navigate the world of trading with confidence and precision.</p>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#pros-and-cons-of-pyalgotrading","title":"Pros and Cons of pyalgotrading","text":"<p>In the exciting world of algorithmic trading, pyalgotrading stands as a formidable tool, offering a range of benefits and considerations for traders and developers. Let's dive into the pros and cons of this versatile library to help you make an informed decision.</p> <p> </p>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#pros-of-pyalgotrading","title":"Pros of pyalgotrading:","text":"<ol> <li> <p>Simplified Strategy Coding: pyalgotrading introduces a user-friendly coding format, making strategy creation accessible to all. Whether you're a trading veteran or a newcomer, this simplicity ensures quick implementation of trading ideas without steep learning curves.</p> </li> <li> <p>Powered by Algobulls: The integration with Algobulls unlocks the potential of the AlgoBulls platform. The best part? It's absolutely free for developers. This partnership opens doors to testing and deploying strategies in a live trading environment, amplifying the scope of possibilities.</p> </li> <li> <p>Python Syntax Advantage: Leveraging Python as the core language brings familiarity to the table. Widely known and understood, Python's syntax is a boon for data analysis. The library's compatibility with Jupyter further enhances data-driven insights.</p> </li> </ol>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#cons-of-pyalgotrading","title":"Cons of pyalgotrading:","text":"<ol> <li> <p>Python's Speed Limitation: While versatile, Python isn't the fastest language for computation. This might pose challenges with complex strategies requiring extensive calculations.</p> </li> <li> <p>Potential for Bugs: Being a relatively new library, occasional bugs could emerge. However, the pyalgotrading technical team is dedicated to swift bug resolution, ensuring a smoother user experience.</p> </li> <li> <p>Initial Flexibility Trade-off: In its pursuit of user-friendliness, pyalgotrading might sacrifice some flexibility found in more complex libraries. This trade-off aims to strike a balance between ease of use and customization.</p> </li> </ol>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#starting-with-pyalgotrading-library","title":"Starting with pyalgotrading Library","text":""},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#installation","title":"Installation:","text":"<p>To embark on your journey with pyalgotrading, the first step is installing the library using pip. This process ensures that you have the necessary tools at your disposal to start crafting and executing trading strategies. Follow these instructions:</p> <ol> <li>Open your terminal or command prompt.</li> <li>Type the following command and press Enter:     <pre><code>pip install **pyalgotrading**\npip install quantstats==0.0.59\npip install pandas==1.5.3\n</code></pre></li> </ol> <p>The first line installs the pyalgotrading library, while the subsequent lines install compatible versions of quantstats and pandas libraries. These are important dependencies that contribute to the functionality and analytical capabilities of pyalgotrading.</p>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#documentation","title":"Documentation:","text":"<p>To fully unleash the potential of pyalgotrading, dive into its comprehensive documentation. This documentation serves as your roadmap, offering detailed insights into the library's features, functions, and capabilities. The documentation is your go-to resource for understanding how to effectively harness the power of pyalgotrading. It includes:</p> <ul> <li>Comprehensive Guides: Step-by-step guides that walk you through various aspects of strategy development, deployment, integration, and analysis.</li> <li>Test with pyalgotrading: A detailed reference guide that provides information about each function, method, and module available in pyalgotrading.</li> <li>Code Examples: Real code snippets and examples that showcase how to implement specific strategies, functions, and techniques using pyalgotrading.</li> <li>Python Cookbook for AlgoTrading: A python cook book for Algotrading, explaining in depth about the strategy creation and execution using python.</li> </ul>"},{"location":"pyalgotrad/pyalgotrading_comprehensive_guide/#example-strategy","title":"Example Strategy:","text":"<p>For those who are new to algorithmic trading or pyalgotrading, exploring the included example strategies is a fantastic way to get started. These example strategies are pre-built trading scenarios that demonstrate different trading strategies and concepts. By studying and experimenting with these examples, you can gain a deeper understanding of how pyalgotrading functions and how strategies are constructed.</p> <p>Here's what you can do with the example strategies:</p> <ul> <li>Analyze Structure: Examine the code structure, including how strategies are defined, conditions are set, and actions are executed.</li> <li>Modify and Experiment: Once you're comfortable with the example strategies, tailor them to your preferences. Adjust parameters, conditions, and actions to see how these modifications affect trading outcomes.</li> <li>Learn Strategies: Each example strategy may represent a different trading approach, such as trend-following or mean-reversion. By studying these examples, you can learn about various trading strategies and their underlying principles.</li> </ul> <p>Remember that the example strategies serve as a foundation for your learning journey. As you become more familiar with the library, you can start building and customizing your own strategies based on your trading preferences and insights.</p> <p>In conclusion, the installation process gets you ready to start using pyalgotrading, while the documentation and example strategies empower you to explore the library's capabilities and apply them to real trading scenarios. Whether you're a newcomer or an experienced trader...</p>"},{"location":"pyalgotrad/python-build-view-results/","title":"Analytics in AlgoBulls Platform","text":""},{"location":"pyalgotrad/python-build-view-results/#how-to-view-the-results","title":"How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy.  Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Only Premium developer plans users will be able to view the strategy analytics values &amp; graphs.</p> <p>Analytics: In the analytics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p>"},{"location":"pyalgotrad/python-build-view-results/#stats","title":"Stats","text":"<p>In this section you can see the total returns, sharpe ratio, sortino ratio, volatility, Max Drawdown, Total wins or Loses, Total short or long trades, hit ratio, number of trades, average trades per day, max profit, max loss, average profit per winning trade, average loss per losing trade. </p>"},{"location":"pyalgotrad/python-build-view-results/#cummulative-returns","title":"Cummulative Returns","text":""},{"location":"pyalgotrad/python-build-view-results/#profit-loss-currency-or","title":"Profit &amp; Loss (Currency or %)","text":"<p>The trade by trade P&amp;L in Currency or Percentage.</p> <p></p>"},{"location":"pyalgotrad/python-build-view-results/#end-of-year-returns-plot","title":"End of Year Returns Plot (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#monthly-returns-histogram","title":"Monthly Returns Histogram (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#monthly-returns-heatmap","title":"Monthly Returns Heatmap (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#daily-returns","title":"Daily Returns (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#underwater-drawdown-plot","title":"Underwater Drawdown Plot (%)","text":""},{"location":"pyalgotrad/python-build-view-results/#pl-book","title":"P&amp;L Book","text":"<p>View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades.</p> <p></p>"},{"location":"pyalgotrad/python-build-view-results/#user-log","title":"User Log","text":"<p>Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance.</p> <p></p>"},{"location":"pyalgotrad/python-build-view-results/#order-history","title":"Order History","text":"<p>View the order state transition for every order placed by your strategy in depth. </p> <p></p>"},{"location":"pyalgotrad/python_packages/","title":"Python Packages and Requirements","text":""},{"location":"pyalgotrad/python_packages/#once-your-prerequisites-are-ready-you-need-to-make-sure-all-the-below-packages-are-installed-properly-in-your-environment","title":"Once your Prerequisites are ready, you need to make sure all the below packages are installed properly in your environment","text":"<ul> <li> <p>Pyalgotrading Package (version: latest):    This package has all the necessary classes to create strategies. For the SMA strategy, you will subclass your class from the StrategyBase class which is present in this package.    <pre><code>   pip3 install pyalgotrading\n</code></pre></p> </li> <li> <p>TA-Lib Package (version: 0.4.27):    This package encompasses all Technical Indicators used in Technical Analysis by strategists. You will need this package to compute Moving Average (SMA) for the example.</p> <pre><code>   python -m pip install TA-Lib\n</code></pre> <p>Warning</p> <ul> <li>If you face any error while installing this package, I recommend you to check their documentation and follow their steps for installation.</li> </ul> </li> </ul> <ul> <li>Pandas Package (version: 1.5.3):      This is a package used for data-manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series. This will help you to operate on the profit and loss data, it will also assist you to operate on historical data which will be fetched inside the strategy. <pre><code> pip3 install pandas==1.5.3\n</code></pre></li> </ul> <ul> <li>QuantStats Package (version: 0.0.59):    This library performs portfolio profiling, allowing quants and portfolio managers to understand their performance better by providing them with in-depth analytics and risk metrics. It is used to generate the plots to visualize and generate analytics of your returns.    <pre><code> pip3 install quantstats==0.0.59\n</code></pre></li> </ul>"},{"location":"pyalgotrad/requirements/","title":"Requirements","text":""},{"location":"pyalgotrad/requirements/#once-your-prerequisites-are-ready-you-need-to-make-sure-all-the-below-packages-are-installed-properly-in-your-environment","title":"Once your Prerequisites are ready, you need to make sure all the below packages are installed properly in your environment","text":"<ul> <li> <p>Pyalgotrading Package (version: latest):    This package has all the necessary classes to create strategies. For the SMA strategy, you will subclass your class from the StrategyBase class which is present in this package.    <pre><code>   pip3 install pyalgotrading\n</code></pre></p> </li> <li> <p>TA-Lib Package (version: 0.4.27):    This package encompasses all Technical Indicators used in Technical Analysis by strategists. You will need this package to compute Moving Average (SMA) for the example.</p> <pre><code>   python -m pip install TA-Lib\n</code></pre> <p>Warning</p> <ul> <li>If you face any error while installing this package, I recommend you to check their documentation and follow their steps for installation.</li> </ul> </li> </ul> <ul> <li>Pandas Package (version: 1.5.3):      This is a package used for data-manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series. This will help you to operate on the profit and loss data, it will also assist you to operate on historical data which will be fetched inside the strategy. <pre><code> pip3 install pandas==1.5.3\n</code></pre></li> </ul> <ul> <li>QuantStats Package (version: 0.0.59):    This library performs portfolio profiling, allowing quants and portfolio managers to understand their performance better by providing them with in-depth analytics and risk metrics. It is used to generate the plots to visualize and generate analytics of your returns.    <pre><code> pip3 install quantstats==0.0.59\n</code></pre></li> </ul>"},{"location":"pyalgotrad/select/","title":"Select your Strategy","text":""},{"location":"pyalgotrad/select/#previously","title":"Previously...","text":"<p>You have uploaded or saved a strategy by:</p> <ul> <li>Your strategy is already uploaded on the AlgoBulls account and you want to search or select it</li> </ul> <p>OR</p> <ul> <li>You have saved the strategy from the AlgoBulls Website</li> </ul>"},{"location":"pyalgotrad/select/#now","title":"Now...","text":"<p>You are now ready to select or import your strategy from your AlgoBulls account for Backtesting, Paper Trading and/or Real Trading. </p>"},{"location":"pyalgotrad/select/#before-you-start","title":"Before you start...","text":"<ul> <li>Make sure you have an active working AlgoBulls account ready to go!</li> <li>Open a Jupyter Notebook.</li> <li>If you have coded the strategy yourself and not used a ready strategy from the pyalgostrategypool package, then make sure your strategy file (.py) and the Jupyter Notebook are in the same folder. </li> </ul>"},{"location":"pyalgotrad/select/#lets-start","title":"Let's Start...","text":"<p>Run the following code snippets into the Jupyter Notebook one by one (or all together).</p>"},{"location":"pyalgotrad/select/#import-statements","title":"Import statements","text":"<pre><code>import inspect\nfrom pyalgotrading.algobulls import AlgoBullsConnection\n</code></pre>"},{"location":"pyalgotrad/select/#import-the-strategy-class","title":"Import the strategy class","text":"<p>Perform the below step either to import a ready strategy OR to import your own created strategy.</p> <p>Import a ready strategy <pre><code>from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder\n</code></pre></p> <p>Import your own strategy <pre><code>from strategy_sma_regular_order import StrategySMARegularOrder\n</code></pre></p>"},{"location":"pyalgotrad/select/#establish-a-connection-to-the-algobulls-platform","title":"Establish a connection to the AlgoBulls Platform","text":"<p><pre><code>algobulls_connection = AlgoBullsConnection()\nalgobulls_connection.get_authorization_url()\n</code></pre> The output of the above step is:</p> <p><code>Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login</code></p> <p>You will need to log in to your AlgoBulls account and fetch the access token from:</p> <p>Settings -&gt; General -&gt; Developer Options</p> <p>(See How)</p> <p>Once you have the access token, set it in the code as shown here:</p> <p><pre><code>algobulls_connection.set_access_token('4365817b795770ea31040a21ad29c8e78b63ad88')\n</code></pre> Replace the token you have copied with the token in the code above.</p>"},{"location":"pyalgotrad/select/#view-all-the-strategies-in-your-algobulls-account","title":"View all the strategies in your AlgoBulls Account","text":"<p>You can view all the strategy saved on your AlgoBulls account. <pre><code>all_strategies_df = algobulls_connection.get_all_strategies()\nprint(all_strategies_df)\n</code></pre></p>"},{"location":"pyalgotrad/select/#search-your-strategy","title":"Search your Strategy","text":"<ul> <li>Search your strategy using <code>strategy name</code>. Make sure you have the strategy with given name in your AlgoBulls Account.      <pre><code>    strategy_name = 'Exponential Moving Averages Crossover'\n    strategy_code, strategy_name = all_strategies_df.loc[all_strategies_df['strategyName'] == strategy_name].iloc[0]        \n</code></pre></li> <li>Search your strategy using <code>strategy code</code>. Make sure you have the strategy with given code in your AlgoBulls Account.      <pre><code>strategy_code = 'afd6214c5db94dbeae7502e861fa4ffc'\nstrategycode, strategyname = all_strategies_df.loc[all_strategies_df['strategyCode'] == strategy_code].iloc[0]\n</code></pre></li> </ul>"},{"location":"pyalgotrad/select/#whats-next","title":"What's Next...","text":"<p>You are now ready to test your uploaded strategy and perform Backtesting, Paper Trading and/or Real Trading with it.</p>"},{"location":"pyalgotrad/testing/","title":"Test your Strategy","text":""},{"location":"pyalgotrad/testing/#previously","title":"Previously...","text":"<p>You have uploaded your strategy to the AlgoBulls platform.</p>"},{"location":"pyalgotrad/testing/#now","title":"Now...","text":"<p>Using the uploaded strategy, you can now try: * Backtesting * Paper Trading * Real Trading </p>"},{"location":"pyalgotrad/testing/#before-you-start","title":"Before you start...","text":"<p>Open a Jupyter Notebook.</p> <p>The steps you will follow are:</p> <ol> <li>Establish a connection to the AlgoBulls Platform.</li> <li>Display all Strategies you have in your account.</li> <li>Select the SMA strategy.</li> <li>Optionally, print the strategy once.</li> <li>Select instrument(s).</li> <li>Submit/Run a Backtest, Paper Trade or Real Trade job.</li> <li>Check Job Status.</li> <li>Fetch Logs (even while the job is running).</li> <li>Fetch Reports. (PnL, Statistics, Order History)</li> </ol>"},{"location":"pyalgotrad/testing/#lets-start","title":"Let's Start...","text":"<p>Run the following code snippets into the Jupyter Notebook one by one (or all together).</p>"},{"location":"pyalgotrad/testing/#import-statements","title":"Import statements","text":"<pre><code>from pyalgotrading.algobulls import AlgoBullsConnection\nfrom datetime import datetime as dt\nfrom pyalgotrading.constants import *\n</code></pre>"},{"location":"pyalgotrad/testing/#establish-a-connection-to-the-algobulls-platform","title":"Establish a connection to the AlgoBulls Platform","text":"<p><pre><code>algobulls_connection = AlgoBullsConnection()\nalgobulls_connection.get_authorization_url()\n</code></pre> The output of the above step is:</p> <p><code>Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login</code></p> <p>You will need to log in to your AlgoBulls account and fetch the access token from:</p> <p>Settings -&gt; General -&gt; Developer Options</p> <p>(See How)</p> <p>Once you have the access token, set it in the code as shown here:</p> <pre><code>algobulls_connection.set_access_token('4365817b795770ea31040a21ad29c8e78b63ad88')\n</code></pre> <p>Replace the token you have copied with the token in the code above.</p>"},{"location":"pyalgotrad/testing/#display-all-strategies-in-your-account","title":"Display all strategies in your account","text":"<pre><code>all_strategies = algobulls_connection.get_all_strategies()\nall_strategies\n</code></pre> <p>An example of the output will be: </p>"},{"location":"pyalgotrad/testing/#select-the-sma-strategy","title":"Select the SMA strategy","text":"<p>Select the last entry of the <code>strategyCode</code> column and display it. <pre><code>strategy_code = all_strategies.iloc[-1]['strategyCode']\nstrategy_code\n</code></pre></p>"},{"location":"pyalgotrad/testing/#print-your-strategy-code","title":"Print your Strategy code","text":"<p>You can print your strategy code once to verify if this is the correct code. This step is optional.</p> <pre><code>strategy_details1 = algobulls_connection.get_strategy_details(strategy_code)\nprint(strategy_details1)\n</code></pre>"},{"location":"pyalgotrad/testing/#search-for-instruments-based-on-a-search-query","title":"Search for instruments (based on a search query)","text":"<p>Now display a few instruments with some keyword. The example below uses 'SBIN' as the keyword.</p> <pre><code>instruments = algobulls_connection.search_instrument('SBIN')\ninstruments\n</code></pre>"},{"location":"pyalgotrad/testing/#select-an-instrument","title":"Select an instrument","text":"<p>From the output, select the instrument on which you wish to test your strategy. For this example, select the first one. <pre><code>instrument = instruments[0]['value']\ninstrument\n</code></pre></p>"},{"location":"pyalgotrad/testing/#submit-a-job","title":"Submit a Job","text":"<p>Delete previous trades <pre><code>algobulls_connection.delete_previous_trades(strategy=strategy)\n</code></pre></p> <p>Set the parameters for the strategy <pre><code>parameters={\n    'timeperiod1': 5,\n    'timeperiod2': 12\n}\n</code></pre></p> <pre><code>vendor_details = {\n    'brokerName': '&lt;VENDOR_NAME&gt;',\n    'credentialParameters': {\n        'api_key': '&lt;API_KEY&gt;',\n        'secret_key': '&lt;SECRET_KEY&gt;'\n    }\n}\n</code></pre> <pre><code>broking_details = {\n    'brokerName': '&lt;BROKER_NAME&gt;',\n    'credentialParameters': {\n        'user_id': '&lt;USER_ID&gt;',\n        'api_key': '&lt;API_KEY&gt;',\n        'password': '&lt;PASSWORD&gt;'\n    }\n}\n</code></pre> <p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>algobulls_connection.backtest(\n        strategy=strategy_code,         # strategy code\n        start='2020-7-1 09:15 +0530',   # start date-time of strategy ('YYYY-MM-DD HH:MM z')\n        end='2020-7-7 15:30 +0530',     # end date-time of strategy ('YYYY-MM-DD HH:MM z')\n        instruments='NSE:SBIN',         # name of the instrument\n        lots=1,                         # number of lots per trade\n        parameters=parameters,          # parameters required for the strategy\n        candle='15 minutes',            # candle size eg : '1 Day', '1 hour', '3 minutes'\n        delete_previous_trades=True,    # delete the previous trades for papertrading (default is true),\n        initial_funds_virtual=10000,    # virtual funds allotted before the paper trading starts (default is 1e9)\n        vendor_details=vendor_details   # vendor's details for authentication and verification \n)\n</code></pre></p> <p>Paper Trading <pre><code>algobulls_connection.papertrade(\n        strategy=strategy_code,         # strategy code\n        start='09:15 +0530',            # start time of strategy (HH:MM z)     \n        end='15:30 +0530',              # end time of strategy (HH:MM z)\n        instruments='NSE:SBIN',         # name of the instrument\n        lots=1,                         # number of lots per trade\n        parameters=parameters,          # parameters required for the strategy\n        candle='15 minutes',            # candle size eg : '1 Day', '1 hour', '3 minutes'\n        delete_previous_trades=True,    # delete the previous trades for papertrading (default is true)\n        initial_funds_virtual=10000,    # virtual funds allotted before the paper trading starts (default is 1e9)\n        vendor_details=vendor_details   # vendor's details for authentication and verification \n)\n</code></pre></p> <p>Real Trading <pre><code>algobulls_connection.realtrade(\n        strategy=strategy_code,          # strategy code\n        start='09:15 +0530',             # start time of strategy (HH:MM z)     \n        end='15:30 +0530',               # end time of strategy (HH:MM z)\n        instruments='NSE:SBIN',          # name of the instrument\n        lots=1,                          # number of lots per trade\n        parameters=parameters,           # parameters required for the strategy\n        candle='15 minutes',             # candle size eg : '1 Day', '1 hour', '3 minutes'\n        broking_details=broking_details  # broker's details for authentication and verification \n)\n</code></pre></p>"},{"location":"pyalgotrad/testing/#fetch-job-status","title":"Fetch Job Status","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>algobulls_connection.get_backtesting_job_status(strategy_code)\n</code></pre></p> <p>Paper Trading <pre><code>algobulls_connection.get_papertrading_job_status(strategy_code)\n</code></pre></p> <p>Real Trading <pre><code>algobulls_connection.get_realtrading_job_status(strategy_code)\n</code></pre></p> <p>You can stop a submitted job anytime.</p>"},{"location":"pyalgotrad/testing/#stop-a-job","title":"Stop a Job","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>algobulls_connection.stop_backtesting_job(strategy_code)\n</code></pre></p> <p>Paper Trading <pre><code>algobulls_connection.stop_papertrading_job(strategy_code)\n</code></pre></p> <p>Real Trading <pre><code>algobulls_connection.stop_realtrading_job(strategy_code)\n</code></pre></p> <p>You can fetch the logs in the middle of a job to monitor the progress.</p>"},{"location":"pyalgotrad/testing/#fetch-logs-of-an-ongoingstoppedcompleted-job","title":"Fetch logs of an ongoing/stopped/completed job","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>logs = algobulls_connection.get_backtesting_logs(strategy_code, auto_update=True, display_logs_in_auto_update_mode=True)\nprint(logs)\n</code></pre></p> <p>Paper Trading <pre><code>logs = algobulls_connection.get_papertrading_logs(strategy_code)\nprint(logs)\n</code></pre></p> <p>Real Trading <pre><code>logs = algobulls_connection.get_realtrading_logs(strategy_code)\nprint(logs)\n</code></pre></p> <p>You can fetch the PnL report, statistics and order history for a job.</p>"},{"location":"pyalgotrad/testing/#fetch-pnl-reports","title":"Fetch PnL Reports","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>algobulls_connection.get_backtesting_report_pnl_table(strategy_code, show_all_rows=True)\n</code></pre></p> <p>Paper Trading <pre><code>algobulls_connection.get_papertrading_report_pnl_table(strategy_code, show_all_rows=True)\n</code></pre></p> <p>Real Trading <pre><code>algobulls_connection.get_realtrading_report_pnl_table(strategy_code, show_all_rows=True)\n</code></pre></p>"},{"location":"pyalgotrad/testing/#fetch-report-statistics","title":"Fetch Report Statistics","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>algobulls_connection.get_backtesting_report_statistics(\n    strategy_code,          # strategy code\n    mode='quantstats',      # package used to generate statistics\n    report='full',          # format of the report\n    html_dump=True          # save report as html file\n)\n</code></pre></p> <p>Paper Trading <pre><code>algobulls_connection.get_papertrading_report_statistics(\n    strategy_code,          # strategy code\n    mode='quantstats',      # package used to generate statistics\n    report='full',          # format of the report\n    html_dump=True          # save report as html file\n)\n</code></pre></p> <p>Real Trading <pre><code>algobulls_connection.get_realtrading_report_statistics(\n    strategy_code,          # strategy code\n    mode='quantstats',      # package used to generate statistics\n    report='full',          # format of the report\n    html_dump=True          # save report as html file\n)\n</code></pre></p>"},{"location":"pyalgotrad/testing/#fetch-order-history","title":"Fetch Order History","text":"<p>Click on each of the tabs to see the relevant code snippet.</p> <p>Backtesting <pre><code>order_history = algobulls_connection.get_backtesting_report_order_history(strategy_code)\nprint(order_history)\n</code></pre></p> <p>Paper Trading <pre><code>order_history = algobulls_connection.get_papertrading_report_order_history(strategy_code)\nprint(order_history)\n</code></pre></p> <p>Real Trading <pre><code>order_history = algobulls_connection.get_realtrading_report_order_history(strategy_code)\nprint(order_history)\n</code></pre></p> <p>Note</p> <ul> <li>Order History for Real Trading is not supported by brokers.</li> <li>Order History for Backtesting, Paper Trading and Real Trading is supported by the AlgoBulls Virtual Brokers.</li> </ul>"},{"location":"pyalgotrad/testing/#whats-next","title":"What's Next...","text":"<p>You can now explore more by creating and uploading more complex strategies.</p> <p>You can also check out the Strategy Coding Guidelines.</p>"},{"location":"pyalgotrad/upload/","title":"Upload your Strategy","text":""},{"location":"pyalgotrad/upload/#previously","title":"Previously...","text":"<p>You have created a strategy by:</p> <ul> <li>Coding the complete strategy from the Create page.</li> </ul> <p>OR</p> <ul> <li>Picking up a ready strategy from the pyalgostrategypool package.</li> </ul>"},{"location":"pyalgotrad/upload/#now","title":"Now...","text":"<p>You are now ready to upload your strategy into your AlgoBulls account for Backtesting, Paper Trading and/or Real Trading. </p>"},{"location":"pyalgotrad/upload/#before-you-start","title":"Before you start...","text":"<ul> <li>Make sure you have an active working AlgoBulls account ready to go!</li> <li>Open a Jupyter Notebook.</li> <li>If you have coded the strategy yourself and not used a ready strategy from the pyalgostrategypool package, then make sure your strategy file (.py) and the Jupyter Notebook are in the same folder. </li> </ul>"},{"location":"pyalgotrad/upload/#lets-start","title":"Let's Start...","text":"<p>Run the following code snippets into the Jupyter Notebook one by one (or all together).</p>"},{"location":"pyalgotrad/upload/#import-statements","title":"Import statements","text":"<pre><code>import inspect\nfrom pyalgotrading.algobulls import AlgoBullsConnection\n</code></pre>"},{"location":"pyalgotrad/upload/#import-the-strategy-class","title":"Import the strategy class","text":"<p>Perform the below step either to import a ready strategy OR to import your own created strategy.</p> <p>Import a ready strategy <pre><code>from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder\n</code></pre></p> <p>Import your own strategy <pre><code>from strategy_sma_regular_order import StrategySMARegularOrder\n</code></pre></p>"},{"location":"pyalgotrad/upload/#establish-a-connection-to-the-algobulls-platform","title":"Establish a connection to the AlgoBulls Platform","text":"<p><pre><code>algobulls_connection = AlgoBullsConnection()\nalgobulls_connection.get_authorization_url()\n</code></pre> The output of the above step is:</p> <p><code>Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login</code></p> <p>You will need to log in to your AlgoBulls account and fetch the access token from:</p> <p>Settings -&gt; General -&gt; Developer Options</p> <p>(See How)</p> <p>Once you have the access token, set it in the code as shown here:</p> <p><pre><code>algobulls_connection.set_access_token('4365817b795770ea31040a21ad29c8e78b63ad88')\n</code></pre> Replace the token you have copied with the token in the code above.</p>"},{"location":"pyalgotrad/upload/#print-your-strategy-code","title":"Print your Strategy code","text":"<p>You can print your strategy code once to verify if this is the correct code before uploading it to the platform. This step is optional. <pre><code>print(inspect.getsource(StrategySMARegularOrder))\n</code></pre></p>"},{"location":"pyalgotrad/upload/#upload-your-strategy_1","title":"Upload your Strategy","text":"<p>Upload your strategy as shown in the code below. <pre><code>algobulls_connection.create_strategy(StrategySMARegularOrder)\n</code></pre></p>"},{"location":"pyalgotrad/upload/#re-upload-your-strategy-after-modifications","title":"Re-upload your Strategy after modifications","text":"<p>If you are re-uploading your strategy after some changes, then use the <code>overwrite</code> switch as shown here. <pre><code>algobulls_connection.create_strategy(StrategySMARegularOrder, overwrite=True)\n</code></pre></p>"},{"location":"pyalgotrad/upload/#whats-next","title":"What's Next...","text":"<p>You are now ready to test your uploaded strategy and perform Backtesting, Paper Trading and/or Real Trading with it.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/","title":"Options Strategy Structure","text":"<p>Links</p> <ul> <li>List of Strategies</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#1-initial-steps","title":"1. Initial steps","text":"<p>i. Create a new strategy file with a unique file name.    eg: strategy_<code>&lt;developer_initials&gt;</code>_options_ema_crossover.py</p> <p>Note</p> <ul> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul> <p>ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.     eg: For the above strategy name the class name would be:         Strategy<code>&lt;developer_initials&gt;</code>OptionsEMACrossover(StrategyOptionsBaseV2)</p> <p>Note<ul> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy class is a child class of the StrategyBase.             </li> </ul> </p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p> <p>i. Strategy info:</p> <p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'OPTIONS'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' \n                    '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' \n                    '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may change for different strategies.</li> </ul> </p> </li> </ul> <p>ii. Parameter creation:</p> <p>Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE']\nself.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE']\nself._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE']\nself._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>iii. Parameter validation</p> <p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument: Checks a single parameter passed in it.</p> <p>Syntax:     check_argument(value to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk: Checks multiple parameters passed in a list </p> <p>Syntax:     check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>No of the strikes values are validated as follows:</p> <pre><code>no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')]\n\nfor no_of_strikes, text in no_of_strikes_list:\n    check_argument(no_of_strikes, 'extern_function', lambda x: 0 &lt;= x &lt;= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50')\n</code></pre> <p>Strike direction values are validated as follows:</p> <pre><code>strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')]\n\nfor strike_direction, text in strikes_direction_list:\n    check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM')\n</code></pre> <p>Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file.</p> <p>We define the below dictionary for <code>strike_direction</code>.</p> <pre><code>strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value}\n</code></pre> <p>Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value.</p> <pre><code>self.strike_direction_ce = strike_direction_map[self._strike_direction_ce]\nself.strike_direction_pe = strike_direction_map[self._strike_direction_pe]\n</code></pre> <p>iv. Start time and End time creation:</p> <p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <pre><code>try:\n    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n\ntry:\n    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> <p>v. Strategy variables:</p> <p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: self.main_order = None            # We save the entry order in this variable self.stoploss_order = None        # We save the corresponding stoploss exit order of the entry order in this variable</p> <p>We initialize the variables with a None value.</p> <pre><code>!!! Note\nThere could be more strategy variables required as per the strategy requirement.\n</code></pre>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p> <p>i. add_order: </p> <ul> <li>Stores the order object for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])</code></p> <p>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</p> <p>ii. get_orders: </p> <ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)</code></p> <p>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></p> <p>iii. remove_tags: </p> <ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_tags(tags=entry_key)</code></p> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags.</p> <p>iv. remove_order: </p> <ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_order(main_order)</code></p> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p> <p>v. get_internals: </p> <ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#5-child-instruments-calculation","title":"5. Child instruments calculation","text":"<p>i. Fetch the LTP of the base instrument (instrument in the YAML).</p> <p><code>ltp = self.broker.get_ltp(self.underlying_instrument)</code></p> <p>ii. Get the ATM ITM and OTM lists of the child instrument based on the LTP:</p> <p><code>self.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp)</code></p> <p>iii. Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument. </p> <p><code>child_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)</code></p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#6-entry-methods","title":"6. Entry Methods","text":"<p>i. strategy_select_instruments_for_entry:</p> <ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selectd_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul> <p>ii. strategy_enter_position:</p> <ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#7-exit-methods","title":"7. Exit Methods","text":"<p>i. strategy_select_instruments_for_exit:</p> <ul> <li> <p>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</p> </li> <li> <p>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</p> </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#8-other-common-methods","title":"8. Other common methods","text":"<p>There are other methods that are used in the strategy:</p> <p>i. check_and_place_stoploss_order:</p> <p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p> <p>ii. set_all_none:</p> <p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p> <p>iii. options_instruments_set_up_local</p> <p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. </p> <p>iv. get_child_instrument_details</p> <p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch a single child instrument based on the no of strikes and strike direction.</p>"},{"location":"pyalgotrad/strategy_guides/common_options_strategy/#9-cleanup","title":"9. Cleanup","text":"<p>i. Add comments and docstrings wherever possible to improve code readability.</p> <p>ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.**</p> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/","title":"Regular Strategy Structure","text":"<p>Links</p> <ul> <li>List of Strategies</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#1-initial-steps","title":"1. Initial steps","text":"<p>i. Create a new strategy file with a unique file name.    eg: strategy_<code>&lt;developer_initials&gt;</code>_futures_ema_crossover.py</p> <p>Note</p> <ul> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul> <p>ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.     eg: For the above strategy name the class name would be:         Strategy<code>&lt;developer_initials&gt;</code>FuturesEMACrossover(StrategyBase)</p> <p>Note<ul> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy is a child class of the StrategyBase class.</li> </ul> </p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p> <p>i. Strategy info:</p> <p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'FUTURES'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is FUTURES, REGULAR, or OPTIONS.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\\n                           '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may be different for different strategies.</li> </ul> </p> </li> </ul> <p>ii. Parameter creation:</p> <p>Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>iii. Parameter validation</p> <p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument: Checks a single parameter passed in it.</p> <p>Syntax:     check_argument(value to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk: Checks multiple parameters passed in a list </p> <p>Syntax:     check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>iv. Start time and End time creation:</p> <p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <pre><code>try:\n    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n\ntry:\n    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> <p>v. Strategy variables:</p> <p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <code>self.order_tag_manager = None</code> </p> <p>We initialize the variables with a None value.</p> <p>Note<p>There could be more strategy variables required as per the strategy requirement. </p> </p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p> <p>i. add_order: </p> <ul> <li>Stores the order object for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])</code></p> <p>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</p> <p>ii. get_orders: </p> <ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)</code></p> <p>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></p> <p>iii. remove_tags: </p> <ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_tags(tags=entry_key)</code></p> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags.</p> <p>iv. remove_order: </p> <ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_order(main_order)</code></p> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p> <p>v. get_internals: </p> <ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.   </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#5-entry-methods","title":"5. Entry Methods","text":"<p>i. strategy_select_instruments_for_entry:</p> <ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selected_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul> <p>ii. strategy_enter_position:</p> <ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#6-exit-methods","title":"6. Exit Methods","text":"<p>i. strategy_select_instruments_for_exit:</p> <ul> <li> <p>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</p> </li> <li> <p>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</p> </li> </ul>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#7-other-common-methods","title":"7. Other common methods","text":"<p>There are other methods that are used in the strategy:</p> <p> i. check_and_place_stoploss_order:</p> <p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p> <p>ii. set_all_none:</p> <p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p>"},{"location":"pyalgotrad/strategy_guides/common_regular_strategy/#8-cleanup","title":"8. Cleanup","text":"<p>i. Add comments and docstrings wherever possible to improve code readability.</p> <p>ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"pyalgotrad/strategy_guides/structure/","title":"Code Structure of Strategy","text":""},{"location":"pyalgotrad/strategy_guides/structure/#previously","title":"Previously...","text":"<p>You now have the necessary prerequisites installed and ready.</p>"},{"location":"pyalgotrad/strategy_guides/structure/#now","title":"Now...","text":"<p>This page describes the methods you will use to create your strategy.</p>"},{"location":"pyalgotrad/strategy_guides/structure/#lets-start","title":"Let's Start...","text":"<p>You have the following methods.</p>"},{"location":"pyalgotrad/strategy_guides/structure/#methods","title":"Methods","text":"<ol> <li><code>strategy_select_instruments_for_entry()</code> - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy,  the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument,  allowing you to decide whether an order is to be punched for that particular instrument or not.</li> <li><code>strategy_enter_position()</code> - You can now punch your order in this method for each instrument that you have selected for entry in the previous method.</li> <li><code>strategy_select_instruments_for_exit()</code> - Once a position is entered for a particular instrument, the backend core calls this method for those  instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that  particular instrument is to be exited or not.</li> <li><code>strategy_exit_position()</code> - You can now exit positions in this method for each instrument that you have selected for exit in the previous method.</li> </ol>"},{"location":"pyalgotrad/strategy_guides/structure/#supporting-methods","title":"Supporting Methods","text":"<p>You have the following supporting methods:</p> <ol> <li><code>__init__()</code> - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy.   </li> <li><code>initialize()</code> - This method is called every time the strategy starts for the first time as well as the start of every trading day.  You may set initial values for the set of variables that you have declared in the previous method. </li> <li><code>name()</code> - This method sets a unique name for your strategy.</li> <li><code>versions_supported()</code> - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you.</li> </ol>"},{"location":"pyalgotrad/strategy_guides/structure/#utility-functions","title":"Utility Functions","text":"<p>You have the following utility function to be used in this strategy :</p> <ol> <li><code>get_crossover_value()</code> - A utility method available which calculates the crossover value. </li> </ol> <p>Links</p> <ul> <li>Strategy Structure (regular)</li> <li>Strategy Structure (options)</li> <li>List of Strategies</li> </ul>"},{"location":"pyalgotrad/strategy_guides/structure/#flowchart","title":"Flowchart","text":"<p>Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.</p> <p></p>"},{"location":"pyalgotrad/strategy_guides/structure/#whats-next","title":"What's Next...","text":"<p>Checkout the strategy guides for building a Regular Strategy or Options Strategy</p>"},{"location":"python_build/","title":"Welcome to <code>Python Build</code> Documentation!","text":""},{"location":"python_build/#index","title":"Index","text":""},{"location":"python_build/#introduction","title":"Introduction:","text":"<ul> <li>Introduction</li> <li>Overview</li> </ul>"},{"location":"python_build/#setup-work-space","title":"Setup Work Space:","text":"<ul> <li>Get Started</li> </ul>"},{"location":"python_build/#strategy-creation-and-execution","title":"Strategy Creation and Execution:","text":"<ul> <li>Basic Structure of a Strategy</li> <li>Create your Strategy<ul> <li>Code Ready Templates</li> <li>Code New Strategy</li> <li>Regular Strategy</li> <li>Options Strategy</li> </ul> </li> <li>Configure and Execute your Strategy</li> </ul>"},{"location":"python_build/#analytics","title":"Analytics:","text":"<ul> <li>AlgoBulls Analytics</li> <li>pyalgotrading Analytics</li> </ul>"},{"location":"python_build/pyalgotrading_analytics/","title":"Pyalgotrading Analytics","text":""},{"location":"python_build/pyalgotrading_analytics/#metric-values-and-statistics","title":"Metric Values and Statistics:","text":""},{"location":"python_build/pyalgotrading_analytics/#cumulative-returns","title":"Cumulative Returns:","text":"<ul> <li>The Cumulative Returns chart illustrates how our strategy's returns value has evolved over time in percentage. </li> <li>Positive values indicate gains, while negatives reflect losses. Bigger positive returns are more favourable. </li> <li>Keep in mind, this chart focuses on gains and losses, excluding risk and timing considerations.</li> <li>There are 2 sub categories of cumulative returns chart depending on the scale we are using. One is normal scaled and other is log scaled </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#end-of-year-returns-eoy","title":"End of Year Returns (EoY):","text":"<ul> <li>The End of Year Returns chart showcases our strategy's annual performance as a percentage. </li> <li>It quantifies its overall performance, considering gains or losses throughout each year.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#distributions-of-monthly-returns-histogram","title":"Distributions of Monthly Returns (Histogram)","text":"<ul> <li>In the Monthly Returns Distribution Histogram, we see the frequency distribution of different levels of returns over consecutive months. </li> <li>This histogram helps us understand the range and patterns in monthly returns, shedding light on our strategy's volatility and performance trends.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#daily-returns","title":"Daily Returns:","text":"<ul> <li>The Daily Returns Chart portrays the percentage change in our strategy's returns between trading days. </li> <li>It provides insights into short-term volatility, trend analysis, and risk assessment.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#rolling-volatility-6-months","title":"Rolling Volatility (6 months)","text":"<ul> <li>A Rolling Volatility (6 months) Plot showcases the changing volatility of an investment over time using a rolling window of six months. </li> <li>This plot reveals how the investment's price fluctuations vary as the window moves across the dataset. </li> <li>It provides insights into short-term volatility patterns, helping investors understand how the investment's risk level evolves in response to different market conditions.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#rolling-sharpe-6-months","title":"Rolling Sharpe (6 months)","text":"<ul> <li>A Rolling Sharpe (6 months) Plot illustrates the dynamic changes in the Sharpe ratio over time using a rolling window of six months. </li> <li>The plot shows how the risk-adjusted performance of an investment fluctuates as the window moves through the dataset. </li> <li>This visualization helps investors understand how the Sharpe ratio varies with changing market conditions and provides insights into the investment's consistency and risk-return trade-offs over short-term periods.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#rolling-sortino-6-months","title":"Rolling Sortino (6 months)","text":"<ul> <li>A Rolling Sortino (6 months) Plot visualizes the variation in the Sortino ratio over time using a rolling window of six months. </li> <li>This plot demonstrates how the investment's risk-adjusted performance, considering only downside volatility, changes as the window progresses through the data. </li> <li>It offers insights into how the Sortino ratio evolves with market conditions, helping investors assess the investment's ability to generate favorable risk-adjusted returns over short-term intervals.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#worst-5-drawdown-periods","title":"Worst 5 Drawdown Periods","text":"<ul> <li>A Worst 5 Drawdown Periods plot displays the top five periods during which the strategy experienced the largest declines from peak to trough. </li> <li>This visualization helps strategists understand the most significant loss-making episodes in the strategy's run. </li> <li>It shows the magnitude and duration of these drawdowns, providing insights into the strategy's risk and potential vulnerabilities.     </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#underwater-plot","title":"Underwater Plot:","text":"<ul> <li>The Underwater Plot visually narrates our strategy's performance concerning its past peaks. </li> <li>It showcases how much our returns value has dropped from its highest point over time. </li> <li>This aids in visualising periods of drawdown and recovery, offering insights into historical risk and resilience.    </li> </ul>"},{"location":"python_build/pyalgotrading_analytics/#monthly-returns-heatmap","title":"Monthly Returns (Heatmap):","text":"<ul> <li>The Monthly Returns Heatmap offers a colour-coded view of our strategy's performance across months. </li> <li>Shades of green indicate positive returns, while shades of red signify losses. </li> <li>This visual tool helps spot trends and patterns, aiding in identifying strong and weak performance periods.    </li> </ul>"},{"location":"python_build/python-build-code-new/","title":"Code New Strategy","text":""},{"location":"python_build/python-build-code-new/#how-to-code-a-new-strategy","title":"How to code a new strategy?","text":"<p>If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section.</p> <p></p> <p>A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section.</p> <p></p> <p>Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view &amp; edit the strategy parameters.</p> <p>To test the behaviour and performance of the strategy, click on Save &amp; Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section.</p> <p>You can rename a strategy by clicking the edit symbol besides the strategy name. </p> <p></p>"},{"location":"python_build/python-build-code-ready-templates/","title":"Code Ready Templates","text":""},{"location":"python_build/python-build-code-ready-templates/#how-to-code-strategies-using-ready-templates","title":"How to code strategies using Ready Templates?","text":"<p>Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates click on More.</p> <p></p> <p>Click on the Code button placed in the bottom right corner of the selected template to view the strategy code.</p> <p></p> <p>You should now see the code editor, where you can start modifying the code as required.</p> <p></p> <p>To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies.</p> <p></p>"},{"location":"python_build/python-build-config-parameters/","title":"Configure and Execute your Strategy","text":""},{"location":"python_build/python-build-config-parameters/#how-to-configure-strategy-parameters-and-execute-strategy","title":"How to Configure Strategy Parameters and Execute Strategy ?","text":"<p>You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can view a strategy\u2019s parameters or edit these parameters too.</p> <p>To know more about the parameters, click here.</p> <p></p> <p>User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.</p> <p>Once Strategy and User Parameters are configured, you can follow these steps to execute your strategy.</p> <p>Follow these simple steps to test the strategy's performance</p> <p>Step 1</p> <p>After clicking Save &amp; Start, a pop-up window will appear.</p> <p></p> <p>Step 2</p> <p>In the customizations section choose Backtesting to back test or Paper Trading to Paper Trade a strategy.</p> <p>Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting you will need to put the start date and end date along with time.</p> <p></p> <p>In Paper Trading you only need to add the start and end time.</p> <p></p> <p>Step 3</p> <p>In the Strategy Configuration section, you can check the parameters added or modified by you.</p> <p>Step 4</p> <p>To begin testing the strategy, click on Execute.</p> <p></p> <p>Step 5</p> <p>Go to the Analytics section to see the returns and performance of strategy visualized.</p> <p>Note:</p> <p>The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy &amp; analyse the strategy results 24x7.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Go to the Logs section to see the step by step execution of strategy in logs.</p> <p></p> <p></p> <p>You can rename a strategy by clicking the edit symbol besides the strategy name.</p> <p></p>"},{"location":"python_build/python-build-getstarted/","title":"Get Started","text":""},{"location":"python_build/python-build-getstarted/#how-to-get-started-with-python-build","title":"How to get started with Python Build?","text":"<p>To start developing your own strategy, you must first activate a plan from the Plans &amp; Wallet section. Select the Developers option in the Explore Plans section and select a plan of your choice. There is currently one developer plans available:</p> <p></p> <ul> <li>Advanced Developer Plan: Develop your own Algorithmic Trading Strategy for Free along with Analytics support, concurrent Strategy Executions, Professional Support, and more.</li> </ul> <p>After selecting your plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use My Coded Strategies section to create your own strategies</p>"},{"location":"python_build/python-build-introduction/","title":"Python Build","text":""},{"location":"python_build/python-build-introduction/#introduction","title":"Introduction","text":"<p>Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infra so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak till you are satisfied with the performance. Get your strategy approved for live Trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic.</p> <p>Go to Build Strategy in the sidebar navigation and select Python Build to know more.</p> <p></p>"},{"location":"python_build/python-build-overview/","title":"Overview","text":""},{"location":"python_build/python-build-overview/#an-overview","title":"An overview","text":"<p>Running Strategies: This section shows how many strategies are currently active and running in your account. </p> <p>Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. </p> <p>Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies.</p> <p>Note:</p> <p>The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy &amp; analyse the strategy results 24x7.</p> <p>Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users.</p> <p>Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. </p> <p>Active Plan: This section displays the current plan active on your AlgoBulls account. </p> <p>Ready Templates: Ready-to-use templates that you can modify and test.</p> <p></p> <p>My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you.</p> <p></p> <p>Quick Help: Resources to help you code better.</p> <p></p>"},{"location":"python_build/python-build-view-results/","title":"Analytics in AlgoBulls Platform","text":""},{"location":"python_build/python-build-view-results/#how-to-view-the-results","title":"How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy.  Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Only Premium developer plans users will be able to view the strategy analytics values &amp; graphs.</p> <p>Analytics: In the analytics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p>"},{"location":"python_build/python-build-view-results/#stats","title":"Stats","text":"<p>In this section you can see the total returns, sharpe ratio, sortino ratio, volatility, Max Drawdown, Total wins or Loses, Total short or long trades, hit ratio, number of trades, average trades per day, max profit, max loss, average profit per winning trade, average loss per losing trade. </p>"},{"location":"python_build/python-build-view-results/#cummulative-returns","title":"Cummulative Returns","text":""},{"location":"python_build/python-build-view-results/#profit-loss-currency-or","title":"Profit &amp; Loss (Currency or %)","text":"<p>The trade by trade P&amp;L in Currency or Percentage.</p> <p></p>"},{"location":"python_build/python-build-view-results/#end-of-year-returns-plot","title":"End of Year Returns Plot (%)","text":""},{"location":"python_build/python-build-view-results/#monthly-returns-histogram","title":"Monthly Returns Histogram (%)","text":""},{"location":"python_build/python-build-view-results/#monthly-returns-heatmap","title":"Monthly Returns Heatmap (%)","text":""},{"location":"python_build/python-build-view-results/#daily-returns","title":"Daily Returns (%)","text":""},{"location":"python_build/python-build-view-results/#underwater-drawdown-plot","title":"Underwater Drawdown Plot (%)","text":""},{"location":"python_build/python-build-view-results/#pl-book","title":"P&amp;L Book","text":"<p>View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades.</p> <p></p>"},{"location":"python_build/python-build-view-results/#user-log","title":"User Log","text":"<p>Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance.</p> <p></p>"},{"location":"python_build/python-build-view-results/#order-history","title":"Order History","text":"<p>View the order state transition for every order placed by your strategy in depth. </p> <p></p>"},{"location":"python_build/python-build/","title":"Python Build","text":""},{"location":"python_build/python-build/#1-introduction","title":"1. Introduction","text":"<p>Now you can code your own strategy easily using our Python Build service! Begin coding your own strategy from scratch, or modify some of our ready-made templates to suit your needs. Get access to our state-of-the-art AlgoBulls Core Trading Engine, which automatically leverages our infra so that you can access the latest historical data to gauge the performance of your strategies. Tweak the various parameters of your strategy to choose the ideal instrument, indicator values, and profit loss percentages as per your needs! View the performance of your strategy using our visual analytics feature and continue to tweak till you are satisfied with the performance. Get your strategy approved for live Trading from our experts and deploy it on 30+ supported brokers without coding any broker integration logic.</p> <p>Go to Build Strategy in the sidebar navigation and select Python Build to know more.</p> <p></p>"},{"location":"python_build/python-build/#2-an-overview","title":"2. An overview","text":"<p>Running Strategies: This section shows how many strategies are currently active and running in your account. </p> <p>Strategies Saved: This displays the number of strategies saved in your AlgoBulls account. It also shows the number of maximum strategies that you can save as per your current plan. </p> <p>Execution Time Consumed: You can view the number of minutes that have been used for Backtesting or Paper Trading your strategies.</p> <p>Note:</p> <p>The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy &amp; analyse the strategy results 24x7.</p> <p>Analytics Support: This shows whether your analytics support is active. Analytics support is not available to free plan users.</p> <p>Professional Support: This section connects you to other professional support forums for additional support while developing the strategy. </p> <p>Active Plan: This section displays the current plan active on your AlgoBulls account. </p> <p>Ready Templates: Ready-to-use templates that you can modify and test.</p> <p></p> <p>My Coded Strategies: Strategies that have been coded and saved by you are displayed here. This includes new and modified strategies developed by you.</p> <p></p> <p>Quick Help: Resources to help you code better.</p> <p></p>"},{"location":"python_build/python-build/#3-how-to-get-started-with-python-build","title":"3. How to get started with Python Build?","text":"<p>To start developing your own strategy, you must first activate a plan from the Plans &amp; Wallet section. Select the Developers option in the Explore Plans section and select a plan of your choice. There are currently two developer plans available:</p> <p></p> <ul> <li> <p>Premium Developer Plan: Develop your own Algorithmic Trading Strategy with Analytics support, concurrent Strategy Executions, Professional Support, and more.</p> </li> <li> <p>Free Developer Plan: Develop your own Algorithmic Trading Strategy for Free.</p> </li> </ul> <p>After selecting your preferred plan, you will be able to begin coding. You can either edit the preloaded Ready templates or use My Coded Strategies section to create your own strategies</p>"},{"location":"python_build/python-build/#4-how-to-code-strategies-using-ready-templates","title":"4. How to code strategies using Ready Templates?","text":"<p>Select a template that you would like to modify from the Ready Template section. To view all the ready-to-use templates click on More.</p> <p></p> <p>Click on the Code button placed in the bottom right corner of the selected template to view the strategy code.</p> <p></p> <p>You should now see the code editor, where you can start modifying the code as required.</p> <p></p> <p>To save the strategy, click the Save button. This strategy will be added to your list of My coded strategies.</p> <p></p> <p>Follow these simple steps to test the strategy's performance</p> <p>Step 1</p> <p>After clicking Save &amp; Start, a pop-up window will appear.</p> <p></p> <p>Step 2</p> <p>In the customizations section choose Backtesting to back test or Paper Trading to Paper Trade a strategy.</p> <p>Select the duration option in the customizations section. Add the desired date and time, as well as the quantity/lots. In Backtesting you will need to put the start date and end date along with time.</p> <p></p> <p>In Paper Trading you only need to add the start and end time.</p> <p></p> <p>Step 3</p> <p>Once you scroll below, you will see the P&amp;L tracker. Switch the P&amp;L tracker ON and enter your desired profit and risk appetite. To keep things simple, you can also leave it turned off.</p> <p></p> <p>Step 4</p> <p>In the Configuration section, you can check the parameters added or modified by you.</p> <p>Step 5</p> <p>To begin testing the strategy, click on Execute.</p> <p></p> <p>Step 6</p> <p>Go to the Results section to see how the strategy has performed.</p> <p>Note:</p> <p>The use of Backtesting/Paper Trading is limited to one month. This would be available from Monday - Friday (excluding NSE holidays) from 9 AM to 11:30 PM. You can code your strategy &amp; analyse the strategy results 24x7.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>You can rename a strategy by clicking the edit symbol besides the strategy name.</p> <p></p> <p>Note:</p> <p>The Analytics &amp; Graph sections are only visible to premium plan users. If you are using a free plan, switch to a premium developer plan now.</p>"},{"location":"python_build/python-build/#5-how-to-view-the-results","title":"5. How to view the Results?","text":"<p>Once you start the strategy, it may take a while for it to complete the execution. You can Switch to the Results tab after you run your strategy.  Even if the strategy execution is not complete, you will still see intermediate results.</p> <p>Only Premium developer plans users will be able to view the strategy analytics values &amp; graphs.</p> <p>Statistics: In the statistics section, you can view a strategy\u2019s Stats &amp; various other metrics in the form of graphs like P&amp;L.</p> <p>i. Stats: In this section you can see the hit ratio, number of trades, average trades per day.</p> <p></p> <p>ii. P&amp;L (INR):  The trade by trade P&amp;L in INR.</p> <p></p> <p>iii. P&amp;L %: The trade by trade P&amp;L in percentage form.</p> <p></p> <p>iv. The Graph Tool</p> <p></p> <p>v. P&amp;L Book: View detailed trade by trade report. Premium users can analyse this data in the form of heatmaps for Gross Profit &amp; Loss, Trading Volume &amp; Total number of Trades.</p> <p></p> <p></p> <p></p> <p>vi. User Log:  Real time logs from strategy execution are displayed in this section. Use these logs to debug your strategy\u2019s behaviour and performance.</p> <p></p> <p>vii. Order History: View the order state transition for every order placed by your strategy in depth. </p> <p></p>"},{"location":"python_build/python-build/#6-how-to-code-a-new-strategy","title":"6. How to code a new strategy?","text":"<p>If you want to create your own strategy, click on the + Sign in the Code New Strategy option under the My Coded Strategies section.</p> <p></p> <p>A new blank code editor will open, allowing you to start coding your new strategy. You can check out the basic building blocks of a strategy here to help you with your code structure. After you've finished coding, click Save to save this strategy in the My Coded Strategies section.</p> <p></p> <p>Next, you need to configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can add, view &amp; edit the strategy parameters.</p> <p>To test the behaviour and performance of the strategy, click on Save &amp; Start and follow the directions given earlier. The performance of the strategy will soon be available in the Results section.</p> <p>You can rename a strategy by clicking the edit symbol besides the strategy name. </p> <p></p>"},{"location":"python_build/python-build/#7-how-to-configure-strategy-parameters","title":"7. How to Configure Strategy Parameters?","text":"<p>You can configure the strategy\u2019s parameters by clicking on the settings symbol in the top right corner of the code editor. In this section you can view a strategy\u2019s parameters or edit these parameters too.</p> <p>To know more about the parameters, click here.</p> <p></p> <p>User Parameters: In this section, you can customize/create your own parameters for the strategy. Click on +Add New Parameter to begin adding them. They should match with the parameters you have defined in your Python class.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/","title":"Options Strategy Structure","text":"<p>Links</p> <ul> <li>List of Strategies</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#1-initial-steps","title":"1. Initial steps","text":"<p>i. Create a new strategy file with a unique file name.    eg: strategy_<code>&lt;developer_initials&gt;</code>_options_ema_crossover.py</p> <p>Note</p> <ul> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul> <p>ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.     eg: For the above strategy name the class name would be:         Strategy<code>&lt;developer_initials&gt;</code>OptionsEMACrossover(StrategyOptionsBaseV2)</p> <p>Note<ul> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy class is a child class of the StrategyBase.             </li> </ul> </p>"},{"location":"python_build/strategy_guides/common_options_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p> <p>i. Strategy info:</p> <p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'OPTIONS'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' \n                    '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' \n                    '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may change for different strategies.</li> </ul> </p> </li> </ul> <p>ii. Parameter creation:</p> <p>Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE']\nself.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE']\nself._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE']\nself._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>iii. Parameter validation</p> <p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument: Checks a single parameter passed in it.</p> <p>Syntax:     check_argument(value to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk: Checks multiple parameters passed in a list </p> <p>Syntax:     check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>No of the strikes values are validated as follows:</p> <pre><code>no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')]\n\nfor no_of_strikes, text in no_of_strikes_list:\n    check_argument(no_of_strikes, 'extern_function', lambda x: 0 &lt;= x &lt;= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50')\n</code></pre> <p>Strike direction values are validated as follows:</p> <pre><code>strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')]\n\nfor strike_direction, text in strikes_direction_list:\n    check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM')\n</code></pre> <p>Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file.</p> <p>We define the below dictionary for <code>strike_direction</code>.</p> <pre><code>strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value}\n</code></pre> <p>Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value.</p> <pre><code>self.strike_direction_ce = strike_direction_map[self._strike_direction_ce]\nself.strike_direction_pe = strike_direction_map[self._strike_direction_pe]\n</code></pre> <p>iv. Start time and End time creation:</p> <p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <pre><code>try:\n    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n\ntry:\n    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> <p>v. Strategy variables:</p> <p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: self.main_order = None            # We save the entry order in this variable self.stoploss_order = None        # We save the corresponding stoploss exit order of the entry order in this variable</p> <p>We initialize the variables with a None value.</p> <pre><code>!!! Note\nThere could be more strategy variables required as per the strategy requirement.\n</code></pre>"},{"location":"python_build/strategy_guides/common_options_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"python_build/strategy_guides/common_options_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p> <p>i. add_order: </p> <ul> <li>Stores the order object for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])</code></p> <p>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</p> <p>ii. get_orders: </p> <ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)</code></p> <p>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></p> <p>iii. remove_tags: </p> <ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_tags(tags=entry_key)</code></p> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags.</p> <p>iv. remove_order: </p> <ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_order(main_order)</code></p> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p> <p>v. get_internals: </p> <ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#5-child-instruments-calculation","title":"5. Child instruments calculation","text":"<p>i. Fetch the LTP of the base instrument (instrument in the YAML).</p> <p><code>ltp = self.broker.get_ltp(self.underlying_instrument)</code></p> <p>ii. Get the ATM ITM and OTM lists of the child instrument based on the LTP:</p> <p><code>self.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp)</code></p> <p>iii. Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument. </p> <p><code>child_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)</code></p>"},{"location":"python_build/strategy_guides/common_options_strategy/#6-entry-methods","title":"6. Entry Methods","text":"<p>i. strategy_select_instruments_for_entry:</p> <ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selectd_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul> <p>ii. strategy_enter_position:</p> <ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#7-exit-methods","title":"7. Exit Methods","text":"<p>i. strategy_select_instruments_for_exit:</p> <ul> <li> <p>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</p> </li> <li> <p>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</p> </li> </ul>"},{"location":"python_build/strategy_guides/common_options_strategy/#8-other-common-methods","title":"8. Other common methods","text":"<p>There are other methods that are used in the strategy:</p> <p>i. check_and_place_stoploss_order:</p> <p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p> <p>ii. set_all_none:</p> <p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p> <p>iii. options_instruments_set_up_local</p> <p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. </p> <p>iv. get_child_instrument_details</p> <p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch a single child instrument based on the no of strikes and strike direction.</p>"},{"location":"python_build/strategy_guides/common_options_strategy/#9-cleanup","title":"9. Cleanup","text":"<p>i. Add comments and docstrings wherever possible to improve code readability.</p> <p>ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.**</p> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/","title":"Regular Strategy Structure","text":"<p>Links</p> <ul> <li>List of Strategies</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#1-initial-steps","title":"1. Initial steps","text":"<p>i. Create a new strategy file with a unique file name.    eg: strategy_<code>&lt;developer_initials&gt;</code>_futures_ema_crossover.py</p> <p>Note</p> <ul> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul> <p>ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.     eg: For the above strategy name the class name would be:         Strategy<code>&lt;developer_initials&gt;</code>FuturesEMACrossover(StrategyBase)</p> <p>Note<ul> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy is a child class of the StrategyBase class.</li> </ul> </p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p> <p>i. Strategy info:</p> <p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'FUTURES'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is FUTURES, REGULAR, or OPTIONS.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\\n                           '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may be different for different strategies.</li> </ul> </p> </li> </ul> <p>ii. Parameter creation:</p> <p>Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>iii. Parameter validation</p> <p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument: Checks a single parameter passed in it.</p> <p>Syntax:     check_argument(value to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk: Checks multiple parameters passed in a list </p> <p>Syntax:     check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>iv. Start time and End time creation:</p> <p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <pre><code>try:\n    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n\ntry:\n    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> <p>v. Strategy variables:</p> <p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <code>self.order_tag_manager = None</code> </p> <p>We initialize the variables with a None value.</p> <p>Note<p>There could be more strategy variables required as per the strategy requirement. </p> </p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p> <p>i. add_order: </p> <ul> <li>Stores the order object for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])</code></p> <p>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</p> <p>ii. get_orders: </p> <ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)</code></p> <p>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></p> <p>iii. remove_tags: </p> <ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_tags(tags=entry_key)</code></p> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags.</p> <p>iv. remove_order: </p> <ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_order(main_order)</code></p> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p> <p>v. get_internals: </p> <ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.   </li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#5-entry-methods","title":"5. Entry Methods","text":"<p>i. strategy_select_instruments_for_entry:</p> <ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selected_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul> <p>ii. strategy_enter_position:</p> <ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#6-exit-methods","title":"6. Exit Methods","text":"<p>i. strategy_select_instruments_for_exit:</p> <ul> <li> <p>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</p> </li> <li> <p>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</p> </li> </ul>"},{"location":"python_build/strategy_guides/common_regular_strategy/#7-other-common-methods","title":"7. Other common methods","text":"<p>There are other methods that are used in the strategy:</p> <p> i. check_and_place_stoploss_order:</p> <p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p> <p>ii. set_all_none:</p> <p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p>"},{"location":"python_build/strategy_guides/common_regular_strategy/#8-cleanup","title":"8. Cleanup","text":"<p>i. Add comments and docstrings wherever possible to improve code readability.</p> <p>ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"python_build/strategy_guides/structure/","title":"Code Structure of Strategy","text":""},{"location":"python_build/strategy_guides/structure/#previously","title":"Previously...","text":"<p>You now have the necessary prerequisites installed and ready.</p>"},{"location":"python_build/strategy_guides/structure/#now","title":"Now...","text":"<p>This page describes the methods you will use to create your strategy.</p>"},{"location":"python_build/strategy_guides/structure/#lets-start","title":"Let's Start...","text":"<p>You have the following methods.</p>"},{"location":"python_build/strategy_guides/structure/#methods","title":"Methods","text":"<ol> <li><code>strategy_select_instruments_for_entry()</code> - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy,  the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument,  allowing you to decide whether an order is to be punched for that particular instrument or not.</li> <li><code>strategy_enter_position()</code> - You can now punch your order in this method for each instrument that you have selected for entry in the previous method.</li> <li><code>strategy_select_instruments_for_exit()</code> - Once a position is entered for a particular instrument, the backend core calls this method for those  instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that  particular instrument is to be exited or not.</li> <li><code>strategy_exit_position()</code> - You can now exit positions in this method for each instrument that you have selected for exit in the previous method.</li> </ol>"},{"location":"python_build/strategy_guides/structure/#supporting-methods","title":"Supporting Methods","text":"<p>You have the following supporting methods:</p> <ol> <li><code>__init__()</code> - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy.   </li> <li><code>initialize()</code> - This method is called every time the strategy starts for the first time as well as the start of every trading day.  You may set initial values for the set of variables that you have declared in the previous method. </li> <li><code>name()</code> - This method sets a unique name for your strategy.</li> <li><code>versions_supported()</code> - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you.</li> </ol>"},{"location":"python_build/strategy_guides/structure/#utility-functions","title":"Utility Functions","text":"<p>You have the following utility function to be used in this strategy :</p> <ol> <li><code>get_crossover_value()</code> - A utility method available which calculates the crossover value. </li> </ol> <p>Links</p> <ul> <li>Strategy Structure (regular)</li> <li>Strategy Structure (options)</li> <li>List of Strategies</li> </ul>"},{"location":"python_build/strategy_guides/structure/#flowchart","title":"Flowchart","text":"<p>Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.</p> <p></p>"},{"location":"python_build/strategy_guides/structure/#whats-next","title":"What's Next...","text":"<p>Checkout the strategy guides for building a Regular Strategy or Options Strategy</p>"},{"location":"strategies/","title":"Index","text":""},{"location":"strategies/#check-out-our-developed-strategies","title":"Check out our developed Strategies","text":""},{"location":"strategies/#regular-strategies","title":"Regular Strategies:","text":"<ul> <li>Aroon Crossover</li> <li>Bollinger Bands</li> <li>EMA Crossover</li> <li>Inverse EMA Scalping</li> <li>Reverse RSI</li> <li>Stochastic Crossover</li> <li>VWAP Crossover</li> </ul>"},{"location":"strategies/#options-strategies","title":"Options Strategies:","text":"<ul> <li>Options Bear Call Ladder</li> <li>Options Bear Put Ladder</li> <li>Options Bull Call Ladder</li> <li>Options Bull Put Ladder</li> <li>Options Long Iron Butterfly</li> <li>Options Straddle</li> <li>Options Strangle</li> </ul>"},{"location":"strategies/aroon_crossover/","title":"Aroon Crossover","text":"<p>This is a trading strategy called \"Aroon Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Aroon indicator crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/aroon_crossover/#aroon-indicator","title":"Aroon Indicator","text":"<ul> <li> <p>In the stock market, Aroon refers to the Aroon indicator, which is a technical analysis tool used to measure the strength and direction of a trend. It consists of two lines, the Aroon-Up line and the Aroon-Down line.</p> </li> <li> <p>The Aroon-Up line measures the number of periods since the highest price within a given period, while the Aroon-Down line measures the number of periods since the lowest price within a given period. The Aroon indicator ranges from 0 to 100, with values closer to 100 indicating a strong trend and values closer to 0 indicating a weak or non-existent trend.</p> </li> <li> <p>Traders and investors use the Aroon indicator to identify potential trend reversals, assess the strength of a trend, and generate buy or sell signals. For example, when the Aroon-Up line crosses above the Aroon-Down line, it may suggest a bullish trend, while a cross below may indicate a bearish trend.</p> </li> <li> <p>It is important to note that the Aroon indicator is just one of many tools used in technical analysis, and its effectiveness can vary depending on market conditions and other factors. It is often used in conjunction with other indicators and analysis techniques to make informed trading decisions.</p> </li> </ul> Fig.1 - SPY candle chart (top), Aroon Indicator for that chart (bottom)"},{"location":"strategies/aroon_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy, called Aroon Crossover, implements a crossover strategy using the Aroon indicator. It generates entry and exit signals based on the crossover of Aroon Up and Aroon Down values.</p>"},{"location":"strategies/aroon_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD None greater than 0 The period for which we calculate the Aroon Value"},{"location":"strategies/aroon_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the Aroon Up and Aroon Down values for a given instrument based on the historical data. It uses the <code>talib.AROON</code> function from the Talib library to calculate the values. The method then determines the crossover of Aroon Up and Aroon Down and returns the corresponding entry or exit action.</p>"},{"location":"strategies/bollinger_bands/","title":"Bollinger Bands","text":"<p>This is a trading strategy called \"Bollinger Bands\" implemented in Python using the PyAlgoTrading library. The strategy is based on the bollinger bands indicator values.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/bollinger_bands/#bollinger-bands-indicator","title":"Bollinger Bands Indicator","text":"<p>Bollinger Bands consists of a middle band (typically a 20-day Simple Moving Average) and two bands that represent the upper and lower price boundaries based on standard deviations. The bands adjust dynamically with market volatility.</p> <p>Key points about Bollinger Bands:</p> <ul> <li>The middle band is a moving average, while the upper and lower bands are calculated by adding/subtracting standard deviations from the middle band.</li> <li>Bollinger Bands help assess price volatility and identify potential overbought or oversold market conditions.</li> <li>A narrowing of the bands (Bollinger Squeeze) suggests low volatility, often followed by increased volatility and potential price breakout.</li> <li>Touching or exceeding the upper band may indicate an overbought market, while touching or falling below the lower band may suggest an oversold market.</li> <li>Price reversals can be observed when the price moves from one band to the other.</li> <li>The upper and lower bands can act as dynamic support and resistance levels.</li> <li>Bollinger Bands are used in combination with other indicators and analysis techniques to make trading decisions. They are not a standalone strategy but provide valuable insights when combined with other tools like the RSI.</li> </ul> Fig.1 - SPY candle chart (top) with Bollinger Bands (purple), 20 day standard deviation graph (bottom)"},{"location":"strategies/bollinger_bands/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy, called Bollinger Bands, is an implementation of the Bollinger Bands indicator. It uses the Bollinger Bands values to compare with previous candle's OPEN, HIGH, LOW and CLOSE values and generate entry and exit signals for trading instruments.</p>"},{"location":"strategies/bollinger_bands/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD None greater than 0 Period (number of candles) by which Bollinger Bands are calculated STANDARD_DEVIATION None between 0 to 10 Standard deviation (in percent) for upper and lower band from the signal bands"},{"location":"strategies/bollinger_bands/#decision-calculation","title":"Decision Calculation","text":"<p>The <code>get_decision</code> method calculates the Bollinger Bands values for a given instrument based on the OHLC (Open, High, Low, Close) historical data. It uses the <code>talib.BBANDS</code> function from the Talib library to calculate the upper and lower bands. The method compares the previous candle's open, low, and close values with the upper and lower bands to determine the entry or exit action. If the conditions for a buy or sell signal are met, the corresponding action is returned.</p>"},{"location":"strategies/ema_crossover/","title":"EMA Crossover","text":"<p>This is a trading strategy called \"EMA Regular Order Strategy\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/ema_crossover/#ema-indicator","title":"EMA indicator","text":"<p>Exponential Moving Averages (EMAs) are a popular technical analysis tool used in the stock market. They are similar to Simple Moving Averages (SMAs), but they place greater emphasis on recent price data.</p> <p>Here is a summary of Exponential Moving Averages:</p> <ul> <li>An Exponential Moving Average is a type of moving average that assigns more weight to recent prices, making it more responsive to current market conditions.</li> <li>Unlike the SMA, which gives equal weight to all data points, the EMA assigns exponentially decreasing weights to older data points.</li> <li>The formula for calculating an EMA involves using a smoothing factor or multiplier that determines the weight given to the previous EMA value and the current price.</li> <li>The most common period used for EMAs is 12 and 26 days, representing short-term and long-term trends, respectively.</li> <li>EMAs are commonly used to identify trend direction, support and resistance levels, and potential entry or exit points.</li> <li>When the price crosses above the EMA, it may signal a bullish trend, while a cross below the EMA may suggest a bearish trend.</li> <li>The EMA is more responsive to price changes compared to the SMA, making it useful for short-term trading strategies.</li> <li>EMAs are often used in conjunction with other technical indicators, such as the Moving Average Convergence Divergence (MACD), to generate trading signals.</li> <li>Traders and investors use Exponential Moving Averages to smooth out price fluctuations, identify trend reversals, and determine potential support and resistance levels. They provide a visual representation of the average price over a specific period, with greater weight given to recent prices.</li> </ul> Fig.1 - IBM candle chart (top) with EMA (green) and SMA (red) lines"},{"location":"strategies/ema_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy, called EMA Regular Order Strategy, implements a crossover strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the crossover of two EMAs.</p>"},{"location":"strategies/ema_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD1 None greater than 0 Period (number of candles) by which EMA-1 is calculated TIME_PERIOD2 None greater than 0 Period (number of candles) by which EMA-2 is calculated"},{"location":"strategies/ema_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover value based on the two EMAs of the closing prices. It uses the <code>talib.EMA</code> function from the Talib library to calculate the EMAs. The method then determines the crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).</p>"},{"location":"strategies/inverse_ema_scalping/","title":"Inverse EMA Scalping","text":"<p>This is a trading strategy called \"Inverse EMA Scalping Regular Order Strategy\" implemented in Python using the PyAlgoTrading library. The strategy is based on the exponential moving average crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/inverse_ema_scalping/#what-is-inverse-ema","title":"What is Inverse EMA","text":"<p>Inverse EMA, also known as Reverse Exponential Moving Average (REMA), is a variation of the Exponential Moving Average (EMA) in the stock market. While the EMA gives more weight to recent price data, the Inverse EMA assigns more weight to older data points.</p> <p>Here is a summary of Inverse EMA:</p> <ul> <li>Inverse EMA is calculated by applying the EMA formula in reverse, giving greater weight to older data points and less weight to recent prices.</li> <li>Instead of smoothing out price fluctuations like the EMA, the Inverse EMA amplifies them, making it more responsive to historical data.</li> <li>The formula for calculating Inverse EMA is similar to the EMA, but it uses a different smoothing factor or multiplier that assigns higher weight to older data points.</li> <li>The Inverse EMA is primarily used to identify historical patterns and potential turning points in the market.</li> <li>When the price crosses above the Inverse EMA, it may suggest a potential reversal from a downtrend to an uptrend, and vice versa when the price crosses below the Inverse EMA.</li> <li>Inverse EMA is not as widely used as the EMA or other moving averages, and its applications may vary among traders and analysts.</li> <li>Inverse EMA is a less commonly used variation of the Exponential Moving Average. While the EMA is designed to provide a smoothed average of recent prices, the Inverse EMA emphasizes historical data, potentially highlighting significant turning points in the market. Traders and analysts who utilize the Inverse EMA may incorporate it into their technical analysis toolkit to complement other indicators and gain insights into price reversals and historical patterns.</li> </ul>"},{"location":"strategies/inverse_ema_scalping/#strategy-overview","title":"Strategy Overview","text":"<p>This strategy implements a scalping strategy using Exponential Moving Averages (EMA). It generates entry and exit signals based on the inverse crossover of two EMAs.</p>"},{"location":"strategies/inverse_ema_scalping/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description LARGER_TIME_PERIOD None greater than 0 Period (number of candles) by which large period EMA is calculated SMALLER_TIME_PERIOD None greater than 0 Period (number of candles) by which short period EMA is calculated"},{"location":"strategies/inverse_ema_scalping/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover value based on the inverse crossover of the two EMAs of the closing prices. It uses the <code>talib.EMA</code> function from the Talib library to calculate the EMAs. The method then determines the inverse crossover between the two EMAs and returns the corresponding value (-1, 0, or 1).</p>"},{"location":"strategies/options_bear_call_ladder/","title":"Options Bear Call Ladder","text":""},{"location":"strategies/options_bear_call_ladder/#options-bear-call-ladder","title":"Options Bear Call Ladder","text":"<p>This class implements the Options Bear Call Ladder strategy.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bear_call_ladder/#bear-call-ladder","title":"Bear Call Ladder","text":"<ul> <li> <p>In the stock market, an options bear call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bearish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions.</p> </li> <li> <p>To create a bear call ladder, an investor typically does the following:</p> <ol> <li>Sells a lower strike call option.</li> <li>Buys two higher strike call options.</li> <li>Sells a final even higher strike call option.</li> </ol> </li> <li> <p>The bear call ladder aims to generate a limited profit if the price of the underlying asset remains below the middle strike price at expiration. The strategy benefits from time decay and a moderate decrease in the price of the underlying asset.</p> </li> <li> <p>The maximum profit potential of the bear call ladder is achieved when the price of the underlying asset is below the middle strike price at expiration. If the price declines further, the profit potential remains limited. However, if the price rises above the higher strike price, the strategy can result in losses.</p> </li> <li> <p>The key feature of the bear call ladder is the combination of short call options, which generate premium income, and long call options, which provide protection against unlimited losses in case the price of the underlying asset rises sharply.</p> </li> <li> <p>Traders implementing the bear call ladder strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile. It's important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> <li> <p>Please be aware that options trading can be complex and involves significant risks. It is always recommended to consult with a qualified financial advisor or broker before engaging in options trading activities.</p> </li> </ul>"},{"location":"strategies/options_bear_call_ladder/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 0 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bear_put_ladder/","title":"Options Bear Put Ladder","text":""},{"location":"strategies/options_bear_put_ladder/#options-bear-put-ladder","title":"Options Bear Put Ladder","text":"<p>This is a template for the Options Bear Put Ladder strategy. The strategy involves the combination of buying and selling put options to profit from a downward price movement in the underlying asset. It utilizes multiple legs with different strike prices and transaction types to create a ladder-like structure.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bear_put_ladder/#bear-put-ladder","title":"Bear Put Ladder","text":"<ul> <li> <p>In the stock market, an options bear put ladder is a strategy that combines buying and selling put options with different strike prices to profit from a moderate bearish view on the underlying asset. It involves a mix of long and short put positions.</p> </li> <li> <p>To implement a bear put ladder strategy, an investor generally follows these steps:</p> <ol> <li>Buys a put option with a lower strike price.</li> <li>Sells two put options with higher strike prices.</li> <li>Buys a final put option with an even higher strike price.</li> </ol> </li> <li> <p>The goal of the bear put ladder is to generate a limited profit if the price of the underlying asset remains below the middle strike price at expiration. The strategy benefits from time decay and a moderate decline in the price of the underlying asset.</p> </li> <li> <p>The maximum profit potential is reached when the price of the underlying asset is below the middle strike price at expiration. If the price continues to decrease, the profit potential remains limited. However, if the price rises above the higher strike price, the strategy can result in losses.</p> </li> <li> <p>The bear put ladder strategy combines short put options to generate premium income and long put options to provide protection against significant losses in case the price of the underlying asset declines substantially.</p> </li> <li> <p>Traders implementing the bear put ladder strategy should consider factors such as the strike prices, premium costs, and expiration date to assess the risk-reward profile. It's crucial to have a comprehensive understanding of options trading and associated risks before employing this strategy in the stock market.</p> </li> <li> <p>Keep in mind that options trading can be complex and involves substantial risks. It is advisable to consult with a qualified financial advisor or broker before engaging in options trading activities.</p> </li> </ul>"},{"location":"strategies/options_bear_put_ladder/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 0 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bull_call_ladder/","title":"Options Bull Call Ladder","text":""},{"location":"strategies/options_bull_call_ladder/#options-bull-call-ladder","title":"Options Bull Call Ladder","text":"<p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bull_call_ladder/#bull-call-ladder","title":"Bull Call Ladder","text":"<ul> <li> <p>In the stock market, an options bull call ladder is a strategy that involves buying and selling call options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short call positions.</p> </li> <li> <p>To create a bull call ladder, an investor typically does the following:</p> <ol> <li>Buys a lower strike call option.</li> <li>Sells two higher strike call options.</li> <li>Buys a final even higher strike call option.</li> </ol> </li> <li> <p>The key feature of the bull call ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay.</p> </li> <li> <p>The profit potential of the bull call ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited.</p> </li> <li> <p>On the other hand, if the price of the underlying asset remains below the lower strike price or declines, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price.</p> </li> <li> <p>The bull call ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile.</p> </li> <li> <p>It is important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> </ul>"},{"location":"strategies/options_bull_call_ladder/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 4 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bull_put_ladder/","title":"Options Bull Put Ladder","text":""},{"location":"strategies/options_bull_put_ladder/#options-bull-put-ladder","title":"Options Bull Put Ladder","text":"<p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_bull_put_ladder/#bull-put-ladder","title":"Bull Put ladder","text":"<ul> <li> <p>In the stock market, an options bull put ladder is a strategy that involves buying and selling put options with different strike prices to profit from a moderate bullish outlook on the underlying asset. It is a complex strategy that combines both long and short put positions.</p> </li> <li> <p>To create a bull put ladder, an investor typically does the following:</p> <ol> <li>Sells a higher strike put option.</li> <li>Buys two lower strike put options.</li> <li>Sells a final even lower strike put option.</li> </ol> </li> <li> <p>The key feature of the bull put ladder is that it provides limited risk and potential for limited profit. The strategy is constructed in such a way that it can benefit from both a moderate rise in the price of the underlying asset and from time decay.</p> </li> <li> <p>The profit potential of the bull put ladder is highest if the price of the underlying asset rises to the level of the middle strike price at expiration. In this case, the investor can achieve the maximum profit. If the price of the underlying asset rises above the middle strike price, the profit potential is limited.</p> </li> <li> <p>On the other hand, if the price of the underlying asset remains above the higher strike price or increases, the strategy can result in losses. The maximum loss occurs if the price rises above the higher strike price.</p> </li> <li> <p>The bull put ladder is a moderately bullish strategy that aims to benefit from both time decay and the potential for a moderate increase in the price of the underlying asset. Traders implementing this strategy should carefully consider factors such as the strike prices, premium costs, and expiration date to assess their risk-reward profile.</p> </li> <li> <p>It is important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> </ul>"},{"location":"strategies/options_bull_put_ladder/#initialization","title":"Initialization","text":"<p>The <code>__init__</code> method initializes the strategy and accepts parameters for configuring the strategy. The parameters are:</p> Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 4 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_bull_put_ladder/#additional-notes","title":"Additional Notes","text":"<ul> <li> <p>The <code>transaction_type_map</code>, <code>tradingsymbol_suffix_map</code>, and <code>strike_direction_map</code> dictionaries are used for mapping transaction types, trading symbol suffixes, and strike directions, respectively.</p> </li> <li> <p>The strategy supports a single allowed expiry date, which can be modified for multiple expiry dates.</p> </li> <li> <p>The strategy uses the <code>get_options_instrument_with_strike_direction</code> method from the base class to fetch child instruments.</p> </li> <li> <p>The <code>initialize</code> method sets up the list of instruments processed for the day.</p> </li> <li> <p>The <code>options_instruments_set_up_local</code> method sets up the Call and Put Options instruments for a given base instrument.</p> </li> <li> <p>The <code>strategy_select_instruments_for_entry</code> method selects instruments for entry by setting up child instruments and appending them to the selected instruments list.</p> </li> <li> <p>The <code>strategy_enter_position</code> method</p> </li> </ul>"},{"location":"strategies/options_long_iron_butterfly/","title":"Options Long Iron Butterfly","text":""},{"location":"strategies/options_long_iron_butterfly/#options-long-iron-butterfly","title":"Options Long Iron Butterfly","text":"<p>This is a template for implementing the Options Long Iron Butterfly strategy in Python.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_long_iron_butterfly/#long-iron-butterfly","title":"Long Iron Butterfly","text":"<ul> <li> <p>In the stock market, an options long iron butterfly is a complex strategy that involves buying two options with the same expiration date but different strike prices. It combines elements of both a bullish and bearish strategy and is designed to profit from low volatility in the underlying asset.</p> </li> <li> <p>To create a long iron butterfly, an investor typically does the following:</p> <ol> <li>Buys an at-the-money (ATM) put option.</li> <li>Buys an ATM call option.</li> <li>Sells an out-of-the-money (OTM) put option with a lower strike price.</li> <li>Sells an OTM call option with a higher strike price.</li> </ol> </li> <li> <p>The key feature of the long iron butterfly is that the sold options (OTM put and OTM call) help offset the cost of the purchased options (ATM put and ATM call). This results in a limited-risk, limited-reward strategy.</p> </li> <li> <p>The strategy profits when the price of the underlying asset remains within a specific range, known as the \"profit zone.\" The profit zone is determined by the strike prices of the options involved in the strategy. If the price of the underlying asset is within this range at expiration, the investor can achieve the maximum profit.</p> </li> <li> <p>However, if the price of the underlying asset moves significantly beyond the profit zone, the strategy can result in losses. The maximum loss occurs if the price falls below the lower strike price or rises above the higher strike price.</p> </li> <li> <p>The long iron butterfly is commonly used when traders anticipate low volatility in the underlying asset. It is a neutral strategy that seeks to benefit from the passage of time and a decrease in implied volatility. Traders implementing this strategy should carefully analyze factors such as the strike prices, premium costs, and expiration date to determine their risk-reward profile.</p> </li> <li> <p>It is important to note that options trading involves risks, and traders should have a thorough understanding of the strategy and associated risks before employing it in the stock market.</p> </li> </ul>"},{"location":"strategies/options_long_iron_butterfly/#strategy-parameters","title":"Strategy Parameters","text":"<p>The strategy accepts the following parameters:</p> Name Default Value Expected Value Description LEG_ONE_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_ONE_TRADING_SYMBOL_SUFFIX 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_ONE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_ONE_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_TWO_TRANSACTION_TYPE 1 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_TWO_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_TWO_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_TWO_NUMBER_OF_STRIKES 0 greater than 0 Number of strikes for leg one. LEG_THREE_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_THREE_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_THREE_STRIKE_DIRECTION 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_THREE_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one. LEG_FOUR_TRANSACTION_TYPE 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] LEG_FOUR_TRADING_SYMBOL_SUFFIX 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] LEG_FOUR_STRIKE_DIRECTION 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] LEG_FOUR_NUMBER_OF_STRIKES 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_straddle/","title":"Options Straddle","text":""},{"location":"strategies/options_straddle/#options-straddle","title":"Options Straddle","text":"<p>This class represents the implementation of an options straddle trading strategy.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_straddle/#straddle-options","title":"Straddle Options","text":"<ul> <li> <p>In the stock market, an options straddle is a strategy where an investor simultaneously purchases a call option and a put option with the same strike price and expiration date on a particular underlying asset, such as a stock. The purpose of this strategy is to profit from significant price movements in the underlying asset, regardless of whether the price goes up or down.</p> </li> <li> <p>By using an options straddle, the investor is essentially betting on volatility rather than the direction of the price movement. If the price of the underlying asset experiences a substantial increase or decrease, either the call or put option will generate profits, offsetting any losses from the other option. The potential for profit is highest when there is a significant price swing, while the risk is limited to the cost of purchasing the options.</p> </li> <li> <p>This strategy is often employed when traders anticipate an upcoming event or announcement that could cause significant market volatility, such as earnings reports or regulatory decisions. The goal is to take advantage of the resulting price movement, regardless of whether it is upward or downward.</p> </li> <li> <p>It is important to note that options straddles can be risky as they require significant price movements to be profitable. If the price remains relatively stable, the trader may experience losses due to the cost of purchasing the options. Therefore, careful consideration of market conditions and risk management is crucial when implementing an options straddle strategy.</p> </li> </ul>"},{"location":"strategies/options_straddle/#parameters","title":"Parameters","text":"Name Default Value Expected Value Description _leg_one_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_one_tradingsymbol_suffix 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_one_strike_direction 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_one_number_of_strikes 0 greater than 0 Number of strikes for leg one. _leg_two_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_two_tradingsymbol_suffix 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_two_strike_direction 1 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_two_number_of_strikes 0 greater than 0 Number of strikes for leg one."},{"location":"strategies/options_strangle/","title":"Options Strangle","text":""},{"location":"strategies/options_strangle/#options-strangle","title":"Options Strangle","text":"<p>The <code>StrategyOptionsStrangle</code> class is a strategy template for trading options strangles. It is derived from the <code>StrategyOptionsBaseV2</code> class.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in an options strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/options_strangle/#strangle-options","title":"Strangle Options","text":"<ul> <li> <p>In the stock market, an options strangle is a strategy where an investor simultaneously buys or sells a call option and a put option on the same underlying asset but with different strike prices and the same expiration date. The purpose of this strategy is to profit from significant price volatility in the underlying asset.</p> </li> <li> <p>Unlike an options straddle, which involves purchasing options at the same strike price, an options strangle involves selecting different strike prices. Typically, the investor buys an out-of-the-money call option (with a strike price above the current market price) and an out-of-the-money put option (with a strike price below the current market price).</p> </li> <li> <p>The strategy aims to benefit from a significant price movement in either direction. If the price of the underlying asset moves significantly upwards, the call option can generate profits. Conversely, if the price moves significantly downwards, the put option can generate profits. The investor is essentially betting on increased price volatility rather than predicting the direction of the price movement.</p> </li> <li> <p>Options strangles are commonly used when traders anticipate a substantial price movement but are unsure about the direction. This strategy allows for potential profits in either an upward or downward market scenario. However, it is important to note that options strangles can involve higher risks, as the underlying asset's price must move significantly to offset the cost of purchasing both options.</p> </li> <li> <p>Traders employing options strangles should carefully consider factors such as the expected price volatility, the expiration date, and the costs associated with purchasing the options. Implementing risk management techniques and monitoring market conditions are essential when utilizing an options strangle strategy.</p> </li> </ul>"},{"location":"strategies/options_strangle/#parameters","title":"Parameters","text":"<p>The following parameters can be set in the Parameters Configuration Pane:</p> Name Default Value Expected Value Description _leg_one_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_one_tradingsymbol_suffix 1 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_one_strike_direction 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_one_number_of_strikes 2 greater than 0 Number of strikes for leg one. _leg_two_transaction_type 2 1 or 2 Transaction type for leg one. [BUY: 1, SELL: 2] _leg_two_tradingsymbol_suffix 2 1 or 2 Trading symbol suffix for leg one. [CE: 1,  PE: 2] _leg_two_strike_direction 2 0, 1 or 2 Strike direction for leg one. [ITM: 0, ATM: 1,  OTM: 2] _leg_two_number_of_strikes 2 greater than 0 Number of strikes for leg one."},{"location":"strategies/reverse_rsi/","title":"Reverse RSI","text":"<p>This is a trading strategy called \"Reverse RSI\" implemented in Python using the PyAlgoTrading library. The strategy is based on the relative strength index indicator.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/reverse_rsi/#relative-strength-index","title":"Relative Strength Index","text":"<p>RSI stands for Relative Strength Index, and it is a popular technical indicator used in the stock market to analyze the strength and momentum of a price trend. The RSI provides insights into whether a stock is overbought or oversold and can help identify potential trend reversals.</p> <p>Here is a summary of RSI in the stock market:</p> <ul> <li>The Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements.</li> <li>It compares the magnitude of recent gains to recent losses over a specified period, typically 14 days, and generates a value between 0 and 100.</li> <li>The RSI is calculated using a formula that involves averaging the upward price movements (gains) and the downward price movements (losses) over the chosen period.</li> <li>A high RSI value (typically above 70) indicates that a stock is overbought, meaning it may have experienced a significant price increase and could be due for a correction or pullback.</li> <li>Conversely, a low RSI value (typically below 30) suggests that a stock is oversold, indicating it may have experienced a significant price decline and could be poised for a potential rebound or upward move.</li> <li>Traders often use RSI as a tool to identify potential trend reversals, as extreme RSI readings (above 70 or below 30) can signal a potential change in the direction of the price trend.</li> <li>Additionally, traders may look for bullish or bearish divergences between the RSI and the price chart, which can provide further indications of a potential trend reversal.</li> <li>The RSI is just one tool among many in technical analysis, and it is often used in conjunction with other indicators and analysis techniques to make more informed trading decisions.</li> </ul> <p>Overall, the Relative Strength Index (RSI) is a widely used indicator in the stock market to assess the strength and momentum of price movements. It helps traders identify overbought and oversold conditions, as well as potential trend reversals, which can assist in making trading decisions.</p> Fig.1 - MCD candle chart (top) and RSI plot (bottom)"},{"location":"strategies/reverse_rsi/#strategy-overview","title":"Strategy Overview","text":"<p>The Reverse RSI strategy is a trading strategy based on the Relative Strength Index (RSI) indicator. It generates entry and exit signals based on the reverse crossover of the RSI values from specified overbought and oversold levels.</p>"},{"location":"strategies/reverse_rsi/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description TIME_PERIOD None greater than 0 Period (number of candles) by which RSI is calculated OVERBOUGHT_VALUE None greater than 0 RSI value above which stocks are considered over-bought OVERSOLD_VALUE None greater than 0 RSI value below which stocks are considered over-sold"},{"location":"strategies/reverse_rsi/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover values for the RSI indicator using historical data of the instrument. It compares the RSI values with the overbought and oversold levels to determine the entry and exit actions. The method returns the crossover values for oversold and overbought levels.</p>"},{"location":"strategies/stochastic_crossover/","title":"Stochastic Crossover","text":"<p>This is a trading strategy called \"Stochastic Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the Stochastic indicator crossover.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/stochastic_crossover/#stochastic-oscillator-indicator","title":"Stochastic Oscillator Indicator","text":"<p>In the stock market, Stochastic refers to the Stochastic Oscillator, which is a popular technical indicator used to analyze price momentum and identify potential trend reversals. The Stochastic Oscillator compares the closing price of a security to its price range over a specific period of time. It consists of two lines, %K and %D, and generates values between 0 and 100.</p> <p>Here is a summary of the Stochastic Oscillator in the stock market:</p> <ul> <li>The Stochastic Oscillator measures the relationship between a security's closing price and its price range over a chosen period.</li> <li>The indicator consists of two lines: %K and %D. %K represents the current closing price relative to the price range, while %D is a smoothed average of %K.</li> <li>The Stochastic Oscillator is bound between 0 and 100. Readings above 80 are typically considered overbought, suggesting a potential price decline or correction. Readings below 20 are often considered oversold, indicating a potential price increase or rebound.</li> <li>Traders use the Stochastic Oscillator to identify potential trend reversals, as overbought or oversold conditions can indicate a possible change in the direction of the price trend.</li> <li>The indicator also generates bullish or bearish divergences, where the price trend and the Stochastic lines move in opposite directions, which can signal a potential trend reversal.</li> <li>The Stochastic Oscillator has various trading strategies associated with it, such as crossovers, overbought/oversold levels, and divergences, which traders use to make buy or sell decisions.</li> <li>It is important to note that the Stochastic Oscillator is a lagging indicator, meaning it may not provide precise timing for trade entries or exits. Therefore, it is often used in conjunction with other indicators and analysis techniques to confirm signals and improve the accuracy of trading decisions.</li> <li>Overall, the Stochastic Oscillator is a widely used technical indicator in the stock market that helps traders assess price momentum, identify overbought and oversold conditions, and spot potential trend reversals. By analyzing the relationship between the closing price and price range, traders can gain insights into potential buying or selling opportunities.</li> </ul> Fig.1 - IBM candle chart (top) with Stochastic Fast (bottom)  Fig.2 - QQQQ candle chart (top) with Stochastic Fast (bottom 1), Stochastic Slow (bottom 2) and Full Stochastic (bottom 3)"},{"location":"strategies/stochastic_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>The strategy follows a simple rule based on the Stochastic indicator crossover. When the Stochastic indicator's %K line crosses above the %D line, a buy signal is generated. Conversely, when the %K line crosses below the %D line, a sell signal is generated. The strategy aims to capture potential trend reversals.</p>"},{"location":"strategies/stochastic_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>The following parameters can be configured for the strategy:</p> Name Default Value Expected Value Description FASTK_PERIOD or PERIOD None greater than 0 The period for the fast %K line of the Stochastic indicator. SLOWK_PERIOD or SMOOTH_K_PERIOD None greater than 0 The period for the slow %K line of the Stochastic indicator. SLOWD_PERIOD or SMOOTH_D_PERIOD None greater than 0 The period for the slow %D line of the Stochastic indicator."},{"location":"strategies/stochastic_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the crossover values for the Slow-K and Slow-D of Stochastic indicator using historical data of the instrument. The method returns the crossover values between slow-K and slow-D.</p>"},{"location":"strategies/vwap_crossover/","title":"VWAP Crossover","text":"<p>This is a trading strategy called \"VWAP Crossover\" implemented in Python using the PyAlgoTrading library. The strategy is based on the crossover of the VWAP (Volume Weighted Average Price) indicator.</p> <p>Links</p> <ul> <li>Strategy Code (.py)</li> <li>Strategy Structure (common methods used in a regular strategy)</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/vwap_crossover/#vwap-indicator","title":"VWAP indicator","text":"<p>In the stock market, VWAP stands for Volume-Weighted Average Price. VWAP is a trading indicator that calculates the average price at which a particular stock or security has traded throughout the day, taking into account both the price and the volume of each trade.</p> <p>Here is a summary of VWAP in the stock market:</p> <ul> <li>VWAP is calculated by multiplying the price of each trade by the corresponding volume and then summing up these values over a specific time period. The total value is divided by the cumulative volume to obtain the average price.</li> <li>The volume-weighted aspect of VWAP gives more weight to trades with higher volume, reflecting the significance of larger trades in the overall average price calculation.</li> <li>VWAP is typically calculated on an intraday basis, such as the trading day or a specific session, and resets at the start of each new period.</li> <li>Traders and investors use VWAP as a benchmark to assess whether their own trades are executed at a better or worse price compared to the average market price. It helps evaluate the quality of their execution and determine if they are buying or selling at a favorable price.</li> <li>VWAP is commonly used by institutional traders who execute large orders as it helps them minimize market impact and avoid unfavorable executions. By comparing their execution price to VWAP, they can assess their performance and adjust their trading strategies accordingly.</li> <li>In addition to being used as a benchmark, VWAP is also employed as a trading strategy. Some traders use VWAP as a reference point for making buy or sell decisions. For example, if the current price is above VWAP, it may be considered bullish, while a price below VWAP could be seen as bearish.</li> <li>VWAP is often displayed as a line on intraday price charts, allowing traders to visually compare the current price to the average price. It can provide insights into the market's overall sentiment and potential support or resistance levels.</li> <li>It is important to note that VWAP is a lagging indicator since it is based on historical data. Therefore, it is often used in combination with other indicators and analysis techniques to validate trade signals and make informed trading decisions.</li> <li>Overall, VWAP is a widely used indicator in the stock market that provides a volume-weighted average price, serving as a benchmark for evaluating trade execution quality and as a reference point for trading decisions. By considering both price and volume, VWAP offers insights into market dynamics and helps traders assess their performance relative to the average market price.</li> </ul> Fig.1 - IBM candle chart (top) with VWAP line  (Blue), Volume chart with SMA line"},{"location":"strategies/vwap_crossover/#strategy-overview","title":"Strategy Overview","text":"<p>The strategy follows a simple rule based on the crossover of the VWAP indicator. When the price crosses above the VWAP, a buy signal is generated, and when the price crosses below the VWAP, a sell signal is generated. The strategy aims to capture potential trend reversals based on the VWAP.</p>"},{"location":"strategies/vwap_crossover/#strategy-parameters","title":"Strategy Parameters","text":"<p>No specific strategy parameters are mentioned in the code. </p>"},{"location":"strategies/vwap_crossover/#crossover-calculation","title":"Crossover Calculation","text":"<p>The <code>get_crossover_value</code> method calculates the VWAP from historical data and the crossover values for the VWAP of the instrument. The method returns the crossover values between close of hist data and vwap.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/","title":"Options Strategy Structure","text":"<p>Links</p> <ul> <li>List of Strategies</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#1-initial-steps","title":"1. Initial steps","text":"<p>i. Create a new strategy file with a unique file name.    eg: strategy_<code>&lt;developer_initials&gt;</code>_options_ema_crossover.py</p> <p>Note</p> <ul> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul> <p>ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.     eg: For the above strategy name the class name would be:         Strategy<code>&lt;developer_initials&gt;</code>OptionsEMACrossover(StrategyOptionsBaseV2)</p> <p>Note<ul> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy class is a child class of the StrategyBase.             </li> </ul> </p>"},{"location":"strategies/strategy_guides/common_options_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p> <p>i. Strategy info:</p> <p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'OPTIONS'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as and when there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is a FUTURES strategy or an OPTIONS strategy.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES \\n(1) \\n(1) STRIKES_DIRECTION_CE' \n                    '\\n(1) STRIKES_DIRECTION_PE \\n(1) NO_OF_STRIKES_AWAY_CE \\n(1) NO_OF_STRIKES_AWAY_PE \\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO' \n                    '\\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 15, err_message=f'Need 15 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may change for different strategies.</li> </ul> </p> </li> </ul> <p>ii. Parameter creation:</p> <p>Next, we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.no_of_strikes_away_ce = self.strategy_parameters['NO_OF_STRIKES_AWAY_CE']\nself.no_of_strikes_away_p = self.strategy_parameters['NO_OF_STRIKES_AWAY_PE']\nself._strike_direction_ce = self.strategy_parameters['STRIKES_DIRECTION_CE']\nself._strike_direction_pe = self.strategy_parameters['STRIKES_DIRECTION_PE']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>iii. Parameter validation</p> <p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument: Checks a single parameter passed in it.</p> <p>Syntax:     check_argument(value to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk: Checks multiple parameters passed in a list </p> <p>Syntax:     check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>No of the strikes values are validated as follows:</p> <pre><code>no_of_strikes_list = [(self.no_of_strikes_away_ce, 'NO_OF_STRIKES_AWAY_CE'), (self.no_of_strikes_away_pe, 'NO_OF_STRIKES_AWAY_PE')]\n\nfor no_of_strikes, text in no_of_strikes_list:\n    check_argument(no_of_strikes, 'extern_function', lambda x: 0 &lt;= x &lt;= 50 and isinstance(x, int), err_message=f'{text} should be an integer with possible values between 0 to 50')\n</code></pre> <p>Strike direction values are validated as follows:</p> <pre><code>strikes_direction_list = [(self._strike_direction_ce, 'STRIKE_DIRECTION_CE'), (self._strike_direction_pe, 'STRIKE_DIRECTION_PE')]\n\nfor strike_direction, text in strikes_direction_list:\n    check_argument(strike_direction, 'extern_function', lambda x: x in [0, 1, 2] and isinstance(x, int), err_message=f'{text} should be an integer with possible values - 0: ITM or 1: ATM or 2: OTM')\n</code></pre> <p>Once all the parameters are validated we calculate the actual value of the strike direction from the strike direction values given in the strategy YAML file.</p> <p>We define the below dictionary for <code>strike_direction</code>.</p> <pre><code>strike_direction_map = {0: OptionsStrikeDirection.ITM.value, 1: OptionsStrikeDirection.ATM.value, 2: OptionsStrikeDirection.OTM.value}\n</code></pre> <p>Then we create new variables for strike direction that save the value as ATM, ITM, and OTM based on the YAML parameter value.</p> <pre><code>self.strike_direction_ce = strike_direction_map[self._strike_direction_ce]\nself.strike_direction_pe = strike_direction_map[self._strike_direction_pe]\n</code></pre> <p>iv. Start time and End time creation:</p> <p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <pre><code>try:\n    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n\ntry:\n    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> <p>v. Strategy variables:</p> <p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: self.main_order = None            # We save the entry order in this variable self.stoploss_order = None        # We save the corresponding stoploss exit order of the entry order in this variable</p> <p>We initialize the variables with a None value.</p> <pre><code>!!! Note\nThere could be more strategy variables required as per the strategy requirement.\n</code></pre>"},{"location":"strategies/strategy_guides/common_options_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"strategies/strategy_guides/common_options_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p> <p>i. add_order: </p> <ul> <li>Stores the order object for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])</code></p> <p>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</p> <p>ii. get_orders: </p> <ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)</code></p> <p>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></p> <p>iii. remove_tags: </p> <ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_tags(tags=entry_key)</code></p> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in order tags.</p> <p>iv. remove_order: </p> <ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_order(main_order)</code></p> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p> <p>v. get_internals: </p> <ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#5-child-instruments-calculation","title":"5. Child instruments calculation","text":"<p>i. Fetch the LTP of the base instrument (instrument in the YAML).</p> <p><code>ltp = self.broker.get_ltp(self.underlying_instrument)</code></p> <p>ii. Get the ATM ITM and OTM lists of the child instrument based on the LTP:</p> <p><code>self.options_instruments_set_up_local(self.underlying_instrument, tradingsymbol_suffix, ltp)</code></p> <p>iii. Select a child instrument from the lists of ATM, ITM, and OTM based on the strike direction and no of strikes given for the child instrument. </p> <p><code>child_instrument = self.get_child_instrument_details(self.underlying_instrument, tradingsymbol_suffix, strike_direction, no_of_strikes)</code></p>"},{"location":"strategies/strategy_guides/common_options_strategy/#6-entry-methods","title":"6. Entry Methods","text":"<p>i. strategy_select_instruments_for_entry:</p> <ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create a <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selectd_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul> <p>ii. strategy_enter_position:</p> <ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#7-exit-methods","title":"7. Exit Methods","text":"<p>i. strategy_select_instruments_for_exit:</p> <ul> <li> <p>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</p> </li> <li> <p>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</p> </li> </ul>"},{"location":"strategies/strategy_guides/common_options_strategy/#8-other-common-methods","title":"8. Other common methods","text":"<p>There are other methods that are used in the strategy:</p> <p>i. check_and_place_stoploss_order:</p> <p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p> <p>ii. set_all_none:</p> <p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p> <p>iii. options_instruments_set_up_local</p> <p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch the ATM, ITM, and OTM lists of the child instruments based on the LTP of the base instrument. </p> <p>iv. get_child_instrument_details</p> <p>This method is called in the <code>strategy_select_instruments_for_entry</code> to fetch a single child instrument based on the no of strikes and strike direction.</p>"},{"location":"strategies/strategy_guides/common_options_strategy/#9-cleanup","title":"9. Cleanup","text":"<p>i. Add comments and docstrings wherever possible to improve code readability.</p> <p>ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.**</p> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/","title":"Regular Strategy Structure","text":"<p>Links</p> <ul> <li>List of Strategies</li> <li>Strategy Design (workflow of a strategy)</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#1-initial-steps","title":"1. Initial steps","text":"<p>i. Create a new strategy file with a unique file name.    eg: strategy_<code>&lt;developer_initials&gt;</code>_futures_ema_crossover.py</p> <p>Note</p> <ul> <li>Add the initials of your name after the word strategy in the strategy file name so that it becomes easier to identify the developer who developed the strategy and also helps with a unique strategy name.</li> <li>Make sure that the file name is in lowercase and that each word is separated with an underscore '_' as shown above.</li> </ul> <p>ii. Create a class with the same name as the file name, and make sure the first letter of each word is in uppercase and the initials should be in uppercase as well.     eg: For the above strategy name the class name would be:         Strategy<code>&lt;developer_initials&gt;</code>FuturesEMACrossover(StrategyBase)</p> <p>Note<ul> <li>If the class name includes indicator names like EMA, SMA, and VWAP the name should be in uppercase in the class name but not in the file name.</li> <li>Every strategy is a child class of the StrategyBase class.</li> </ul> </p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#2-init-method","title":"2. Init method","text":"<p>This method gets called only once when the strategy is started.</p> <p>i. Strategy info:</p> <p>In the init method add the <code>super().__init__(*args, **kwargs)</code> and add the below lines.</p> <pre><code>VERSION = strategy_version \nCLIENT = client_name\nSTRATEGY_TYPE = 'FUTURES'\n\nself.logger.info(f'\\n{\"#\" * 40}\\nSTRATEGY VERSION: {VERSION}\\n{\"#\" * 40}')\nself.logger.debug(f'\\n{\"#\" * 60}\\nSTRATEGY TYPE: {STRATEGY_TYPE} | CLIENT: {CLIENT}\\n{\"#\" * 60}')\n</code></pre> <ul> <li> <p>VERSION: This is the strategy version, the initial version is 3.3.1 as there are fixes/updates/changes in the strategy the version should be updated to 3.3.2, and so on.</p> </li> <li> <p>CLIENT: Name of the client.</p> </li> <li> <p>STRATEGY_TYPE: Whether the strategy is FUTURES, REGULAR, or OPTIONS.</p> </li> </ul> <p>We print this information in the next line, so whenever we run the strategy this information is displayed in the logs.</p> <p>We save the parameter string in the parameter_string variable and check if the length of the parameter_string matches the number of parameters in the strategy's YAML file.</p> <p>eg:</p> <pre><code>parameter_string = '\\n(1) FRESH_ORDER_CANDLE \\n(1) START_TIME_HOURS \\n(1) START_TIME_MINUTES \\n(1) END_TIME_HOURS \\n(1) END_TIME_MINUTES ' \\\n                           '\\n(1) EMA_PERIOD_ONE \\n(1) EMA_PERIOD_TWO \\n(1) TARGET_PERCENTAGE \\n(1) STOPLOSS_PERCENTAGE \\n(1) STOPLOSS_RANGE \\n(1) STOPLOSS_ORDER_COUNT_ALLOWED'\n\ncheck_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> <ul> <li> <p>parameter_string: This string contains all the strategy parameters as shown above.</p> </li> <li> <p>We check if the number of parameters matches those in the strategy YAML file.</p> <p>Note<ul> <li>The parameter names and the number of parameters may be different for different strategies.</li> </ul> </p> </li> </ul> <p>ii. Parameter creation:</p> <p>Next we assign the parameter values to the class variables of the same name as the parameters but in the lowercase format, as shown below:</p> <p>eg: <pre><code>self.fresh_order_candle = self.strategy_parameters['FRESH_ORDER_CANDLE']\nself.start_time_hours = self.strategy_parameters['START_TIME_HOURS']\nself.start_time_minutes = self.strategy_parameters['START_TIME_MINUTES']\nself.end_time_hours = self.strategy_parameters['END_TIME_HOURS']\nself.end_time_minutes = self.strategy_parameters['END_TIME_MINUTES']\nself.ema_period_one = self.strategy_parameters['EMA_PERIOD_ONE']\nself.ema_period_two = self.strategy_parameters['EMA_PERIOD_TWO']\nself.target_percentage = self.strategy_parameters['TARGET_PERCENTAGE']\nself.stoploss_percentage = self.strategy_parameters['STOPLOSS_PERCENTAGE']\nself.stoploss_range = self.strategy_parameters['STOPLOSS_RANGE']\nself.stoploss_order_count_allowed = self.strategy_parameters['STOPLOSS_ORDER_COUNT_ALLOWED']\n</code></pre></p> <p>iii. Parameter validation</p> <p>We validate each parameter's value according to the strategy requirement. The following methods can be used to validate the parameter values:</p> <ul> <li> <p>check_argument: Checks a single parameter passed in it.</p> <p>Syntax:     check_argument(value to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: check_argument(self.strategy_parameters, 'extern_function', lambda x: len(x) &gt;= 11, err_message=f'Need 11 parameters for this strategy: {parameter_string}')\n</code></pre> </li> <li> <p>check_argument_bulk: Checks multiple parameters passed in a list </p> <p>Syntax:     check_argument_bulk(list of values to be checked, 'extern_function', validating condition or method, error_message)</p> <pre><code>eg: is_nonnegative_int_arg_list = [self.start_time_hours, self.start_time_minutes, self.end_time_hours, self.end_time_minutes]\ncheck_argument_bulk(is_nonnegative_int_arg_list, 'extern_function', is_nonnegative_int, 'Value should be &gt;=0')\n</code></pre> </li> <li> <p>is_nonnegative_int: Checks whether the value is greater than or equal to zero.</p> </li> <li> <p>is_positive_int_or_float: Checks whether the value is greater than zero and is an integer or a float value.</p> </li> <li> <p>is_positive_int: Checks whether the value is greater than zero and is an integer value.</p> </li> <li> <p>is_nonnegative_int_or_float: Checks whether the value is greater than or equal to zero and is an integer or a float value.</p> </li> </ul> <p>iv. Start time and End time creation:</p> <p>Add the below code to calculate the strategy start time and end time, from the start time and end time parameters in the strategy YAML file.</p> <pre><code>try:\n    self.candle_start_time = time(hour=self.start_time_hours, minute=self.start_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting start hours and minutes... EXITING')\n    raise SystemExit\n\ntry:\n    self.candle_end_time = time(hour=self.end_time_hours, minute=self.end_time_minutes)\nexcept ValueError:\n    self.logger.fatal('Error converting end time hours and minutes... EXITING')\n    raise SystemExit\n</code></pre> <p>v. Strategy variables:</p> <p>We create our own strategy variables other than the strategy parameter variables which will be used throughout the strategy.</p> <p>eg: <code>self.order_tag_manager = None</code> </p> <p>We initialize the variables with a None value.</p> <p>Note<p>There could be more strategy variables required as per the strategy requirement. </p> </p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#3-initialize-method","title":"3. Initialize method","text":"<p>Unlike the <code>init method</code>, this method gets called every day at the beginning of the day once the strategy is started.</p> <p>Here the strategy variables that were initialized as None are again defined as dictionaries/lists except for the <code>self.order_tag_manager</code>.  Create a reference for <code>OrderTagManager</code> as shown below:</p> <p><code>self.order_tag_manager = OrderTagManager</code> </p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#4-ordertagmanager","title":"4. OrderTagManager","text":"<p>The <code>self.order_tag_manager</code> is used to store/remove the entry/exit orders. The <code>self.order_tag_manager</code> has the following methods:</p> <p>i. add_order: </p> <ul> <li>Stores the order object for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.add_order(_order, tags=[base_inst_str, entry_key])</code></p> <p>Here the <code>_order</code> is the order object stored inside the <code>OrderTagManager</code> for the tags <code>base_inst_str</code> and <code>entry_key</code>.</p> <p>ii. get_orders: </p> <ul> <li>Retrieve the order(s) for the given tags.</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.get_orders(tags=[base_inst_str, BrokerExistingOrderPositionConstants.ENTER, entry_key], ignore_errors=True)</code></p> <p>Here the order object retrieved from the <code>OrderTagManager</code> for the tags <code>base_inst_str, BrokerExistingOrderPositionConstants.ENTER</code> and <code>entry_key</code></p> <p>iii. remove_tags: </p> <ul> <li>Removes the tags stored in the <code>OrderTagManager</code> along with the orders related stored in that tag</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_tags(tags=entry_key)</code></p> <p>Here the <code>entry_key</code> tag is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>When the tag is removed the order objects stored in that tag are also removed but the same order objects would still be present in the order tags.</p> <p>iv. remove_order: </p> <ul> <li>Remove the order(s) from the <code>OrderTagManager</code> for the given tag(s).</li> </ul> <p>eg:</p> <p><code>self.order_tag_manager.remove_order(main_order)</code></p> <p>Here the <code>main_order</code> order object is removed from the <code>OrderTagManager</code>.</p> <p>Note</p> <p>The order object will be removed from all the tags ta</p> <p>v. get_internals: </p> <ul> <li>Returns the values i.e. both the entry and exit orders stored inside the tags list.   </li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#5-entry-methods","title":"5. Entry Methods","text":"<p>i. strategy_select_instruments_for_entry:</p> <ul> <li> <p>In this method we process each instrument in the instruments bucket, if there is some entry condition to be checked then we create an <code>get_entry_decision</code> method  that calculates the entry condition like a crossover or compares the latest value of the OHLC data or indicator data.</p> </li> <li> <p>When the order has to be placed we add the <code>instrument</code> to <code>selected_instruments_bucket</code> and additional data related to the instrument that will be required while placing to the <code>sideband_info</code>. This information is passed to the <code>strategy_enter_position</code> method</p> </li> </ul> <p>ii. strategy_enter_position:</p> <ul> <li>Here is where we actually place the entry order for which we calculate the quantity for the order to be placed. If the order is placed successfully we save the order in a class variable such that we can access the order object via the variable in the exit methods.</li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#6-exit-methods","title":"6. Exit Methods","text":"<p>i. strategy_select_instruments_for_exit:</p> <ul> <li> <p>This method is called before the entry methods because in the case of delivery strategy we want to resume and exit previous day orders before we can place new entry orders.</p> </li> <li> <p>Here we place stoploss exit orders, target exit orders, and check for exit conditions for the open entry orders.</p> </li> </ul>"},{"location":"strategies/strategy_guides/common_regular_strategy/#7-other-common-methods","title":"7. Other common methods","text":"<p>There are other methods that are used in the strategy:</p> <p> i. check_and_place_stoploss_order:</p> <p>This method is called in the <code>strategy_select_instruments_for_exit</code> when our entry order is open, and we want to place a stoploss exit order for the same.</p> <p>ii. set_all_none:</p> <p>This method is called in the <code>strategy_exit_position</code> when our entry order has exited, and we want to remove the order object from the <code>self.main_order</code> variable.</p>"},{"location":"strategies/strategy_guides/common_regular_strategy/#8-cleanup","title":"8. Cleanup","text":"<p>i. Add comments and docstrings wherever possible to improve code readability.</p> <p>ii. Once the strategy is completed perform O-I-L on the strategy code and remove unwanted imports, variables, and methods before delivering the code.</p> <p>To know more about a strategy from our given template, simply check the first line of comment in the code of that specific strategy. You can even access them here in <code>Strategies</code> Section</p>"},{"location":"strategies/strategy_guides/structure/","title":"Code Structure of Strategy","text":""},{"location":"strategies/strategy_guides/structure/#previously","title":"Previously...","text":"<p>You now have the necessary prerequisites installed and ready.</p>"},{"location":"strategies/strategy_guides/structure/#now","title":"Now...","text":"<p>This page describes the methods you will use to create your strategy.</p>"},{"location":"strategies/strategy_guides/structure/#lets-start","title":"Let's Start...","text":"<p>You have the following methods.</p>"},{"location":"strategies/strategy_guides/structure/#methods","title":"Methods","text":"<ol> <li><code>strategy_select_instruments_for_entry()</code> - You may want to run your strategy for multiple instruments. When you pass those instruments to the strategy,  the backend core calls this method for each instrument one by one, every candle time. This allows you to write decision-making code for each instrument,  allowing you to decide whether an order is to be punched for that particular instrument or not.</li> <li><code>strategy_enter_position()</code> - You can now punch your order in this method for each instrument that you have selected for entry in the previous method.</li> <li><code>strategy_select_instruments_for_exit()</code> - Once a position is entered for a particular instrument, the backend core calls this method for those  instruments one by one, every candle time. This allows you to write decision-making code for each instrument, allowing you to decide whether that  particular instrument is to be exited or not.</li> <li><code>strategy_exit_position()</code> - You can now exit positions in this method for each instrument that you have selected for exit in the previous method.</li> </ol>"},{"location":"strategies/strategy_guides/structure/#supporting-methods","title":"Supporting Methods","text":"<p>You have the following supporting methods:</p> <ol> <li><code>__init__()</code> - This is the constructor method used in every strategy. You can perform sanity checks here for each parameter passed as an argument to the strategy. You can also declare the set of variables that you may need for your strategy.   </li> <li><code>initialize()</code> - This method is called every time the strategy starts for the first time as well as the start of every trading day.  You may set initial values for the set of variables that you have declared in the previous method. </li> <li><code>name()</code> - This method sets a unique name for your strategy.</li> <li><code>versions_supported()</code> - This method sets the version of AlgoBulls Platform on which this strategy is certified tested successfully by you.</li> </ol>"},{"location":"strategies/strategy_guides/structure/#utility-functions","title":"Utility Functions","text":"<p>You have the following utility function to be used in this strategy :</p> <ol> <li><code>get_crossover_value()</code> - A utility method available which calculates the crossover value. </li> </ol> <p>Links</p> <ul> <li>Strategy Structure (regular)</li> <li>Strategy Structure (options)</li> <li>List of Strategies</li> </ul>"},{"location":"strategies/strategy_guides/structure/#flowchart","title":"Flowchart","text":"<p>Once you create your own strategy or use a ready strategy from the pyalgostrategypool package, this is how it works internally on the AlgoBulls Core Trading Engine.</p> <p></p>"},{"location":"strategies/strategy_guides/structure/#whats-next","title":"What's Next...","text":"<p>Checkout the strategy guides for building a Regular Strategy or Options Strategy</p>"}]}