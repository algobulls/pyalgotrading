{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pyalgotrading Documentation! \u00b6 Visit the Tutorial \u00b6 Tutorial: Introduction Prerequisites Basic Structure of a Strategy Program Example Upload your Strategy Test your Strategy To browse the source docs, use the below links \u00b6 Packages algobulls / broker / instrument / order / strategy / utils / Modules: constants pyalgotrading \u00b6 Official Python Package for Algorithmic Trading APIs powered by AlgoBulls! Features \u00b6 Powered by the AlgoBulls Platform Everything related to Algorithmic Trading Strategies! Create & upload strategies on the AlgoBulls Platform Free pool of Strategies are available separately at pyalgostrategypool ! Support for all 150+ Technical Indicators provided by TA-Lib Support for multiple candlesticks patterns - Japanese OHLC, Renko, Heikin-Ashi, Linebreak Support for multiple candle inntervals - 1 minute, 3 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 1 day. Support for Regular Orders and Bracket Orders Support for MARKET , LIMIT , STOPLOSS , STOPLOSS-LIMIT orders Support for INTRADAY and DELIVERY orders Support for Backtesting Support for Paper Trading Support for Real Trading Support for multiple brokers for Real Trading Currently supported brokers - Zerodha Coming soon - AliceBlue, Mastertrust More on the way! Real-time Logs for Backtesting, Paper Trading, Real Trading Multiple real-time Reports available for Backtesting, Paper Trading and Real Trading - Profit-n-Loss report (PnL report) Statistics of (PnL report) Order History for each order with state transitions & timestamps Plot Candlestick charts using plotly.py Backtesting, Paper Trading and Real Trading can be performed on the same strategy code base! Documentation \u00b6 You can find the docs here . Python \u00b6 Python Support: Python 3.6+ . Python Requirements: See requirements.txt . We recommend you to use the latest version of Python (v3.8+) to enjoy better performance benefits, especially for pandas. (For Python 3.6, the latest supported Pandas version is v0.25.3. For Python 3.8, the latest supported version is v1.0.x) Installation \u00b6 Package can be easily installed using pip - pip install pyalgotrading Support / Getting Help \u00b6 Bug Reporting / New Feature Request : Please create a new issue here on GitHub. Discussion Forum : Coming Soon! Additional Support : If none of the above help, please contact pushpak@algobulls.com . Contribution Guidelines \u00b6 Here\u2019s how we suggest you go about proposing a change to this project: Fork this project to your account. Create a branch for the change you intend to make. Make your changes to your fork. Send a pull request from your fork\u2019s branch to our master branch. Changelog \u00b6 See CHANGELOG.md . License \u00b6 See LICENSE .","title":"Home"},{"location":"#welcome-to-pyalgotrading-documentation","text":"","title":"Welcome to pyalgotrading Documentation!"},{"location":"#visit-the-tutorial","text":"Tutorial: Introduction Prerequisites Basic Structure of a Strategy Program Example Upload your Strategy Test your Strategy","title":"Visit the Tutorial"},{"location":"#to-browse-the-source-docs-use-the-below-links","text":"Packages algobulls / broker / instrument / order / strategy / utils / Modules: constants","title":"To browse the source docs, use the below links"},{"location":"#pyalgotrading","text":"Official Python Package for Algorithmic Trading APIs powered by AlgoBulls!","title":"pyalgotrading"},{"location":"#features","text":"Powered by the AlgoBulls Platform Everything related to Algorithmic Trading Strategies! Create & upload strategies on the AlgoBulls Platform Free pool of Strategies are available separately at pyalgostrategypool ! Support for all 150+ Technical Indicators provided by TA-Lib Support for multiple candlesticks patterns - Japanese OHLC, Renko, Heikin-Ashi, Linebreak Support for multiple candle inntervals - 1 minute, 3 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 1 day. Support for Regular Orders and Bracket Orders Support for MARKET , LIMIT , STOPLOSS , STOPLOSS-LIMIT orders Support for INTRADAY and DELIVERY orders Support for Backtesting Support for Paper Trading Support for Real Trading Support for multiple brokers for Real Trading Currently supported brokers - Zerodha Coming soon - AliceBlue, Mastertrust More on the way! Real-time Logs for Backtesting, Paper Trading, Real Trading Multiple real-time Reports available for Backtesting, Paper Trading and Real Trading - Profit-n-Loss report (PnL report) Statistics of (PnL report) Order History for each order with state transitions & timestamps Plot Candlestick charts using plotly.py Backtesting, Paper Trading and Real Trading can be performed on the same strategy code base!","title":"Features"},{"location":"#documentation","text":"You can find the docs here .","title":"Documentation"},{"location":"#python","text":"Python Support: Python 3.6+ . Python Requirements: See requirements.txt . We recommend you to use the latest version of Python (v3.8+) to enjoy better performance benefits, especially for pandas. (For Python 3.6, the latest supported Pandas version is v0.25.3. For Python 3.8, the latest supported version is v1.0.x)","title":"Python"},{"location":"#installation","text":"Package can be easily installed using pip - pip install pyalgotrading","title":"Installation"},{"location":"#support-getting-help","text":"Bug Reporting / New Feature Request : Please create a new issue here on GitHub. Discussion Forum : Coming Soon! Additional Support : If none of the above help, please contact pushpak@algobulls.com .","title":"Support / Getting Help"},{"location":"#contribution-guidelines","text":"Here\u2019s how we suggest you go about proposing a change to this project: Fork this project to your account. Create a branch for the change you intend to make. Make your changes to your fork. Send a pull request from your fork\u2019s branch to our master branch.","title":"Contribution Guidelines"},{"location":"#changelog","text":"See CHANGELOG.md .","title":"Changelog"},{"location":"#license","text":"See LICENSE .","title":"License"},{"location":"introduction/","text":"Welcome! This tutorial will help you to practise with the pyalgotrading package with the help of an example. You will need an active and working AlgoBulls Account. Check out the Prerequisites section to ensure you have everything setup before you start the tutorial. This tutorial will help you with the following: Code your own simple strategy using the pyalgotrading package Upload yor strategy to the AlgoBulls Platform Run Backtest / Paper Trade / Real Trade using your strategy Fetch logs during runtime, see reports, view the statstics and see your order history For point 1, you need a Python IDE of your choice. However, if you do not wish to code your own strategy, then check out our pyalgostrategypool package to get a readymade strategy for your use. For points 2,3 and 4, you can use a Juypter Notebook. Check out the basic structure of a strategy. This will give you a basic summary and the flow behind each method which you will code in the strategy. Reach out to AlgoBulls Support for any queries.","title":"Introduction"},{"location":"module_constants/","text":"\u00b6 A collection of classes of type Enumeration use while programming a new strategy AlgoBullsEngineVersion \u00b6 A class of Versioning Constants AlgoBullsJobStatus \u00b6 A class of job status Constants AlgoBullsJobSubmissionResponse \u00b6 A class of responses when querying the job status AlgoBullsSupportedBrokers \u00b6 A class of supported brokers BrokerOrderCodeConstants \u00b6 A class of Order Code Constants BrokerOrderTransactionTypeConstants \u00b6 A class of Order Transaction Type Constants BrokerOrderTypeConstants \u00b6 A class of Order Type Constants BrokerOrderVarietyConstants \u00b6 A class of Order Variety Constants CandleInterval \u00b6 A class of Candle Intervals with their Alternate names PlotType \u00b6 A class of Plot Types StrategyMode \u00b6 A class of Strategy Modes StrategyType \u00b6 A class of Strategy Type TradingReportType \u00b6 A class of Trading Report Types TradingType \u00b6 A class of Trading Types","title":"constants"},{"location":"module_constants/#pyalgotrading.constants","text":"A collection of classes of type Enumeration use while programming a new strategy","title":"pyalgotrading.constants"},{"location":"module_constants/#pyalgotrading.constants.AlgoBullsEngineVersion","text":"A class of Versioning Constants","title":"AlgoBullsEngineVersion"},{"location":"module_constants/#pyalgotrading.constants.AlgoBullsJobStatus","text":"A class of job status Constants","title":"AlgoBullsJobStatus"},{"location":"module_constants/#pyalgotrading.constants.AlgoBullsJobSubmissionResponse","text":"A class of responses when querying the job status","title":"AlgoBullsJobSubmissionResponse"},{"location":"module_constants/#pyalgotrading.constants.AlgoBullsSupportedBrokers","text":"A class of supported brokers","title":"AlgoBullsSupportedBrokers"},{"location":"module_constants/#pyalgotrading.constants.BrokerOrderCodeConstants","text":"A class of Order Code Constants","title":"BrokerOrderCodeConstants"},{"location":"module_constants/#pyalgotrading.constants.BrokerOrderTransactionTypeConstants","text":"A class of Order Transaction Type Constants","title":"BrokerOrderTransactionTypeConstants"},{"location":"module_constants/#pyalgotrading.constants.BrokerOrderTypeConstants","text":"A class of Order Type Constants","title":"BrokerOrderTypeConstants"},{"location":"module_constants/#pyalgotrading.constants.BrokerOrderVarietyConstants","text":"A class of Order Variety Constants","title":"BrokerOrderVarietyConstants"},{"location":"module_constants/#pyalgotrading.constants.CandleInterval","text":"A class of Candle Intervals with their Alternate names","title":"CandleInterval"},{"location":"module_constants/#pyalgotrading.constants.PlotType","text":"A class of Plot Types","title":"PlotType"},{"location":"module_constants/#pyalgotrading.constants.StrategyMode","text":"A class of Strategy Modes","title":"StrategyMode"},{"location":"module_constants/#pyalgotrading.constants.StrategyType","text":"A class of Strategy Type","title":"StrategyType"},{"location":"module_constants/#pyalgotrading.constants.TradingReportType","text":"A class of Trading Report Types","title":"TradingReportType"},{"location":"module_constants/#pyalgotrading.constants.TradingType","text":"A class of Trading Types","title":"TradingType"},{"location":"package_algobulls/","text":"\u00b6 Package for interacting with the AlgoBulls backend api \u00b6 Module for handling API calls to the AlgoBulls backend. AlgoBullsAPI \u00b6 AlgoBulls API __init__ ( self ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/api.py 20 21 22 23 24 25 26 27 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . headers = None self . __key_backtesting = None # cstc id self . __key_papertrading = None # cstc id self . __key_realtrading = None # cstc id create_strategy ( self , strategy_name , strategy_details , abc_version ) \u00b6 Create a new strategy for the user on the AlgoBulls platform. Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning For every user, the strategy_name should be unique. You cannot create multiple strategies with the same name. ENDPOINT POST v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def create_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Create a new strategy for the user on the AlgoBulls platform. Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under [AlgoBullsEngineVersion]() Returns: JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning: For every user, the `strategy_name` should be unique. You cannot create multiple strategies with the same name. Info: ENDPOINT `POST` v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'post' , json_data = json_data ) return response get_all_strategies ( self ) \u00b6 Get all the Python strategies created by the user on the AlgoBulls platform Returns: Type Description dict JSON Response received from AlgoBulls platform with list of all the created strategies. ENDPOINT OPTIONS v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 166 167 168 169 170 171 172 173 174 175 176 177 178 def get_all_strategies ( self ) -> dict : \"\"\" Get all the Python strategies created by the user on the AlgoBulls platform Returns: JSON Response received from AlgoBulls platform with list of all the created strategies. Info: ENDPOINT `OPTIONS` v2/user/strategy/build/python \"\"\" endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'options' ) return response get_job_status ( self , strategy_code , trading_type ) \u00b6 Get status for a BACKTESTING/PAPERTRADING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type TradingType Trading type required Returns: Type Description dict Job status ENDPOINT GET v2/user/strategy/status Source code in pyalgotrading/algobulls/api.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def get_job_status ( self , strategy_code : str , trading_type : TradingType ) -> dict : \"\"\" Get status for a BACKTESTING/PAPERTRADING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Trading type Returns: Job status Info: ENDPOINT `GET` v2/user/strategy/status \"\"\" key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) params = { 'key' : key } endpoint = f 'v2/user/strategy/status' response = self . _send_request ( endpoint = endpoint , params = params ) return response get_reports ( self , strategy_code , trading_type , report_type ) \u00b6 Get reports for a BACKTESTING/PAPERTRADING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type TradingType Value of TradingType Enum required report_type TradingReportType Value of TradingReportType Enum required Returns: Type Description dict Report data ENDPOINT GET v1/customer_strategy_algotrading_reports Source code in pyalgotrading/algobulls/api.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def get_reports ( self , strategy_code : str , trading_type : TradingType , report_type : TradingReportType ) -> dict : \"\"\" Get reports for a BACKTESTING/PAPERTRADING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Value of TradingType Enum report_type: Value of TradingReportType Enum Returns: Report data Info: ENDPOINT `GET` v1/customer_strategy_algotrading_reports \"\"\" if report_type is TradingReportType . PNL_TABLE : endpoint = 'v2/user/strategy/pltable' elif report_type is TradingReportType . STATS_TABLE : endpoint = 'v2/user/strategy/statstable' elif report_type is TradingReportType . ORDER_HISTORY : endpoint = 'v2/user/strategy/orderhistory' else : raise NotImplementedError key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) params = { 'key' : key } response = self . _send_request ( endpoint = endpoint , params = params ) return response get_strategy_details ( self , strategy_code ) \u00b6 Get strategy details for Parameters: Name Type Description Default strategy_code str unique code of strategy, which is received while creating the strategy or required Returns: Type Description dict JSON ENDPOINT GET v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def get_strategy_details ( self , strategy_code : str ) -> dict : \"\"\" Get strategy details for Arguments: strategy_code: unique code of strategy, which is received while creating the strategy or Return: JSON Info: ENDPOINT `GET` v2/user/strategy/build/python \"\"\" params = { 'strategyCode' : strategy_code } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , params = params ) return response search_instrument ( self , instrument ) \u00b6 Parameters: Name Type Description Default instrument str instrument key required Returns: Type Description dict JSON Response ENDPOINT GET v2/instrument/search Source code in pyalgotrading/algobulls/api.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def search_instrument ( self , instrument : str ) -> dict : \"\"\" Args: instrument: instrument key Returns: JSON Response Info: ENDPOINT `GET` v2/instrument/search \"\"\" params = { 'instrument' : instrument } endpoint = f 'v2/instrument/search' response = self . _send_request ( endpoint = endpoint , params = params , requires_authorization = False ) return response set_access_token ( self , access_token ) \u00b6 Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Parameters: Name Type Description Default access_token str Access token generated by logging to the URL given by the get_authorization_url() method required Source code in pyalgotrading/algobulls/api.py 29 30 31 32 33 34 35 36 37 38 39 def set_access_token ( self , access_token : str ): \"\"\" Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Args: access_token: Access token generated by logging to the URL given by the `get_authorization_url()` method \"\"\" self . headers = { 'Authorization' : f ' { access_token } ' } set_strategy_config ( self , strategy_code , strategy_config , trading_type ) \u00b6 Parameters: Name Type Description Default strategy_code str strategy code required strategy_config dict strategy configuration required trading_type TradingType BACKTESTING, PAPER TRADING or REAL TRADING required Returns: Type Description (<class 'str'>, <class 'dict'>) Info: ENDPOINT PATCH v2/portfolio/strategy Source code in pyalgotrading/algobulls/api.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def set_strategy_config ( self , strategy_code : str , strategy_config : dict , trading_type : TradingType ) -> ( str , dict ): \"\"\" Args: strategy_code: strategy code strategy_config: strategy configuration trading_type: BACKTESTING, PAPER TRADING or REAL TRADING Returns: Info: ENDPOINT PATCH v2/portfolio/strategy \"\"\" # Configure the params json_data = { ** strategy_config , 'overwrite' : True } key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) endpoint = f 'v2/user/strategy/ { key } /tweak' print ( 'Setting Strategy Config...' , end = ' ' ) response = self . _send_request ( method = 'patch' , endpoint = endpoint , json_data = json_data ) print ( 'Success.' ) return key , response start_strategy_algotrading ( self , strategy_code , trading_type ) \u00b6 Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v2/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def start_strategy_algotrading ( self , strategy_code : str , trading_type : TradingType ) -> dict : \"\"\" Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v2/customer_strategy_algotrading \"\"\" if trading_type == TradingType . REALTRADING : endpoint = 'v2/portfolio/strategies' elif trading_type == TradingType . PAPERTRADING : endpoint = 'v2/papertrading/strategies' elif trading_type == TradingType . BACKTESTING : endpoint = 'v2/backtesting/strategies' else : raise NotImplementedError try : key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) json_data = { 'method' : 'update' , 'newVal' : 1 , 'key' : key , 'record' : { 'status' : 0 }} print ( f 'Submitting { trading_type . name } job...' , end = ' ' ) response = self . _send_request ( method = 'post' , endpoint = endpoint , json_data = json_data ) print ( 'Success.' ) return response except ( AlgoBullsAPIForbiddenError , AlgoBullsAPIInsufficientBalanceError ) as ex : print ( 'Fail.' ) print ( f ' { ex . get_error_type () } : { ex . response } ' ) stop_strategy_algotrading ( self , strategy_code , trading_type ) \u00b6 Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def stop_strategy_algotrading ( self , strategy_code : str , trading_type : TradingType ) -> dict : \"\"\" Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v1/customer_strategy_algotrading \"\"\" if trading_type == TradingType . REALTRADING : endpoint = 'v2/portfolio/strategies' elif trading_type == TradingType . PAPERTRADING : endpoint = 'v2/papertrading/strategies' elif trading_type == TradingType . BACKTESTING : endpoint = 'v2/backtesting/strategies' else : raise NotImplementedError try : key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) json_data = { 'method' : 'update' , 'newVal' : 0 , 'key' : key , 'record' : { 'status' : 2 }} print ( f 'Stopping { trading_type . name } job...' , end = ' ' ) response = self . _send_request ( method = 'post' , endpoint = endpoint , json_data = json_data ) print ( 'Success.' ) return response except ( AlgoBullsAPIForbiddenError , AlgoBullsAPIInsufficientBalanceError ) as ex : print ( 'Fail.' ) print ( f ' { ex . get_error_type () } : { ex . response } ' ) update_strategy ( self , strategy_name , strategy_details , abc_version ) \u00b6 Update an already existing strategy on the AlgoBulls platform Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. ENDPOINT PUT v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def update_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Update an already existing strategy on the AlgoBulls platform Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under `AlgoBullsEngineVersion` Returns: JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. Info: ENDPOINT PUT v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'put' , json_data = json_data ) return response connection \u00b6 Module for AlgoBulls connection AlgoBullsConnection \u00b6 Class for AlgoBulls connection __init__ ( self ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/connection.py 20 21 22 23 24 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . api = AlgoBullsAPI () backtest ( self , strategy_code , start_timestamp , end_timestamp , instrument , lots , strategy_parameters , candle_interval , strategy_mode =< StrategyMode . INTRADAY : 0 > ) \u00b6 Submit a backtesting job for a strategy on the AlgoBulls Platform Parameters: Name Type Description Default strategy_code strategy code required start_timestamp start date/time required end_timestamp end date/time required instrument instrument key required lots Number of lots of the passed instrument to trade on required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description backtest job submission status Source code in pyalgotrading/algobulls/connection.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def backtest ( self , strategy_code , start_timestamp , end_timestamp , instrument , lots , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Submit a backtesting job for a strategy on the AlgoBulls Platform Args: strategy_code: strategy code start_timestamp: start date/time end_timestamp: end date/time instrument: instrument key lots: Number of lots of the passed instrument to trade on strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: backtest job submission status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( start_timestamp , dt ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( end_timestamp , dt ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( lots , int ) is True and lots > 0 ), f 'Argument \"lots\" should be a positive integer.' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument \"strategy_parameters\" should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument \"strategy_mode\" should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument \"candle_interval\" should be an enum of type CandleInterval' # Setup config for Backtesting strategy_config = { 'tradingTime' : [ start_timestamp . strftime ( ' %d -%m-%Y %H:%M' ), end_timestamp . strftime ( ' %d -%m-%Y %H:%M' )], 'instruments' : [ instrument ], 'lots' : lots , 'parameters' : strategy_parameters , 'candle' : candle_interval . value , 'strategyMode' : strategy_mode . value } self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config , trading_type = TradingType . BACKTESTING ) # Submit Backtesting job response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING ) create_strategy ( self , strategy , overwrite = False ) \u00b6 Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. Source code in pyalgotrading/algobulls/connection.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def create_strategy ( self , strategy , overwrite = False ): \"\"\" Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. \"\"\" # Sanity checks assert issubclass ( strategy , StrategyBase ), f 'strategy should be a subclass of class StrategyBase. Got class of type: type { strategy } ' # Validate class by creating an instance print ( 'Validating Strategy...' ) strategy () # Get source code, and upload as new strategy (if strategy_code is None) else edit same strategy strategy_name = strategy . name () strategy_details = inspect . getsource ( strategy ) abc_version = strategy . versions_supported () . value # If strategy code is None, create a new strategy object try : response = self . api . create_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) except AlgoBullsAPIBadRequest as ex : if overwrite is True : # If strategy code is available, update the existing strategy response = self . api . update_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) else : print ( f 'Error uploading strategy. Details: \\n { ex } ' ) return return response get_all_strategies ( self ) \u00b6 Fetch all available strategies Returns: Type Description list of available strategies Source code in pyalgotrading/algobulls/connection.py 86 87 88 89 90 91 92 93 94 95 96 def get_all_strategies ( self ): \"\"\" Fetch all available strategies Returns: list of available strategies \"\"\" response = self . api . get_all_strategies () if isinstance ( response [ 'data' ], list ): return pd . DataFrame ( response [ 'data' ]) else : return response get_authorization_url () staticmethod \u00b6 Fetches the authorization URL Returns: Type Description authorization URL Source code in pyalgotrading/algobulls/connection.py 26 27 28 29 30 31 32 33 34 35 @staticmethod def get_authorization_url (): \"\"\" Fetches the authorization URL Returns: authorization URL \"\"\" url = 'https://app.algobulls.com/user/login' print ( f 'Please login to this URL with your AlgoBulls credentials and get your developer access token: { url } ' ) return url get_backtesting_job_status ( self , strategy_code ) \u00b6 Gets BACKTESTING job status for given strategy_code Source code in pyalgotrading/algobulls/connection.py 243 244 245 246 247 248 def get_backtesting_job_status ( self , strategy_code ): \"\"\" Gets BACKTESTING job status for given strategy_code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_job_status ( strategy_code , TradingType . BACKTESTING ) get_backtesting_logs ( self , strategy_code ) \u00b6 Fetch backtesting logs Parameters: Name Type Description Default strategy_code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 262 263 264 265 266 267 268 269 270 271 272 def get_backtesting_logs ( self , strategy_code ): \"\"\" Fetch backtesting logs Args: strategy_code: Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_logs ( strategy_code , trading_type = TradingType . BACKTESTING ) get_backtesting_report_order_history ( self , strategy_code ) \u00b6 Fetch backtesting order history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 299 300 301 302 303 304 305 306 307 308 309 def get_backtesting_report_order_history ( self , strategy_code ): \"\"\" Fetch backtesting order history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . ORDER_HISTORY ) get_backtesting_report_pnl_table ( self , strategy_code , show_all_rows = False ) \u00b6 Fetch backtesting Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 274 275 276 277 278 279 280 281 282 283 284 285 def get_backtesting_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch backtesting Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows ) get_backtesting_report_statistics ( self , strategy_code ) \u00b6 Fetch backtesting report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 287 288 289 290 291 292 293 294 295 296 297 def get_backtesting_report_statistics ( self , strategy_code ): \"\"\" Fetch backtesting report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True ) get_job_status ( self , strategy_code , trading_type ) \u00b6 Gets job status for given strategy_code and trading_type Source code in pyalgotrading/algobulls/connection.py 129 130 131 132 133 134 135 136 137 def get_job_status ( self , strategy_code , trading_type ): \"\"\" Gets job status for given strategy_code and trading_type \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' response = self . api . get_job_status ( strategy_code = strategy_code , trading_type = trading_type ) return response get_logs ( self , strategy_code , trading_type ) \u00b6 Fetch logs for a strategy Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required Returns: Type Description Execution logs Source code in pyalgotrading/algobulls/connection.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def get_logs ( self , strategy_code , trading_type ): \"\"\" Fetch logs for a strategy Args: strategy_code: strategy code trading_type: trading type Returns: Execution logs \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' return self . api . get_logs ( strategy_code = strategy_code , trading_type = trading_type ) . get ( 'data' ) get_papertrading_job_status ( self , strategy_code ) \u00b6 Get papertrading job status Parameters: Name Type Description Default strategy_code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 349 350 351 352 353 354 355 356 357 358 359 def get_papertrading_job_status ( self , strategy_code ): \"\"\" Get papertrading job status Args: strategy_code: Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_job_status ( strategy_code , TradingType . PAPERTRADING ) get_papertrading_logs ( self , strategy_code ) \u00b6 Fetch papertrading logs Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 373 374 375 376 377 378 379 380 381 382 383 def get_papertrading_logs ( self , strategy_code ): \"\"\" Fetch papertrading logs Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_logs ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING ) get_papertrading_report_order_history ( self , strategy_code ) \u00b6 Fetch papertrading order history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 410 411 412 413 414 415 416 417 418 419 420 def get_papertrading_report_order_history ( self , strategy_code ): \"\"\" Fetch papertrading order history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . ORDER_HISTORY ) get_papertrading_report_pnl_table ( self , strategy_code , show_all_rows = False ) \u00b6 Fetch papertrading Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 385 386 387 388 389 390 391 392 393 394 395 396 def get_papertrading_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch papertrading Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows ) get_papertrading_report_statistics ( self , strategy_code ) \u00b6 Fetch papertrading report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 398 399 400 401 402 403 404 405 406 407 408 def get_papertrading_report_statistics ( self , strategy_code ): \"\"\" Fetch papertrading report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True ) get_realtrading_job_status ( self , strategy_code ) \u00b6 Fetch realtrading job status Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 461 462 463 464 465 466 467 468 469 470 471 472 473 def get_realtrading_job_status ( self , strategy_code ): \"\"\" Fetch realtrading job status Args: strategy_code: strategy code Returns: job status \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_job_status ( strategy_code , TradingType . REALTRADING ) get_realtrading_logs ( self , strategy_code ) \u00b6 Fetch realtrading logs Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 488 489 490 491 492 493 494 495 496 497 498 499 500 def get_realtrading_logs ( self , strategy_code ): \"\"\" Fetch realtrading logs Args: strategy_code: strategy code Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_logs ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING ) get_realtrading_report_order_history ( self , strategy_code ) \u00b6 Fetch realtrading order history Parameters: Name Type Description Default # broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def get_realtrading_report_order_history ( self , strategy_code ): \"\"\" Fetch realtrading order history Args: # broker: broker name strategy_code: strategy code Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . ORDER_HISTORY ) get_realtrading_report_pnl_table ( self , strategy_code , show_all_rows = False ) \u00b6 Fetch realtrading Profit / Loss table Parameters: Name Type Description Default # broker broker name required strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def get_realtrading_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch realtrading Profit / Loss table Args: # broker: broker name strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows ) get_realtrading_report_statistics ( self , strategy_code ) \u00b6 Fetch realtrading report statistics Parameters: Name Type Description Default # broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def get_realtrading_report_statistics ( self , strategy_code ): \"\"\" Fetch realtrading report statistics Args: # broker: broker name strategy_code: strategy code Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True ) get_report ( self , strategy_code , trading_type , report_type , render_as_dataframe = False , show_all_rows = False ) \u00b6 Fetch report for a strategy Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required report_type report type required render_as_dataframe True or False False show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def get_report ( self , strategy_code , trading_type , report_type , render_as_dataframe = False , show_all_rows = False ): \"\"\" Fetch report for a strategy Args: strategy_code: strategy code trading_type: trading type report_type: report type render_as_dataframe: True or False show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' assert ( isinstance ( report_type , TradingReportType ) is True ), f 'Argument \"report_type\" should be an enum of type { TradingReportType . __name__ } ' assert ( isinstance ( render_as_dataframe , bool ) is True ), f 'Argument \"render_as_dataframe\" should be a bool' assert ( isinstance ( show_all_rows , bool ) is True ), f 'Argument \"show_all_rows\" should be a bool' # assert (broker is None or isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be None or an enum of type {AlgoBullsSupportedBrokers.__name__}' response = self . api . get_reports ( strategy_code = strategy_code , trading_type = trading_type , report_type = report_type ) if response . get ( 'data' ): if render_as_dataframe : if show_all_rows : pandas_dataframe_all_rows () _response = pd . DataFrame ( response [ 'data' ]) else : _response = response [ 'data' ] return _response else : print ( 'Report not available yet. Please retry in sometime' ) get_strategy_details ( self , strategy_code ) \u00b6 Fetch the strategy details of a particular strategy Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description strategy program / code Source code in pyalgotrading/algobulls/connection.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_strategy_details ( self , strategy_code ): \"\"\" Fetch the strategy details of a particular strategy Args: strategy_code: strategy code Returns: strategy program / code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' try : response = self . api . get_strategy_details ( strategy_code ) strategy_code = response [ 'data' ] return strategy_code except AlgoBullsAPIBadRequest : print ( f 'ERROR: No strategy found with ID: { strategy_code } ' ) papertrade ( self , strategy_code , start_time , end_time , instrument , lots , strategy_parameters , candle_interval , strategy_mode =< StrategyMode . INTRADAY : 0 > ) \u00b6 Start a paper trading session Parameters: Name Type Description Default strategy_code strategy code required start_time start time required end_time end time required instrument instrument key required lots Number of lots of the passed instrument to trade on required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def papertrade ( self , strategy_code , start_time , end_time , instrument , lots , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a paper trading session Args: strategy_code: strategy code start_time: start time end_time: end time instrument: instrument key lots: Number of lots of the passed instrument to trade on strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( end_time , time ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( lots , int ) is True and lots > 0 ), f 'Argument \"lots\" should be a positive integer.' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument \"strategy_parameters\" should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument \"strategy_mode\" should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument \"candle_interval\" should be an enum of type CandleInterval' # Setup config for Paper Trading strategy_config = { 'tradingTime' : [ start_time . strftime ( '%H:%M' ), end_time . strftime ( '%H:%M' )], 'instruments' : [ instrument ], 'lots' : lots , 'parameters' : strategy_parameters , 'candle' : candle_interval . value , 'strategyMode' : strategy_mode . value } self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config , trading_type = TradingType . PAPERTRADING ) # Submit Paper Trading job response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING ) realtrade ( self , strategy_code , start_time , end_time , instrument , lots , strategy_parameters , candle_interval , strategy_mode =< StrategyMode . INTRADAY : 0 > ) \u00b6 Start a realtrading session Parameters: Name Type Description Default strategy_code strategy code required start_time start time required end_time end time required instrument instrument key required lots Number of lots of the passed instrument to trade on required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 def realtrade ( self , strategy_code , start_time , end_time , instrument , lots , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a realtrading session Args: strategy_code: strategy code start_time: start time end_time: end time instrument: instrument key lots: Number of lots of the passed instrument to trade on strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument \"start_time\" should be an instance of type datetime.time' assert ( isinstance ( end_time , time ) is True ), f 'Argument \"end_time\" should be an instance of type datetime.time' assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( lots , int ) is True and lots > 0 ), f 'Argument \"lots\" should be a positive integer.' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument \"strategy_parameters\" should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument \"strategy_mode\" should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument \"candle_interval\" should be an enum of type CandleInterval' # Setup config for backtesting strategy_config = { 'tradingTime' : [ start_time . strftime ( '%H:%M' ), end_time . strftime ( '%H:%M' )], 'instruments' : [ instrument ], 'lots' : lots , 'parameters' : strategy_parameters , 'candle' : candle_interval . value , 'strategyMode' : strategy_mode . value } self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config , trading_type = TradingType . REALTRADING ) # Submit Real Trading job response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING ) search_instrument ( self , instrument ) \u00b6 Search for an instrument Parameters: Name Type Description Default instrument instrument key required Returns: Type Description True or False Source code in pyalgotrading/algobulls/connection.py 116 117 118 119 120 121 122 123 124 125 126 127 def search_instrument ( self , instrument ): \"\"\" Search for an instrument Args: instrument: instrument key Returns: True or False \"\"\" assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string' response = self . api . search_instrument ( instrument ) . get ( 'data' ) return response set_access_token ( self , access_token ) \u00b6 Set the access token Parameters: Name Type Description Default access_token access token required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 37 38 39 40 41 42 43 44 45 46 47 def set_access_token ( self , access_token ): \"\"\" Set the access token Args: access_token: access token Returns: None \"\"\" assert ( isinstance ( access_token , str ) is True ), f 'Argument \"access_token\" should be a string' self . api . set_access_token ( access_token ) stop_backtesting_job ( self , strategy_code ) \u00b6 Stops the BACKTESTING job Parameters: Name Type Description Default strategy_code Strategy Code / ID required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 250 251 252 253 254 255 256 257 258 259 260 def stop_backtesting_job ( self , strategy_code ): \"\"\" Stops the BACKTESTING job Args: strategy_code: Strategy Code / ID Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING ) stop_job ( self , strategy_code , trading_type ) \u00b6 Stops a job Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def stop_job ( self , strategy_code , trading_type ): \"\"\" Stops a job Args: strategy_code: strategy code trading_type: trading type Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' response = self . api . stop_strategy_algotrading ( strategy_code = strategy_code , trading_type = trading_type ) stop_papertrading_job ( self , strategy_code ) \u00b6 Stop the papertrading session Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 361 362 363 364 365 366 367 368 369 370 371 def stop_papertrading_job ( self , strategy_code ): \"\"\" Stop the papertrading session Args: strategy_code: strategy code Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING ) stop_realtrading_job ( self , strategy_code ) \u00b6 Stop the realtrading session Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 475 476 477 478 479 480 481 482 483 484 485 486 def stop_realtrading_job ( self , strategy_code ): \"\"\" Stop the realtrading session Args: strategy_code: strategy code Returns: None \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING ) pandas_dataframe_all_rows () \u00b6 Returns: None Source code in pyalgotrading/algobulls/connection.py 549 550 551 552 553 554 555 556 557 558 def pandas_dataframe_all_rows (): \"\"\" Returns: None \"\"\" pd . set_option ( 'display.max_rows' , None ) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , None ) exceptions \u00b6 AlgoBullsAPIBadRequest \u00b6 Exception class for HTTP status code of 400 (Bad Request) AlgoBullsAPIBaseException \u00b6 Base exception class for all API related exceptions AlgoBullsAPIForbiddenError \u00b6 Exception class for HTTP status code of 403 (Operation not permitted) Use case: Trying to START or STOP a strategy when it is in intermediate state. AlgoBullsAPIInsufficientBalanceError \u00b6 Exception class for HTTP status code of 402 (Insufficient Balance) AlgoBullsAPIInternalServerErrorException \u00b6 Exception class for HTTP status code of 500 (Internal Server Error) AlgoBullsAPIResourceNotFoundError \u00b6 Exception class for HTTP status code of 404 (Resource Not Found) AlgoBullsAPIUnauthorizedError \u00b6 Exception class for HTTP status code of 401 (Unauthorized)","title":"algobulls"},{"location":"package_algobulls/#pyalgotrading.algobulls","text":"Package for interacting with the AlgoBulls backend","title":"pyalgotrading.algobulls"},{"location":"package_algobulls/#pyalgotrading.algobulls.api","text":"Module for handling API calls to the AlgoBulls backend.","title":"api"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI","text":"AlgoBulls API","title":"AlgoBullsAPI"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/api.py 20 21 22 23 24 25 26 27 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . headers = None self . __key_backtesting = None # cstc id self . __key_papertrading = None # cstc id self . __key_realtrading = None # cstc id","title":"__init__()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.create_strategy","text":"Create a new strategy for the user on the AlgoBulls platform. Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning For every user, the strategy_name should be unique. You cannot create multiple strategies with the same name. ENDPOINT POST v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def create_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Create a new strategy for the user on the AlgoBulls platform. Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under [AlgoBullsEngineVersion]() Returns: JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning: For every user, the `strategy_name` should be unique. You cannot create multiple strategies with the same name. Info: ENDPOINT `POST` v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'post' , json_data = json_data ) return response","title":"create_strategy()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_all_strategies","text":"Get all the Python strategies created by the user on the AlgoBulls platform Returns: Type Description dict JSON Response received from AlgoBulls platform with list of all the created strategies. ENDPOINT OPTIONS v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 166 167 168 169 170 171 172 173 174 175 176 177 178 def get_all_strategies ( self ) -> dict : \"\"\" Get all the Python strategies created by the user on the AlgoBulls platform Returns: JSON Response received from AlgoBulls platform with list of all the created strategies. Info: ENDPOINT `OPTIONS` v2/user/strategy/build/python \"\"\" endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'options' ) return response","title":"get_all_strategies()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_job_status","text":"Get status for a BACKTESTING/PAPERTRADING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type TradingType Trading type required Returns: Type Description dict Job status ENDPOINT GET v2/user/strategy/status Source code in pyalgotrading/algobulls/api.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def get_job_status ( self , strategy_code : str , trading_type : TradingType ) -> dict : \"\"\" Get status for a BACKTESTING/PAPERTRADING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Trading type Returns: Job status Info: ENDPOINT `GET` v2/user/strategy/status \"\"\" key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) params = { 'key' : key } endpoint = f 'v2/user/strategy/status' response = self . _send_request ( endpoint = endpoint , params = params ) return response","title":"get_job_status()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_reports","text":"Get reports for a BACKTESTING/PAPERTRADING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type TradingType Value of TradingType Enum required report_type TradingReportType Value of TradingReportType Enum required Returns: Type Description dict Report data ENDPOINT GET v1/customer_strategy_algotrading_reports Source code in pyalgotrading/algobulls/api.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def get_reports ( self , strategy_code : str , trading_type : TradingType , report_type : TradingReportType ) -> dict : \"\"\" Get reports for a BACKTESTING/PAPERTRADING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Value of TradingType Enum report_type: Value of TradingReportType Enum Returns: Report data Info: ENDPOINT `GET` v1/customer_strategy_algotrading_reports \"\"\" if report_type is TradingReportType . PNL_TABLE : endpoint = 'v2/user/strategy/pltable' elif report_type is TradingReportType . STATS_TABLE : endpoint = 'v2/user/strategy/statstable' elif report_type is TradingReportType . ORDER_HISTORY : endpoint = 'v2/user/strategy/orderhistory' else : raise NotImplementedError key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) params = { 'key' : key } response = self . _send_request ( endpoint = endpoint , params = params ) return response","title":"get_reports()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_strategy_details","text":"Get strategy details for Parameters: Name Type Description Default strategy_code str unique code of strategy, which is received while creating the strategy or required Returns: Type Description dict JSON ENDPOINT GET v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def get_strategy_details ( self , strategy_code : str ) -> dict : \"\"\" Get strategy details for Arguments: strategy_code: unique code of strategy, which is received while creating the strategy or Return: JSON Info: ENDPOINT `GET` v2/user/strategy/build/python \"\"\" params = { 'strategyCode' : strategy_code } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , params = params ) return response","title":"get_strategy_details()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.search_instrument","text":"Parameters: Name Type Description Default instrument str instrument key required Returns: Type Description dict JSON Response ENDPOINT GET v2/instrument/search Source code in pyalgotrading/algobulls/api.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def search_instrument ( self , instrument : str ) -> dict : \"\"\" Args: instrument: instrument key Returns: JSON Response Info: ENDPOINT `GET` v2/instrument/search \"\"\" params = { 'instrument' : instrument } endpoint = f 'v2/instrument/search' response = self . _send_request ( endpoint = endpoint , params = params , requires_authorization = False ) return response","title":"search_instrument()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.set_access_token","text":"Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Parameters: Name Type Description Default access_token str Access token generated by logging to the URL given by the get_authorization_url() method required Source code in pyalgotrading/algobulls/api.py 29 30 31 32 33 34 35 36 37 38 39 def set_access_token ( self , access_token : str ): \"\"\" Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Args: access_token: Access token generated by logging to the URL given by the `get_authorization_url()` method \"\"\" self . headers = { 'Authorization' : f ' { access_token } ' }","title":"set_access_token()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.set_strategy_config","text":"Parameters: Name Type Description Default strategy_code str strategy code required strategy_config dict strategy configuration required trading_type TradingType BACKTESTING, PAPER TRADING or REAL TRADING required Returns: Type Description (<class 'str'>, <class 'dict'>) Info: ENDPOINT PATCH v2/portfolio/strategy Source code in pyalgotrading/algobulls/api.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def set_strategy_config ( self , strategy_code : str , strategy_config : dict , trading_type : TradingType ) -> ( str , dict ): \"\"\" Args: strategy_code: strategy code strategy_config: strategy configuration trading_type: BACKTESTING, PAPER TRADING or REAL TRADING Returns: Info: ENDPOINT PATCH v2/portfolio/strategy \"\"\" # Configure the params json_data = { ** strategy_config , 'overwrite' : True } key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) endpoint = f 'v2/user/strategy/ { key } /tweak' print ( 'Setting Strategy Config...' , end = ' ' ) response = self . _send_request ( method = 'patch' , endpoint = endpoint , json_data = json_data ) print ( 'Success.' ) return key , response","title":"set_strategy_config()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.start_strategy_algotrading","text":"Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v2/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def start_strategy_algotrading ( self , strategy_code : str , trading_type : TradingType ) -> dict : \"\"\" Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v2/customer_strategy_algotrading \"\"\" if trading_type == TradingType . REALTRADING : endpoint = 'v2/portfolio/strategies' elif trading_type == TradingType . PAPERTRADING : endpoint = 'v2/papertrading/strategies' elif trading_type == TradingType . BACKTESTING : endpoint = 'v2/backtesting/strategies' else : raise NotImplementedError try : key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) json_data = { 'method' : 'update' , 'newVal' : 1 , 'key' : key , 'record' : { 'status' : 0 }} print ( f 'Submitting { trading_type . name } job...' , end = ' ' ) response = self . _send_request ( method = 'post' , endpoint = endpoint , json_data = json_data ) print ( 'Success.' ) return response except ( AlgoBullsAPIForbiddenError , AlgoBullsAPIInsufficientBalanceError ) as ex : print ( 'Fail.' ) print ( f ' { ex . get_error_type () } : { ex . response } ' )","title":"start_strategy_algotrading()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.stop_strategy_algotrading","text":"Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def stop_strategy_algotrading ( self , strategy_code : str , trading_type : TradingType ) -> dict : \"\"\" Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v1/customer_strategy_algotrading \"\"\" if trading_type == TradingType . REALTRADING : endpoint = 'v2/portfolio/strategies' elif trading_type == TradingType . PAPERTRADING : endpoint = 'v2/papertrading/strategies' elif trading_type == TradingType . BACKTESTING : endpoint = 'v2/backtesting/strategies' else : raise NotImplementedError try : key = self . __get_key ( strategy_code = strategy_code , trading_type = trading_type ) json_data = { 'method' : 'update' , 'newVal' : 0 , 'key' : key , 'record' : { 'status' : 2 }} print ( f 'Stopping { trading_type . name } job...' , end = ' ' ) response = self . _send_request ( method = 'post' , endpoint = endpoint , json_data = json_data ) print ( 'Success.' ) return response except ( AlgoBullsAPIForbiddenError , AlgoBullsAPIInsufficientBalanceError ) as ex : print ( 'Fail.' ) print ( f ' { ex . get_error_type () } : { ex . response } ' )","title":"stop_strategy_algotrading()"},{"location":"package_algobulls/#pyalgotrading.algobulls.api.AlgoBullsAPI.update_strategy","text":"Update an already existing strategy on the AlgoBulls platform Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. ENDPOINT PUT v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def update_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Update an already existing strategy on the AlgoBulls platform Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under `AlgoBullsEngineVersion` Returns: JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. Info: ENDPOINT PUT v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'put' , json_data = json_data ) return response","title":"update_strategy()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection","text":"Module for AlgoBulls connection","title":"connection"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection","text":"Class for AlgoBulls connection","title":"AlgoBullsConnection"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/connection.py 20 21 22 23 24 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . api = AlgoBullsAPI ()","title":"__init__()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.backtest","text":"Submit a backtesting job for a strategy on the AlgoBulls Platform Parameters: Name Type Description Default strategy_code strategy code required start_timestamp start date/time required end_timestamp end date/time required instrument instrument key required lots Number of lots of the passed instrument to trade on required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description backtest job submission status Source code in pyalgotrading/algobulls/connection.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def backtest ( self , strategy_code , start_timestamp , end_timestamp , instrument , lots , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Submit a backtesting job for a strategy on the AlgoBulls Platform Args: strategy_code: strategy code start_timestamp: start date/time end_timestamp: end date/time instrument: instrument key lots: Number of lots of the passed instrument to trade on strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: backtest job submission status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( start_timestamp , dt ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( end_timestamp , dt ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( lots , int ) is True and lots > 0 ), f 'Argument \"lots\" should be a positive integer.' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument \"strategy_parameters\" should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument \"strategy_mode\" should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument \"candle_interval\" should be an enum of type CandleInterval' # Setup config for Backtesting strategy_config = { 'tradingTime' : [ start_timestamp . strftime ( ' %d -%m-%Y %H:%M' ), end_timestamp . strftime ( ' %d -%m-%Y %H:%M' )], 'instruments' : [ instrument ], 'lots' : lots , 'parameters' : strategy_parameters , 'candle' : candle_interval . value , 'strategyMode' : strategy_mode . value } self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config , trading_type = TradingType . BACKTESTING ) # Submit Backtesting job response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING )","title":"backtest()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.create_strategy","text":"Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. Source code in pyalgotrading/algobulls/connection.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def create_strategy ( self , strategy , overwrite = False ): \"\"\" Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. \"\"\" # Sanity checks assert issubclass ( strategy , StrategyBase ), f 'strategy should be a subclass of class StrategyBase. Got class of type: type { strategy } ' # Validate class by creating an instance print ( 'Validating Strategy...' ) strategy () # Get source code, and upload as new strategy (if strategy_code is None) else edit same strategy strategy_name = strategy . name () strategy_details = inspect . getsource ( strategy ) abc_version = strategy . versions_supported () . value # If strategy code is None, create a new strategy object try : response = self . api . create_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) except AlgoBullsAPIBadRequest as ex : if overwrite is True : # If strategy code is available, update the existing strategy response = self . api . update_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) else : print ( f 'Error uploading strategy. Details: \\n { ex } ' ) return return response","title":"create_strategy()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_all_strategies","text":"Fetch all available strategies Returns: Type Description list of available strategies Source code in pyalgotrading/algobulls/connection.py 86 87 88 89 90 91 92 93 94 95 96 def get_all_strategies ( self ): \"\"\" Fetch all available strategies Returns: list of available strategies \"\"\" response = self . api . get_all_strategies () if isinstance ( response [ 'data' ], list ): return pd . DataFrame ( response [ 'data' ]) else : return response","title":"get_all_strategies()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_authorization_url","text":"Fetches the authorization URL Returns: Type Description authorization URL Source code in pyalgotrading/algobulls/connection.py 26 27 28 29 30 31 32 33 34 35 @staticmethod def get_authorization_url (): \"\"\" Fetches the authorization URL Returns: authorization URL \"\"\" url = 'https://app.algobulls.com/user/login' print ( f 'Please login to this URL with your AlgoBulls credentials and get your developer access token: { url } ' ) return url","title":"get_authorization_url()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_job_status","text":"Gets BACKTESTING job status for given strategy_code Source code in pyalgotrading/algobulls/connection.py 243 244 245 246 247 248 def get_backtesting_job_status ( self , strategy_code ): \"\"\" Gets BACKTESTING job status for given strategy_code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_job_status ( strategy_code , TradingType . BACKTESTING )","title":"get_backtesting_job_status()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_logs","text":"Fetch backtesting logs Parameters: Name Type Description Default strategy_code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 262 263 264 265 266 267 268 269 270 271 272 def get_backtesting_logs ( self , strategy_code ): \"\"\" Fetch backtesting logs Args: strategy_code: Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_logs ( strategy_code , trading_type = TradingType . BACKTESTING )","title":"get_backtesting_logs()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_report_order_history","text":"Fetch backtesting order history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 299 300 301 302 303 304 305 306 307 308 309 def get_backtesting_report_order_history ( self , strategy_code ): \"\"\" Fetch backtesting order history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . ORDER_HISTORY )","title":"get_backtesting_report_order_history()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_report_pnl_table","text":"Fetch backtesting Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 274 275 276 277 278 279 280 281 282 283 284 285 def get_backtesting_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch backtesting Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows )","title":"get_backtesting_report_pnl_table()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_report_statistics","text":"Fetch backtesting report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 287 288 289 290 291 292 293 294 295 296 297 def get_backtesting_report_statistics ( self , strategy_code ): \"\"\" Fetch backtesting report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True )","title":"get_backtesting_report_statistics()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_job_status","text":"Gets job status for given strategy_code and trading_type Source code in pyalgotrading/algobulls/connection.py 129 130 131 132 133 134 135 136 137 def get_job_status ( self , strategy_code , trading_type ): \"\"\" Gets job status for given strategy_code and trading_type \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' response = self . api . get_job_status ( strategy_code = strategy_code , trading_type = trading_type ) return response","title":"get_job_status()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_logs","text":"Fetch logs for a strategy Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required Returns: Type Description Execution logs Source code in pyalgotrading/algobulls/connection.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def get_logs ( self , strategy_code , trading_type ): \"\"\" Fetch logs for a strategy Args: strategy_code: strategy code trading_type: trading type Returns: Execution logs \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' return self . api . get_logs ( strategy_code = strategy_code , trading_type = trading_type ) . get ( 'data' )","title":"get_logs()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_job_status","text":"Get papertrading job status Parameters: Name Type Description Default strategy_code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 349 350 351 352 353 354 355 356 357 358 359 def get_papertrading_job_status ( self , strategy_code ): \"\"\" Get papertrading job status Args: strategy_code: Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_job_status ( strategy_code , TradingType . PAPERTRADING )","title":"get_papertrading_job_status()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_logs","text":"Fetch papertrading logs Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 373 374 375 376 377 378 379 380 381 382 383 def get_papertrading_logs ( self , strategy_code ): \"\"\" Fetch papertrading logs Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_logs ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING )","title":"get_papertrading_logs()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_report_order_history","text":"Fetch papertrading order history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 410 411 412 413 414 415 416 417 418 419 420 def get_papertrading_report_order_history ( self , strategy_code ): \"\"\" Fetch papertrading order history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . ORDER_HISTORY )","title":"get_papertrading_report_order_history()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_report_pnl_table","text":"Fetch papertrading Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 385 386 387 388 389 390 391 392 393 394 395 396 def get_papertrading_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch papertrading Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows )","title":"get_papertrading_report_pnl_table()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_report_statistics","text":"Fetch papertrading report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 398 399 400 401 402 403 404 405 406 407 408 def get_papertrading_report_statistics ( self , strategy_code ): \"\"\" Fetch papertrading report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True )","title":"get_papertrading_report_statistics()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_job_status","text":"Fetch realtrading job status Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 461 462 463 464 465 466 467 468 469 470 471 472 473 def get_realtrading_job_status ( self , strategy_code ): \"\"\" Fetch realtrading job status Args: strategy_code: strategy code Returns: job status \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_job_status ( strategy_code , TradingType . REALTRADING )","title":"get_realtrading_job_status()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_logs","text":"Fetch realtrading logs Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 488 489 490 491 492 493 494 495 496 497 498 499 500 def get_realtrading_logs ( self , strategy_code ): \"\"\" Fetch realtrading logs Args: strategy_code: strategy code Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_logs ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING )","title":"get_realtrading_logs()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_report_order_history","text":"Fetch realtrading order history Parameters: Name Type Description Default # broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def get_realtrading_report_order_history ( self , strategy_code ): \"\"\" Fetch realtrading order history Args: # broker: broker name strategy_code: strategy code Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . ORDER_HISTORY )","title":"get_realtrading_report_order_history()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_report_pnl_table","text":"Fetch realtrading Profit / Loss table Parameters: Name Type Description Default # broker broker name required strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def get_realtrading_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch realtrading Profit / Loss table Args: # broker: broker name strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows )","title":"get_realtrading_report_pnl_table()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_report_statistics","text":"Fetch realtrading report statistics Parameters: Name Type Description Default # broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def get_realtrading_report_statistics ( self , strategy_code ): \"\"\" Fetch realtrading report statistics Args: # broker: broker name strategy_code: strategy code Returns: report details \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True )","title":"get_realtrading_report_statistics()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_report","text":"Fetch report for a strategy Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required report_type report type required render_as_dataframe True or False False show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def get_report ( self , strategy_code , trading_type , report_type , render_as_dataframe = False , show_all_rows = False ): \"\"\" Fetch report for a strategy Args: strategy_code: strategy code trading_type: trading type report_type: report type render_as_dataframe: True or False show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' assert ( isinstance ( report_type , TradingReportType ) is True ), f 'Argument \"report_type\" should be an enum of type { TradingReportType . __name__ } ' assert ( isinstance ( render_as_dataframe , bool ) is True ), f 'Argument \"render_as_dataframe\" should be a bool' assert ( isinstance ( show_all_rows , bool ) is True ), f 'Argument \"show_all_rows\" should be a bool' # assert (broker is None or isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be None or an enum of type {AlgoBullsSupportedBrokers.__name__}' response = self . api . get_reports ( strategy_code = strategy_code , trading_type = trading_type , report_type = report_type ) if response . get ( 'data' ): if render_as_dataframe : if show_all_rows : pandas_dataframe_all_rows () _response = pd . DataFrame ( response [ 'data' ]) else : _response = response [ 'data' ] return _response else : print ( 'Report not available yet. Please retry in sometime' )","title":"get_report()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_strategy_details","text":"Fetch the strategy details of a particular strategy Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description strategy program / code Source code in pyalgotrading/algobulls/connection.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_strategy_details ( self , strategy_code ): \"\"\" Fetch the strategy details of a particular strategy Args: strategy_code: strategy code Returns: strategy program / code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' try : response = self . api . get_strategy_details ( strategy_code ) strategy_code = response [ 'data' ] return strategy_code except AlgoBullsAPIBadRequest : print ( f 'ERROR: No strategy found with ID: { strategy_code } ' )","title":"get_strategy_details()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.papertrade","text":"Start a paper trading session Parameters: Name Type Description Default strategy_code strategy code required start_time start time required end_time end time required instrument instrument key required lots Number of lots of the passed instrument to trade on required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def papertrade ( self , strategy_code , start_time , end_time , instrument , lots , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a paper trading session Args: strategy_code: strategy code start_time: start time end_time: end time instrument: instrument key lots: Number of lots of the passed instrument to trade on strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( end_time , time ) is True ), f 'Argument \"start_timestamp\" should be an instance of type datetime.datetime' assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( lots , int ) is True and lots > 0 ), f 'Argument \"lots\" should be a positive integer.' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument \"strategy_parameters\" should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument \"strategy_mode\" should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument \"candle_interval\" should be an enum of type CandleInterval' # Setup config for Paper Trading strategy_config = { 'tradingTime' : [ start_time . strftime ( '%H:%M' ), end_time . strftime ( '%H:%M' )], 'instruments' : [ instrument ], 'lots' : lots , 'parameters' : strategy_parameters , 'candle' : candle_interval . value , 'strategyMode' : strategy_mode . value } self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config , trading_type = TradingType . PAPERTRADING ) # Submit Paper Trading job response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING )","title":"papertrade()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.realtrade","text":"Start a realtrading session Parameters: Name Type Description Default strategy_code strategy code required start_time start time required end_time end time required instrument instrument key required lots Number of lots of the passed instrument to trade on required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 def realtrade ( self , strategy_code , start_time , end_time , instrument , lots , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a realtrading session Args: strategy_code: strategy code start_time: start time end_time: end time instrument: instrument key lots: Number of lots of the passed instrument to trade on strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument \"start_time\" should be an instance of type datetime.time' assert ( isinstance ( end_time , time ) is True ), f 'Argument \"end_time\" should be an instance of type datetime.time' assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( lots , int ) is True and lots > 0 ), f 'Argument \"lots\" should be a positive integer.' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument \"strategy_parameters\" should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument \"strategy_mode\" should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument \"candle_interval\" should be an enum of type CandleInterval' # Setup config for backtesting strategy_config = { 'tradingTime' : [ start_time . strftime ( '%H:%M' ), end_time . strftime ( '%H:%M' )], 'instruments' : [ instrument ], 'lots' : lots , 'parameters' : strategy_parameters , 'candle' : candle_interval . value , 'strategyMode' : strategy_mode . value } self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config , trading_type = TradingType . REALTRADING ) # Submit Real Trading job response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING )","title":"realtrade()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.search_instrument","text":"Search for an instrument Parameters: Name Type Description Default instrument instrument key required Returns: Type Description True or False Source code in pyalgotrading/algobulls/connection.py 116 117 118 119 120 121 122 123 124 125 126 127 def search_instrument ( self , instrument ): \"\"\" Search for an instrument Args: instrument: instrument key Returns: True or False \"\"\" assert ( isinstance ( instrument , str ) is True ), f 'Argument \"instrument\" should be a string' response = self . api . search_instrument ( instrument ) . get ( 'data' ) return response","title":"search_instrument()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.set_access_token","text":"Set the access token Parameters: Name Type Description Default access_token access token required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 37 38 39 40 41 42 43 44 45 46 47 def set_access_token ( self , access_token ): \"\"\" Set the access token Args: access_token: access token Returns: None \"\"\" assert ( isinstance ( access_token , str ) is True ), f 'Argument \"access_token\" should be a string' self . api . set_access_token ( access_token )","title":"set_access_token()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_backtesting_job","text":"Stops the BACKTESTING job Parameters: Name Type Description Default strategy_code Strategy Code / ID required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 250 251 252 253 254 255 256 257 258 259 260 def stop_backtesting_job ( self , strategy_code ): \"\"\" Stops the BACKTESTING job Args: strategy_code: Strategy Code / ID Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING )","title":"stop_backtesting_job()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_job","text":"Stops a job Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def stop_job ( self , strategy_code , trading_type ): \"\"\" Stops a job Args: strategy_code: strategy code trading_type: trading type Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument \"trading_type\" should be an enum of type { TradingType . __name__ } ' response = self . api . stop_strategy_algotrading ( strategy_code = strategy_code , trading_type = trading_type )","title":"stop_job()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_papertrading_job","text":"Stop the papertrading session Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 361 362 363 364 365 366 367 368 369 370 371 def stop_papertrading_job ( self , strategy_code ): \"\"\" Stop the papertrading session Args: strategy_code: strategy code Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING )","title":"stop_papertrading_job()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_realtrading_job","text":"Stop the realtrading session Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 475 476 477 478 479 480 481 482 483 484 485 486 def stop_realtrading_job ( self , strategy_code ): \"\"\" Stop the realtrading session Args: strategy_code: strategy code Returns: None \"\"\" # assert (isinstance(broker, AlgoBullsSupportedBrokers) is True), f'Argument broker should be an enum of type {AlgoBullsSupportedBrokers.__name__}' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument \"strategy_code\" should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING )","title":"stop_realtrading_job()"},{"location":"package_algobulls/#pyalgotrading.algobulls.connection.pandas_dataframe_all_rows","text":"Returns: None Source code in pyalgotrading/algobulls/connection.py 549 550 551 552 553 554 555 556 557 558 def pandas_dataframe_all_rows (): \"\"\" Returns: None \"\"\" pd . set_option ( 'display.max_rows' , None ) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , None )","title":"pandas_dataframe_all_rows()"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions","text":"","title":"exceptions"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIBadRequest","text":"Exception class for HTTP status code of 400 (Bad Request)","title":"AlgoBullsAPIBadRequest"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIBaseException","text":"Base exception class for all API related exceptions","title":"AlgoBullsAPIBaseException"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIForbiddenError","text":"Exception class for HTTP status code of 403 (Operation not permitted) Use case: Trying to START or STOP a strategy when it is in intermediate state.","title":"AlgoBullsAPIForbiddenError"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIInsufficientBalanceError","text":"Exception class for HTTP status code of 402 (Insufficient Balance)","title":"AlgoBullsAPIInsufficientBalanceError"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIInternalServerErrorException","text":"Exception class for HTTP status code of 500 (Internal Server Error)","title":"AlgoBullsAPIInternalServerErrorException"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIResourceNotFoundError","text":"Exception class for HTTP status code of 404 (Resource Not Found)","title":"AlgoBullsAPIResourceNotFoundError"},{"location":"package_algobulls/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIUnauthorizedError","text":"Exception class for HTTP status code of 401 (Unauthorized)","title":"AlgoBullsAPIUnauthorizedError"},{"location":"package_broker/","text":"\u00b6 broker_connection_base \u00b6 Base class for Broker Connection BrokerConnectionBase \u00b6 Base class for Broker Connection get_all_instruments ( self ) \u00b6 All instruments enlisted by the broker Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_base.py 20 21 22 23 24 25 26 27 @abstractmethod def get_all_instruments ( self ): \"\"\" All instruments enlisted by the broker Returns: list of all instruments \"\"\" raise NotImplementedError get_circuit_limits ( self , * args , ** kwargs ) \u00b6 Fetch the circuit limits Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_base.py 55 56 57 58 59 60 61 62 63 64 65 66 @abstractmethod def get_circuit_limits ( self , * args , ** kwargs ): \"\"\" Fetch the circuit limits Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: circuit limit value \"\"\" raise NotImplementedError get_close_price_last_day ( self , * args , ** kwargs ) \u00b6 Fetch the closed price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_base.py 185 186 187 188 189 190 191 192 193 194 195 196 @abstractmethod def get_close_price_last_day ( self , * args , ** kwargs ): \"\"\" Fetch the closed price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: closed price value \"\"\" raise NotImplementedError get_funds ( self , * args , ** kwargs ) \u00b6 Fetch the available funds Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_base.py 226 227 228 229 230 231 232 233 234 235 236 237 @abstractmethod def get_funds ( self , * args , ** kwargs ): \"\"\" Fetch the available funds Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: available funds value \"\"\" raise NotImplementedError get_high_price_day ( self , * args , ** kwargs ) \u00b6 Fetch the high price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_base.py 159 160 161 162 163 164 165 166 167 168 169 170 @abstractmethod def get_high_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the high price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: high price value \"\"\" raise NotImplementedError get_historical_data ( self , instrument , candle_interval , start_date , end_date ) \u00b6 Fetch the historical data Parameters: Name Type Description Default instrument instrument key required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_base.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 @abstractmethod def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: instrument key candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" raise NotImplementedError get_instrument ( self , * args , ** kwargs ) \u00b6 Fetch a single instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description a single instrument Source code in pyalgotrading/broker/broker_connection_base.py 29 30 31 32 33 34 35 36 37 38 39 40 @abstractmethod def get_instrument ( self , * args , ** kwargs ): \"\"\" Fetch a single instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: a single instrument \"\"\" raise NotImplementedError get_low_price_day ( self , * args , ** kwargs ) \u00b6 Fetch the low price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_base.py 172 173 174 175 176 177 178 179 180 181 182 183 @abstractmethod def get_low_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the low price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: low price value \"\"\" raise NotImplementedError get_ltp ( self , * args , ** kwargs ) \u00b6 Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_base.py 68 69 70 71 72 73 74 75 76 77 78 79 @abstractmethod def get_ltp ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Price (LTP) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltp value \"\"\" raise NotImplementedError get_ltq ( self , * args , ** kwargs ) \u00b6 Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_base.py 94 95 96 97 98 99 100 101 102 103 104 105 @abstractmethod def get_ltq ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltq value \"\"\" raise NotImplementedError get_ltt ( self , * args , ** kwargs ) \u00b6 Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_base.py 81 82 83 84 85 86 87 88 89 90 91 92 @abstractmethod def get_ltt ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Time (LTT) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltt value \"\"\" raise NotImplementedError get_margins ( self , * args , ** kwargs ) \u00b6 Fetch the margins Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_base.py 213 214 215 216 217 218 219 220 221 222 223 224 @abstractmethod def get_margins ( self , * args , ** kwargs ): \"\"\" Fetch the margins Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: margin value \"\"\" raise NotImplementedError get_market_depth ( self , * args , ** kwargs ) \u00b6 Fetch the market depth Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_base.py 42 43 44 45 46 47 48 49 50 51 52 53 @abstractmethod def get_market_depth ( self , * args , ** kwargs ): \"\"\" Fetch the market depth Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: market depth value \"\"\" raise NotImplementedError get_name ( self ) \u00b6 Name of the broker Returns: Type Description broker name Source code in pyalgotrading/broker/broker_connection_base.py 11 12 13 14 15 16 17 18 @abstractmethod def get_name ( self ): \"\"\" Name of the broker Returns: broker name \"\"\" raise NotImplementedError get_open_price_day ( self , * args , ** kwargs ) \u00b6 Fetch the open price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_base.py 146 147 148 149 150 151 152 153 154 155 156 157 @abstractmethod def get_open_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the open price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: open price value \"\"\" raise NotImplementedError get_order_status ( self , order_id ) \u00b6 Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_base.py 270 271 272 273 274 275 276 277 278 279 280 @abstractmethod def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" raise NotImplementedError get_profile ( self ) \u00b6 Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_base.py 239 240 241 242 243 244 245 246 @abstractmethod def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" raise NotImplementedError get_total_pending_buy_quantity ( self , * args , ** kwargs ) \u00b6 Fetch the total pending buy quantity for instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 107 108 109 110 111 112 113 114 115 116 117 118 @abstractmethod def get_total_pending_buy_quantity ( self , * args , ** kwargs ): \"\"\" Fetch the total pending buy quantity for instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError get_total_pending_sell_quantity ( self , * args , ** kwargs ) \u00b6 Fetch the total pending sell quantity for the instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 120 121 122 123 124 125 126 127 128 129 130 131 @abstractmethod def get_total_pending_sell_quantity ( self , * args , ** kwargs ): \"\"\" Fetch the total pending sell quantity for the instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError get_total_volume_day ( self , * args , ** kwargs ) \u00b6 Fetch the total volume for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_base.py 133 134 135 136 137 138 139 140 141 142 143 144 @abstractmethod def get_total_volume_day ( self , * args , ** kwargs ): \"\"\" Fetch the total volume for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total volume value \"\"\" raise NotImplementedError place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) \u00b6 Place an order Parameters: Name Type Description Default instrument instrument key required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Returns: Type Description order id Source code in pyalgotrading/broker/broker_connection_base.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 @abstractmethod def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Place an order Args: instrument: instrument key order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value Returns: order id \"\"\" raise NotImplementedError broker_connection_zerodha \u00b6 Module for class BrokerConnectionZerodha BrokerConnectionZerodha \u00b6 class for Broker Connection Zerodha __init__ ( self , api_key , api_secret ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default api_key api key given by the broker required api_secret api secret to be used for making an authenticated connection with the broker required Source code in pyalgotrading/broker/broker_connection_zerodha.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , api_key , api_secret ): \"\"\" Init method that is used while creating an object of this class Args: api_key: api key given by the broker api_secret: api secret to be used for making an authenticated connection with the broker \"\"\" self . api_key = api_key self . api_secret = api_secret # Create kiteconnect instance kiteconnect = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect==3.8.2' ) self . api = kiteconnect . KiteConnect ( api_key = self . api_key ) # Print the login url. User will use this to login to broker site and get access token print ( f 'Please login to this link to generate your request token: { self . api . login_url () } ' ) # Create other attributes self . all_instruments = None self . populate_constants () cancel_order ( self , order_id , order_type ) \u00b6 Cancel an order Parameters: Name Type Description Default order_id order id required order_type order type required Returns: Type Description Order Status Source code in pyalgotrading/broker/broker_connection_zerodha.py 373 374 375 376 377 378 379 380 381 382 383 384 def cancel_order ( self , order_id , order_type ): \"\"\" Cancel an order Args: order_id: order id order_type: order type Returns: Order Status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # What we call as 'Order Type', Zerodha calls it as 'variety' return self . api . cancel_order ( variety = _variety , order_id = order_id ) get_all_instruments ( self ) \u00b6 Fetches all instruments Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_zerodha.py 87 88 89 90 91 92 93 94 def get_all_instruments ( self ): \"\"\" Fetches all instruments Returns: list of all instruments \"\"\" self . all_instruments = pd . DataFrame ( self . api . instruments ()) return self . all_instruments get_circuit_limits ( self , instrument ) \u00b6 Fetch the circuit limits Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_zerodha.py 143 144 145 146 147 148 149 150 151 152 153 154 155 def get_circuit_limits ( self , instrument : Instrument ): \"\"\" Fetch the circuit limits Args: instrument: Financial Instrument Returns: circuit limit value \"\"\" quote = self . get_quote ( instrument ) lower_circuit_limit = quote [ 'lower_circuit_limit' ] upper_circuit_limit = quote [ 'upper_circuit_limit' ] return lower_circuit_limit , upper_circuit_limit get_close_price_last_day ( self , instrument ) \u00b6 Fetch the closed price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 274 275 276 277 278 279 280 281 282 283 284 285 def get_close_price_last_day ( self , instrument : Instrument ): \"\"\" Fetch the closed price of the day Args: instrument: Financial Instrument Returns: closed price value \"\"\" quote = self . get_quote ( instrument ) close_price_day = quote [ 'ohlc' ][ 'close' ] return close_price_day get_funds ( self , segment ) \u00b6 Fetch the available funds Parameters: Name Type Description Default segment segment required Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_zerodha.py 315 316 317 318 319 320 321 322 323 324 325 326 def get_funds ( self , segment ): \"\"\" Fetch the available funds Args: segment: segment Returns: available funds value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment )[ 'net' ] get_high_price_day ( self , instrument ) \u00b6 Fetch the high price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 248 249 250 251 252 253 254 255 256 257 258 259 def get_high_price_day ( self , instrument : Instrument ): \"\"\" Fetch the high price of the day Args: instrument: Financial Instrument Returns: high price value \"\"\" quote = self . get_quote ( instrument ) high_price_day = quote [ 'ohlc' ][ 'high' ] return high_price_day get_historical_data ( self , instrument , candle_interval , start_date , end_date ) \u00b6 Fetch the historical data Parameters: Name Type Description Default instrument Financial Instrument required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_zerodha.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: Financial Instrument candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" return pd . DataFrame ( self . api . historical_data ( instrument . broker_token , from_date = start_date , to_date = end_date , interval = candle_interval )) \\ . reindex ([ 'date' , 'open' , 'high' , 'low' , 'close' , 'volume' ], axis = \"columns\" ) . rename ( columns = { 'date' : 'timestamp' }) get_instrument ( self , segment , tradingsymbol ) \u00b6 Fetch an instrument Parameters: Name Type Description Default segment str Segment to which instrument belongs to required tradingsymbol str Trading symbol of the instrument required Returns: Type Description Instrument Instrument object Source code in pyalgotrading/broker/broker_connection_zerodha.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_instrument ( self , segment : str , tradingsymbol : str ) -> Instrument : \"\"\" Fetch an instrument Args: segment: Segment to which instrument belongs to tradingsymbol: Trading symbol of the instrument Returns: Instrument object \"\"\" if self . all_instruments is None : self . all_instruments = self . get_all_instruments () try : _inst = self . all_instruments [( self . all_instruments . segment == segment ) & ( self . all_instruments . tradingsymbol == tradingsymbol )] . iloc [ 0 ] instrument = Instrument ( segment = _inst [ 'segment' ], exchange = _inst [ 'exchange' ], tradingsymbol = _inst [ 'tradingsymbol' ], broker_token = _inst [ 'instrument_token' ], tick_size = _inst [ 'tick_size' ], lot_size = _inst [ 'lot_size' ], expiry = _inst [ 'expiry' ], strike_price = _inst [ 'strike' ]) return instrument except IndexError : print ( 'ERROR: Instrument not found. Either it is expired and hence not available, or you have misspelled the \"segment\" and \"tradingsymbol\" parameters.' ) get_low_price_day ( self , instrument ) \u00b6 Fetch the low price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 261 262 263 264 265 266 267 268 269 270 271 272 def get_low_price_day ( self , instrument : Instrument ): \"\"\" Fetch the low price of the day Args: instrument: Financial Instrument Returns: low price value \"\"\" quote = self . get_quote ( instrument ) low_price_day = quote [ 'ohlc' ][ 'low' ] return low_price_day get_ltp ( self , instrument ) \u00b6 Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_zerodha.py 157 158 159 160 161 162 163 164 165 166 167 168 def get_ltp ( self , instrument : Instrument ): \"\"\" Fetch the Last Trading Price (LTP) Args: instrument: Financial Instrument Returns: ltp value \"\"\" quote = self . get_quote ( instrument ) ltp = quote [ 'last_price' ] return ltp get_ltq ( self , instrument ) \u00b6 Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default instrument Financial Instrument required Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_zerodha.py 183 184 185 186 187 188 189 190 191 192 193 194 def get_ltq ( self , instrument ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: instrument: Financial Instrument Returns: ltq value \"\"\" quote = self . get_quote ( instrument ) ltq = quote [ 'last_quantity' ] return ltq get_ltt ( self , instrument ) \u00b6 Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default instrument Financial Instrument required Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_zerodha.py 170 171 172 173 174 175 176 177 178 179 180 181 def get_ltt ( self , instrument ): \"\"\" Fetch the Last Trading Time (LTT) Args: instrument: Financial Instrument Returns: ltt value \"\"\" quote = self . get_quote ( instrument ) ltt = quote [ 'last_trade_time' ] return ltt get_margins ( self , segment ) \u00b6 Fetch the margins Parameters: Name Type Description Default segment segment required Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_zerodha.py 302 303 304 305 306 307 308 309 310 311 312 313 def get_margins ( self , segment ): \"\"\" Fetch the margins Args: segment: segment Returns: margin value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment ) get_market_depth ( self , instrument ) \u00b6 Fetch the market depth Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_zerodha.py 129 130 131 132 133 134 135 136 137 138 139 140 141 def get_market_depth ( self , instrument : Instrument ): \"\"\" Fetch the market depth Args: instrument: Financial Instrument Returns: market depth value \"\"\" quote = self . get_quote ( instrument ) buy_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'buy' ]) sell_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'sell' ]) return buy_market_depth , sell_market_depth get_name ( self ) \u00b6 Fetch the name of the broker Returns: Type Description name of the broker Source code in pyalgotrading/broker/broker_connection_zerodha.py 44 45 46 47 48 49 50 def get_name ( self ): \"\"\" Fetch the name of the broker Returns: name of the broker \"\"\" return 'ZERODHA' get_open_price_day ( self , instrument ) \u00b6 Fetch the open price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 235 236 237 238 239 240 241 242 243 244 245 246 def get_open_price_day ( self , instrument : Instrument ): \"\"\" Fetch the open price of the day Args: instrument: Financial Instrument Returns: open price value \"\"\" quote = self . get_quote ( instrument ) open_price_day = quote [ 'ohlc' ][ 'open' ] return open_price_day get_order_status ( self , order_id ) \u00b6 Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_zerodha.py 362 363 364 365 366 367 368 369 370 371 def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" return self . api . order_history ( order_id )[ - 1 ][ 'status' ] get_profile ( self ) \u00b6 Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_zerodha.py 328 329 330 331 332 333 334 def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" return self . api . profile () get_quote ( self , instrument ) \u00b6 Fetch the quote Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description quote value Source code in pyalgotrading/broker/broker_connection_zerodha.py 116 117 118 119 120 121 122 123 124 125 126 127 def get_quote ( self , instrument : Instrument ): \"\"\" Fetch the quote Args: instrument: Financial Instrument Returns: quote value \"\"\" _inst = f ' { instrument . segment } : { instrument . tradingsymbol } ' quote = self . api . quote ([ _inst ])[ _inst ] return quote get_total_pending_buy_quantity ( self , instrument ) \u00b6 Fetch the total pending buy quantity for instrument Parameters: Name Type Description Default instrument Financial Instrument required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 196 197 198 199 200 201 202 203 204 205 206 207 def get_total_pending_buy_quantity ( self , instrument ): \"\"\" Fetch the total pending buy quantity for instrument Args: instrument: Financial Instrument Returns: total quantity value \"\"\" quote = self . get_quote ( instrument ) total_buy_quantity_day = quote [ 'buy_quantity' ] return total_buy_quantity_day get_total_pending_sell_quantity ( self , instrument ) \u00b6 Fetch the total pending sell quantity for instrument Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 209 210 211 212 213 214 215 216 217 218 219 220 def get_total_pending_sell_quantity ( self , instrument : Instrument ): \"\"\" Fetch the total pending sell quantity for instrument Args: instrument: Financial Instrument Returns: total quantity value \"\"\" quote = self . get_quote ( instrument ) total_sell_quantity_day = quote [ 'sell_quantity' ] return total_sell_quantity_day get_total_volume_day ( self , instrument ) \u00b6 Fetch the total volume for the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_zerodha.py 222 223 224 225 226 227 228 229 230 231 232 233 def get_total_volume_day ( self , instrument : Instrument ): \"\"\" Fetch the total volume for the day Args: instrument: Financial Instrument Returns: total volume value \"\"\" quote = self . get_quote ( instrument ) total_volume_day = quote [ 'volume' ] return total_volume_day place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss = None , target = None , trailing_stoploss = None ) \u00b6 Place an order Parameters: Name Type Description Default instrument Financial Instrument required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss stoploss amount / value None target target amount / value None trailing_stoploss trailing stoploss amount / value None Returns: Type Description Order status Source code in pyalgotrading/broker/broker_connection_zerodha.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss = None , target = None , trailing_stoploss = None ): \"\"\" Place an order Args: instrument: Financial Instrument order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss: stoploss amount / value target: target amount / value trailing_stoploss: trailing stoploss amount / value Returns: Order status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # what we call as 'Order Type', Zerodha calls it as 'variety' _transaction_type = BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP [ order_transaction_type ] _product = BrokerConnectionZerodha . ORDER_CODE_MAP [ order_code ] # what we call as 'Order Code', Zerodha calls it as 'product' _order_type = BrokerConnectionZerodha . ORDER_VARIETY_MAP [ order_variety ] # What we call as 'Order Variety', Zerodha calls it as 'order_type' return self . api . place_order ( variety = _variety , exchange = instrument . exchange , tradingsymbol = instrument . tradingsymbol , transaction_type = _transaction_type , quantity = quantity , product = _product , order_type = _order_type , price = price , trigger_price = trigger_price , squareoff = target , stoploss = stoploss , trailing_stoploss = trailing_stoploss ) populate_constants ( self ) \u00b6 Map pyalgotrading constants to broker constants :return: None Source code in pyalgotrading/broker/broker_connection_zerodha.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def populate_constants ( self ): \"\"\" Map pyalgotrading constants to broker constants :return: None \"\"\" _ = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect==3.8.2' ) . KiteConnect BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP = { BrokerOrderTransactionTypeConstants . BUY : _ . TRANSACTION_TYPE_BUY , BrokerOrderTransactionTypeConstants . SELL : _ . TRANSACTION_TYPE_SELL } BrokerConnectionZerodha . ORDER_TYPE_MAP = { BrokerOrderTypeConstants . REGULAR : _ . VARIETY_REGULAR , BrokerOrderTypeConstants . BRACKET : _ . VARIETY_BO , BrokerOrderTypeConstants . COVER : _ . VARIETY_CO , BrokerOrderTypeConstants . AMO : _ . VARIETY_AMO } BrokerConnectionZerodha . ORDER_CODE_MAP = { BrokerOrderCodeConstants . INTRADAY : _ . PRODUCT_MIS , BrokerOrderCodeConstants . DELIVERY : _ . PRODUCT_CNC } BrokerConnectionZerodha . ORDER_VARIETY_MAP = { BrokerOrderVarietyConstants . MARKET : _ . ORDER_TYPE_MARKET , BrokerOrderVarietyConstants . LIMIT : _ . ORDER_TYPE_LIMIT , BrokerOrderVarietyConstants . STOPLOSS_LIMIT : _ . ORDER_TYPE_SL , BrokerOrderVarietyConstants . STOPLOSS_MARKET : _ . ORDER_TYPE_SLM } set_access_token ( self , request_token ) \u00b6 Sets the access token Parameters: Name Type Description Default request_token the request token required Returns: Type Description None Source code in pyalgotrading/broker/broker_connection_zerodha.py 75 76 77 78 79 80 81 82 83 84 85 def set_access_token ( self , request_token ): \"\"\" Sets the access token Args: request_token: the request token Returns: None \"\"\" data = self . api . generate_session ( request_token , api_secret = self . api_secret ) self . api . set_access_token ( data [ \"access_token\" ]) utils \u00b6 Module for calculating crossover crossover ( val1_hist , val2_hist , accuracy_decimals = 2 ) \u00b6 Computes crossover of 2 data series - val1_hist and val2_hist. Parameters: Name Type Description Default val1_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required val2_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required accuracy_decimals int Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. 2 Returns: Type Description int 1 if val1_hist(OHLC) cuts val2_hist upwards -1 if val1_hist cuts val2_hist downwards 0 if there is no cut between val1_hist and val2_hist Source code in pyalgotrading/broker/utils.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def crossover ( val1_hist : Union [ Tuple , List , pd . Series ], val2_hist : Union [ Tuple , List , pd . Series ], accuracy_decimals : int = 2 ) -> int : \"\"\" Computes crossover of 2 data series - val1_hist and val2_hist. Args: val1_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) val2_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) accuracy_decimals: Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. Returns: - `1` if `val1_hist(OHLC)` cuts `val2_hist` upwards - `-1` if `val1_hist` cuts `val2_hist` downwards - `0` if there is no cut between `val1_hist` and `val2_hist` \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"broker"},{"location":"package_broker/#pyalgotrading.broker","text":"","title":"pyalgotrading.broker"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base","text":"Base class for Broker Connection","title":"broker_connection_base"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase","text":"Base class for Broker Connection","title":"BrokerConnectionBase"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_all_instruments","text":"All instruments enlisted by the broker Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_base.py 20 21 22 23 24 25 26 27 @abstractmethod def get_all_instruments ( self ): \"\"\" All instruments enlisted by the broker Returns: list of all instruments \"\"\" raise NotImplementedError","title":"get_all_instruments()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_circuit_limits","text":"Fetch the circuit limits Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_base.py 55 56 57 58 59 60 61 62 63 64 65 66 @abstractmethod def get_circuit_limits ( self , * args , ** kwargs ): \"\"\" Fetch the circuit limits Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: circuit limit value \"\"\" raise NotImplementedError","title":"get_circuit_limits()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_close_price_last_day","text":"Fetch the closed price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_base.py 185 186 187 188 189 190 191 192 193 194 195 196 @abstractmethod def get_close_price_last_day ( self , * args , ** kwargs ): \"\"\" Fetch the closed price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: closed price value \"\"\" raise NotImplementedError","title":"get_close_price_last_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_funds","text":"Fetch the available funds Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_base.py 226 227 228 229 230 231 232 233 234 235 236 237 @abstractmethod def get_funds ( self , * args , ** kwargs ): \"\"\" Fetch the available funds Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: available funds value \"\"\" raise NotImplementedError","title":"get_funds()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_high_price_day","text":"Fetch the high price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_base.py 159 160 161 162 163 164 165 166 167 168 169 170 @abstractmethod def get_high_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the high price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: high price value \"\"\" raise NotImplementedError","title":"get_high_price_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_historical_data","text":"Fetch the historical data Parameters: Name Type Description Default instrument instrument key required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_base.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 @abstractmethod def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: instrument key candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" raise NotImplementedError","title":"get_historical_data()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_instrument","text":"Fetch a single instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description a single instrument Source code in pyalgotrading/broker/broker_connection_base.py 29 30 31 32 33 34 35 36 37 38 39 40 @abstractmethod def get_instrument ( self , * args , ** kwargs ): \"\"\" Fetch a single instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: a single instrument \"\"\" raise NotImplementedError","title":"get_instrument()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_low_price_day","text":"Fetch the low price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_base.py 172 173 174 175 176 177 178 179 180 181 182 183 @abstractmethod def get_low_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the low price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: low price value \"\"\" raise NotImplementedError","title":"get_low_price_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_ltp","text":"Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_base.py 68 69 70 71 72 73 74 75 76 77 78 79 @abstractmethod def get_ltp ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Price (LTP) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltp value \"\"\" raise NotImplementedError","title":"get_ltp()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_ltq","text":"Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_base.py 94 95 96 97 98 99 100 101 102 103 104 105 @abstractmethod def get_ltq ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltq value \"\"\" raise NotImplementedError","title":"get_ltq()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_ltt","text":"Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_base.py 81 82 83 84 85 86 87 88 89 90 91 92 @abstractmethod def get_ltt ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Time (LTT) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltt value \"\"\" raise NotImplementedError","title":"get_ltt()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_margins","text":"Fetch the margins Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_base.py 213 214 215 216 217 218 219 220 221 222 223 224 @abstractmethod def get_margins ( self , * args , ** kwargs ): \"\"\" Fetch the margins Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: margin value \"\"\" raise NotImplementedError","title":"get_margins()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_market_depth","text":"Fetch the market depth Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_base.py 42 43 44 45 46 47 48 49 50 51 52 53 @abstractmethod def get_market_depth ( self , * args , ** kwargs ): \"\"\" Fetch the market depth Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: market depth value \"\"\" raise NotImplementedError","title":"get_market_depth()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_name","text":"Name of the broker Returns: Type Description broker name Source code in pyalgotrading/broker/broker_connection_base.py 11 12 13 14 15 16 17 18 @abstractmethod def get_name ( self ): \"\"\" Name of the broker Returns: broker name \"\"\" raise NotImplementedError","title":"get_name()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_open_price_day","text":"Fetch the open price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_base.py 146 147 148 149 150 151 152 153 154 155 156 157 @abstractmethod def get_open_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the open price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: open price value \"\"\" raise NotImplementedError","title":"get_open_price_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_order_status","text":"Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_base.py 270 271 272 273 274 275 276 277 278 279 280 @abstractmethod def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" raise NotImplementedError","title":"get_order_status()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_profile","text":"Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_base.py 239 240 241 242 243 244 245 246 @abstractmethod def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" raise NotImplementedError","title":"get_profile()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_total_pending_buy_quantity","text":"Fetch the total pending buy quantity for instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 107 108 109 110 111 112 113 114 115 116 117 118 @abstractmethod def get_total_pending_buy_quantity ( self , * args , ** kwargs ): \"\"\" Fetch the total pending buy quantity for instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError","title":"get_total_pending_buy_quantity()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_total_pending_sell_quantity","text":"Fetch the total pending sell quantity for the instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 120 121 122 123 124 125 126 127 128 129 130 131 @abstractmethod def get_total_pending_sell_quantity ( self , * args , ** kwargs ): \"\"\" Fetch the total pending sell quantity for the instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError","title":"get_total_pending_sell_quantity()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_total_volume_day","text":"Fetch the total volume for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_base.py 133 134 135 136 137 138 139 140 141 142 143 144 @abstractmethod def get_total_volume_day ( self , * args , ** kwargs ): \"\"\" Fetch the total volume for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total volume value \"\"\" raise NotImplementedError","title":"get_total_volume_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.place_order","text":"Place an order Parameters: Name Type Description Default instrument instrument key required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Returns: Type Description order id Source code in pyalgotrading/broker/broker_connection_base.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 @abstractmethod def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Place an order Args: instrument: instrument key order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value Returns: order id \"\"\" raise NotImplementedError","title":"place_order()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha","text":"Module for class BrokerConnectionZerodha","title":"broker_connection_zerodha"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha","text":"class for Broker Connection Zerodha","title":"BrokerConnectionZerodha"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default api_key api key given by the broker required api_secret api secret to be used for making an authenticated connection with the broker required Source code in pyalgotrading/broker/broker_connection_zerodha.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , api_key , api_secret ): \"\"\" Init method that is used while creating an object of this class Args: api_key: api key given by the broker api_secret: api secret to be used for making an authenticated connection with the broker \"\"\" self . api_key = api_key self . api_secret = api_secret # Create kiteconnect instance kiteconnect = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect==3.8.2' ) self . api = kiteconnect . KiteConnect ( api_key = self . api_key ) # Print the login url. User will use this to login to broker site and get access token print ( f 'Please login to this link to generate your request token: { self . api . login_url () } ' ) # Create other attributes self . all_instruments = None self . populate_constants ()","title":"__init__()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.cancel_order","text":"Cancel an order Parameters: Name Type Description Default order_id order id required order_type order type required Returns: Type Description Order Status Source code in pyalgotrading/broker/broker_connection_zerodha.py 373 374 375 376 377 378 379 380 381 382 383 384 def cancel_order ( self , order_id , order_type ): \"\"\" Cancel an order Args: order_id: order id order_type: order type Returns: Order Status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # What we call as 'Order Type', Zerodha calls it as 'variety' return self . api . cancel_order ( variety = _variety , order_id = order_id )","title":"cancel_order()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_all_instruments","text":"Fetches all instruments Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_zerodha.py 87 88 89 90 91 92 93 94 def get_all_instruments ( self ): \"\"\" Fetches all instruments Returns: list of all instruments \"\"\" self . all_instruments = pd . DataFrame ( self . api . instruments ()) return self . all_instruments","title":"get_all_instruments()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_circuit_limits","text":"Fetch the circuit limits Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_zerodha.py 143 144 145 146 147 148 149 150 151 152 153 154 155 def get_circuit_limits ( self , instrument : Instrument ): \"\"\" Fetch the circuit limits Args: instrument: Financial Instrument Returns: circuit limit value \"\"\" quote = self . get_quote ( instrument ) lower_circuit_limit = quote [ 'lower_circuit_limit' ] upper_circuit_limit = quote [ 'upper_circuit_limit' ] return lower_circuit_limit , upper_circuit_limit","title":"get_circuit_limits()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_close_price_last_day","text":"Fetch the closed price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 274 275 276 277 278 279 280 281 282 283 284 285 def get_close_price_last_day ( self , instrument : Instrument ): \"\"\" Fetch the closed price of the day Args: instrument: Financial Instrument Returns: closed price value \"\"\" quote = self . get_quote ( instrument ) close_price_day = quote [ 'ohlc' ][ 'close' ] return close_price_day","title":"get_close_price_last_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_funds","text":"Fetch the available funds Parameters: Name Type Description Default segment segment required Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_zerodha.py 315 316 317 318 319 320 321 322 323 324 325 326 def get_funds ( self , segment ): \"\"\" Fetch the available funds Args: segment: segment Returns: available funds value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment )[ 'net' ]","title":"get_funds()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_high_price_day","text":"Fetch the high price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 248 249 250 251 252 253 254 255 256 257 258 259 def get_high_price_day ( self , instrument : Instrument ): \"\"\" Fetch the high price of the day Args: instrument: Financial Instrument Returns: high price value \"\"\" quote = self . get_quote ( instrument ) high_price_day = quote [ 'ohlc' ][ 'high' ] return high_price_day","title":"get_high_price_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_historical_data","text":"Fetch the historical data Parameters: Name Type Description Default instrument Financial Instrument required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_zerodha.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: Financial Instrument candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" return pd . DataFrame ( self . api . historical_data ( instrument . broker_token , from_date = start_date , to_date = end_date , interval = candle_interval )) \\ . reindex ([ 'date' , 'open' , 'high' , 'low' , 'close' , 'volume' ], axis = \"columns\" ) . rename ( columns = { 'date' : 'timestamp' })","title":"get_historical_data()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_instrument","text":"Fetch an instrument Parameters: Name Type Description Default segment str Segment to which instrument belongs to required tradingsymbol str Trading symbol of the instrument required Returns: Type Description Instrument Instrument object Source code in pyalgotrading/broker/broker_connection_zerodha.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_instrument ( self , segment : str , tradingsymbol : str ) -> Instrument : \"\"\" Fetch an instrument Args: segment: Segment to which instrument belongs to tradingsymbol: Trading symbol of the instrument Returns: Instrument object \"\"\" if self . all_instruments is None : self . all_instruments = self . get_all_instruments () try : _inst = self . all_instruments [( self . all_instruments . segment == segment ) & ( self . all_instruments . tradingsymbol == tradingsymbol )] . iloc [ 0 ] instrument = Instrument ( segment = _inst [ 'segment' ], exchange = _inst [ 'exchange' ], tradingsymbol = _inst [ 'tradingsymbol' ], broker_token = _inst [ 'instrument_token' ], tick_size = _inst [ 'tick_size' ], lot_size = _inst [ 'lot_size' ], expiry = _inst [ 'expiry' ], strike_price = _inst [ 'strike' ]) return instrument except IndexError : print ( 'ERROR: Instrument not found. Either it is expired and hence not available, or you have misspelled the \"segment\" and \"tradingsymbol\" parameters.' )","title":"get_instrument()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_low_price_day","text":"Fetch the low price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 261 262 263 264 265 266 267 268 269 270 271 272 def get_low_price_day ( self , instrument : Instrument ): \"\"\" Fetch the low price of the day Args: instrument: Financial Instrument Returns: low price value \"\"\" quote = self . get_quote ( instrument ) low_price_day = quote [ 'ohlc' ][ 'low' ] return low_price_day","title":"get_low_price_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_ltp","text":"Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_zerodha.py 157 158 159 160 161 162 163 164 165 166 167 168 def get_ltp ( self , instrument : Instrument ): \"\"\" Fetch the Last Trading Price (LTP) Args: instrument: Financial Instrument Returns: ltp value \"\"\" quote = self . get_quote ( instrument ) ltp = quote [ 'last_price' ] return ltp","title":"get_ltp()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_ltq","text":"Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default instrument Financial Instrument required Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_zerodha.py 183 184 185 186 187 188 189 190 191 192 193 194 def get_ltq ( self , instrument ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: instrument: Financial Instrument Returns: ltq value \"\"\" quote = self . get_quote ( instrument ) ltq = quote [ 'last_quantity' ] return ltq","title":"get_ltq()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_ltt","text":"Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default instrument Financial Instrument required Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_zerodha.py 170 171 172 173 174 175 176 177 178 179 180 181 def get_ltt ( self , instrument ): \"\"\" Fetch the Last Trading Time (LTT) Args: instrument: Financial Instrument Returns: ltt value \"\"\" quote = self . get_quote ( instrument ) ltt = quote [ 'last_trade_time' ] return ltt","title":"get_ltt()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_margins","text":"Fetch the margins Parameters: Name Type Description Default segment segment required Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_zerodha.py 302 303 304 305 306 307 308 309 310 311 312 313 def get_margins ( self , segment ): \"\"\" Fetch the margins Args: segment: segment Returns: margin value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment )","title":"get_margins()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_market_depth","text":"Fetch the market depth Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_zerodha.py 129 130 131 132 133 134 135 136 137 138 139 140 141 def get_market_depth ( self , instrument : Instrument ): \"\"\" Fetch the market depth Args: instrument: Financial Instrument Returns: market depth value \"\"\" quote = self . get_quote ( instrument ) buy_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'buy' ]) sell_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'sell' ]) return buy_market_depth , sell_market_depth","title":"get_market_depth()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_name","text":"Fetch the name of the broker Returns: Type Description name of the broker Source code in pyalgotrading/broker/broker_connection_zerodha.py 44 45 46 47 48 49 50 def get_name ( self ): \"\"\" Fetch the name of the broker Returns: name of the broker \"\"\" return 'ZERODHA'","title":"get_name()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_open_price_day","text":"Fetch the open price of the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 235 236 237 238 239 240 241 242 243 244 245 246 def get_open_price_day ( self , instrument : Instrument ): \"\"\" Fetch the open price of the day Args: instrument: Financial Instrument Returns: open price value \"\"\" quote = self . get_quote ( instrument ) open_price_day = quote [ 'ohlc' ][ 'open' ] return open_price_day","title":"get_open_price_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_order_status","text":"Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_zerodha.py 362 363 364 365 366 367 368 369 370 371 def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" return self . api . order_history ( order_id )[ - 1 ][ 'status' ]","title":"get_order_status()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_profile","text":"Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_zerodha.py 328 329 330 331 332 333 334 def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" return self . api . profile ()","title":"get_profile()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_quote","text":"Fetch the quote Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description quote value Source code in pyalgotrading/broker/broker_connection_zerodha.py 116 117 118 119 120 121 122 123 124 125 126 127 def get_quote ( self , instrument : Instrument ): \"\"\" Fetch the quote Args: instrument: Financial Instrument Returns: quote value \"\"\" _inst = f ' { instrument . segment } : { instrument . tradingsymbol } ' quote = self . api . quote ([ _inst ])[ _inst ] return quote","title":"get_quote()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_total_pending_buy_quantity","text":"Fetch the total pending buy quantity for instrument Parameters: Name Type Description Default instrument Financial Instrument required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 196 197 198 199 200 201 202 203 204 205 206 207 def get_total_pending_buy_quantity ( self , instrument ): \"\"\" Fetch the total pending buy quantity for instrument Args: instrument: Financial Instrument Returns: total quantity value \"\"\" quote = self . get_quote ( instrument ) total_buy_quantity_day = quote [ 'buy_quantity' ] return total_buy_quantity_day","title":"get_total_pending_buy_quantity()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_total_pending_sell_quantity","text":"Fetch the total pending sell quantity for instrument Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 209 210 211 212 213 214 215 216 217 218 219 220 def get_total_pending_sell_quantity ( self , instrument : Instrument ): \"\"\" Fetch the total pending sell quantity for instrument Args: instrument: Financial Instrument Returns: total quantity value \"\"\" quote = self . get_quote ( instrument ) total_sell_quantity_day = quote [ 'sell_quantity' ] return total_sell_quantity_day","title":"get_total_pending_sell_quantity()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_total_volume_day","text":"Fetch the total volume for the day Parameters: Name Type Description Default instrument Instrument Financial Instrument required Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_zerodha.py 222 223 224 225 226 227 228 229 230 231 232 233 def get_total_volume_day ( self , instrument : Instrument ): \"\"\" Fetch the total volume for the day Args: instrument: Financial Instrument Returns: total volume value \"\"\" quote = self . get_quote ( instrument ) total_volume_day = quote [ 'volume' ] return total_volume_day","title":"get_total_volume_day()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.place_order","text":"Place an order Parameters: Name Type Description Default instrument Financial Instrument required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss stoploss amount / value None target target amount / value None trailing_stoploss trailing stoploss amount / value None Returns: Type Description Order status Source code in pyalgotrading/broker/broker_connection_zerodha.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss = None , target = None , trailing_stoploss = None ): \"\"\" Place an order Args: instrument: Financial Instrument order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss: stoploss amount / value target: target amount / value trailing_stoploss: trailing stoploss amount / value Returns: Order status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # what we call as 'Order Type', Zerodha calls it as 'variety' _transaction_type = BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP [ order_transaction_type ] _product = BrokerConnectionZerodha . ORDER_CODE_MAP [ order_code ] # what we call as 'Order Code', Zerodha calls it as 'product' _order_type = BrokerConnectionZerodha . ORDER_VARIETY_MAP [ order_variety ] # What we call as 'Order Variety', Zerodha calls it as 'order_type' return self . api . place_order ( variety = _variety , exchange = instrument . exchange , tradingsymbol = instrument . tradingsymbol , transaction_type = _transaction_type , quantity = quantity , product = _product , order_type = _order_type , price = price , trigger_price = trigger_price , squareoff = target , stoploss = stoploss , trailing_stoploss = trailing_stoploss )","title":"place_order()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.populate_constants","text":"Map pyalgotrading constants to broker constants :return: None Source code in pyalgotrading/broker/broker_connection_zerodha.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def populate_constants ( self ): \"\"\" Map pyalgotrading constants to broker constants :return: None \"\"\" _ = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect==3.8.2' ) . KiteConnect BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP = { BrokerOrderTransactionTypeConstants . BUY : _ . TRANSACTION_TYPE_BUY , BrokerOrderTransactionTypeConstants . SELL : _ . TRANSACTION_TYPE_SELL } BrokerConnectionZerodha . ORDER_TYPE_MAP = { BrokerOrderTypeConstants . REGULAR : _ . VARIETY_REGULAR , BrokerOrderTypeConstants . BRACKET : _ . VARIETY_BO , BrokerOrderTypeConstants . COVER : _ . VARIETY_CO , BrokerOrderTypeConstants . AMO : _ . VARIETY_AMO } BrokerConnectionZerodha . ORDER_CODE_MAP = { BrokerOrderCodeConstants . INTRADAY : _ . PRODUCT_MIS , BrokerOrderCodeConstants . DELIVERY : _ . PRODUCT_CNC } BrokerConnectionZerodha . ORDER_VARIETY_MAP = { BrokerOrderVarietyConstants . MARKET : _ . ORDER_TYPE_MARKET , BrokerOrderVarietyConstants . LIMIT : _ . ORDER_TYPE_LIMIT , BrokerOrderVarietyConstants . STOPLOSS_LIMIT : _ . ORDER_TYPE_SL , BrokerOrderVarietyConstants . STOPLOSS_MARKET : _ . ORDER_TYPE_SLM }","title":"populate_constants()"},{"location":"package_broker/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.set_access_token","text":"Sets the access token Parameters: Name Type Description Default request_token the request token required Returns: Type Description None Source code in pyalgotrading/broker/broker_connection_zerodha.py 75 76 77 78 79 80 81 82 83 84 85 def set_access_token ( self , request_token ): \"\"\" Sets the access token Args: request_token: the request token Returns: None \"\"\" data = self . api . generate_session ( request_token , api_secret = self . api_secret ) self . api . set_access_token ( data [ \"access_token\" ])","title":"set_access_token()"},{"location":"package_broker/#pyalgotrading.broker.utils","text":"Module for calculating crossover","title":"utils"},{"location":"package_broker/#pyalgotrading.broker.utils.crossover","text":"Computes crossover of 2 data series - val1_hist and val2_hist. Parameters: Name Type Description Default val1_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required val2_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required accuracy_decimals int Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. 2 Returns: Type Description int 1 if val1_hist(OHLC) cuts val2_hist upwards -1 if val1_hist cuts val2_hist downwards 0 if there is no cut between val1_hist and val2_hist Source code in pyalgotrading/broker/utils.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def crossover ( val1_hist : Union [ Tuple , List , pd . Series ], val2_hist : Union [ Tuple , List , pd . Series ], accuracy_decimals : int = 2 ) -> int : \"\"\" Computes crossover of 2 data series - val1_hist and val2_hist. Args: val1_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) val2_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) accuracy_decimals: Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. Returns: - `1` if `val1_hist(OHLC)` cuts `val2_hist` upwards - `-1` if `val1_hist` cuts `val2_hist` downwards - `0` if there is no cut between `val1_hist` and `val2_hist` \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"crossover()"},{"location":"package_instrument/","text":"\u00b6 instrument \u00b6 Instrument Class Instrument \u00b6 Instrument Class __init__ ( self , segment , exchange , tradingsymbol , broker_token , tick_size , lot_size , expiry = None , strike_price = None ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default segment segment required exchange exchange required tradingsymbol trading symbol required broker_token alphnumeric token required tick_size tick size required lot_size lot size required expiry expiry date None strike_price strike amount / value None Source code in pyalgotrading/instrument/instrument.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def __init__ ( self , segment , exchange , tradingsymbol , broker_token , tick_size , lot_size , expiry = None , strike_price = None ): \"\"\" Init method that is used while creating an object of this class Args: segment: segment exchange: exchange tradingsymbol: trading symbol broker_token: alphnumeric token tick_size: tick size lot_size: lot size expiry: expiry date strike_price: strike amount / value \"\"\" self . segment = segment self . exchange = exchange self . tradingsymbol = tradingsymbol self . broker_token = broker_token self . tick_size = tick_size self . lot_size = lot_size self . expiry = expiry self . strike_price = strike_price is_expired ( self ) \u00b6 Returns whether expired or not Returns: Type Description bool True or False Source code in pyalgotrading/instrument/instrument.py 42 43 44 45 46 47 48 def is_expired ( self ) -> bool : \"\"\" Returns whether expired or not Returns: True or False \"\"\" return date . today () > self . expiry if self . will_expire () else False will_expire ( self ) \u00b6 Returns expiry details Returns: Type Description bool a value containing the expiry date Source code in pyalgotrading/instrument/instrument.py 34 35 36 37 38 39 40 def will_expire ( self ) -> bool : \"\"\" Returns expiry details Returns: a value containing the expiry date \"\"\" return ( self . expiry is not None ) and ( self . expiry != '' )","title":"instrument"},{"location":"package_instrument/#pyalgotrading.instrument","text":"","title":"pyalgotrading.instrument"},{"location":"package_instrument/#pyalgotrading.instrument.instrument","text":"Instrument Class","title":"instrument"},{"location":"package_instrument/#pyalgotrading.instrument.instrument.Instrument","text":"Instrument Class","title":"Instrument"},{"location":"package_instrument/#pyalgotrading.instrument.instrument.Instrument.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default segment segment required exchange exchange required tradingsymbol trading symbol required broker_token alphnumeric token required tick_size tick size required lot_size lot size required expiry expiry date None strike_price strike amount / value None Source code in pyalgotrading/instrument/instrument.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def __init__ ( self , segment , exchange , tradingsymbol , broker_token , tick_size , lot_size , expiry = None , strike_price = None ): \"\"\" Init method that is used while creating an object of this class Args: segment: segment exchange: exchange tradingsymbol: trading symbol broker_token: alphnumeric token tick_size: tick size lot_size: lot size expiry: expiry date strike_price: strike amount / value \"\"\" self . segment = segment self . exchange = exchange self . tradingsymbol = tradingsymbol self . broker_token = broker_token self . tick_size = tick_size self . lot_size = lot_size self . expiry = expiry self . strike_price = strike_price","title":"__init__()"},{"location":"package_instrument/#pyalgotrading.instrument.instrument.Instrument.is_expired","text":"Returns whether expired or not Returns: Type Description bool True or False Source code in pyalgotrading/instrument/instrument.py 42 43 44 45 46 47 48 def is_expired ( self ) -> bool : \"\"\" Returns whether expired or not Returns: True or False \"\"\" return date . today () > self . expiry if self . will_expire () else False","title":"is_expired()"},{"location":"package_instrument/#pyalgotrading.instrument.instrument.Instrument.will_expire","text":"Returns expiry details Returns: Type Description bool a value containing the expiry date Source code in pyalgotrading/instrument/instrument.py 34 35 36 37 38 39 40 def will_expire ( self ) -> bool : \"\"\" Returns expiry details Returns: a value containing the expiry date \"\"\" return ( self . expiry is not None ) and ( self . expiry != '' )","title":"will_expire()"},{"location":"package_order/","text":"\u00b6 order_base \u00b6 OrderBase \u00b6 Base class for Regular Order / Bracket Order cancel_order ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 32 33 34 35 36 37 38 39 def cancel_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass exit_position ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 23 24 25 26 27 28 29 30 def exit_position ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass get_order_status ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 14 15 16 17 18 19 20 21 def get_order_status ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass place_order ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 5 6 7 8 9 10 11 12 def place_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass order_bracket_base \u00b6 Class for Bracket Order BuyOrderBracket \u00b6 Class for Bracket Order Buy __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 53 54 55 56 57 58 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger ) OrderBracketBase \u00b6 Class for Bracket Order __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code bracket order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Source code in pyalgotrading/order/order_bracket_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: bracket order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_BRACKET self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price self . target_trigger = target_trigger self . stoploss_trigger = stoploss_trigger self . trailing_stoploss_trigger = trailing_stoploss_trigger is_closed ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: Type Description True / False Source code in pyalgotrading/order/order_bracket_base.py 39 40 41 42 43 44 45 46 def is_closed ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: True / False \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass SellOrderBracket \u00b6 Class for Bracket Order Sell __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 65 66 67 68 69 70 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger ) order_regular_base \u00b6 Class for Regular Order BuyOrderRegular \u00b6 Class for Regular Order Buy __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 38 39 40 41 42 43 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price ) OrderRegularBase \u00b6 Class for Regular Order __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code regular order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None Source code in pyalgotrading/order/order_regular_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: regular order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_REGULAR self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price SellOrderRegular \u00b6 Class for Regular Order Buy __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 50 51 52 53 54 55 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price )","title":"order"},{"location":"package_order/#pyalgotrading.order","text":"","title":"pyalgotrading.order"},{"location":"package_order/#pyalgotrading.order.order_base","text":"","title":"order_base"},{"location":"package_order/#pyalgotrading.order.order_base.OrderBase","text":"Base class for Regular Order / Bracket Order","title":"OrderBase"},{"location":"package_order/#pyalgotrading.order.order_base.OrderBase.cancel_order","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 32 33 34 35 36 37 38 39 def cancel_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"cancel_order()"},{"location":"package_order/#pyalgotrading.order.order_base.OrderBase.exit_position","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 23 24 25 26 27 28 29 30 def exit_position ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"exit_position()"},{"location":"package_order/#pyalgotrading.order.order_base.OrderBase.get_order_status","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 14 15 16 17 18 19 20 21 def get_order_status ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"get_order_status()"},{"location":"package_order/#pyalgotrading.order.order_base.OrderBase.place_order","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 5 6 7 8 9 10 11 12 def place_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"place_order()"},{"location":"package_order/#pyalgotrading.order.order_bracket_base","text":"Class for Bracket Order","title":"order_bracket_base"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.BuyOrderBracket","text":"Class for Bracket Order Buy","title":"BuyOrderBracket"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.BuyOrderBracket.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 53 54 55 56 57 58 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger )","title":"__init__()"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.OrderBracketBase","text":"Class for Bracket Order","title":"OrderBracketBase"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.OrderBracketBase.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code bracket order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Source code in pyalgotrading/order/order_bracket_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: bracket order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_BRACKET self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price self . target_trigger = target_trigger self . stoploss_trigger = stoploss_trigger self . trailing_stoploss_trigger = trailing_stoploss_trigger","title":"__init__()"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.OrderBracketBase.is_closed","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: Type Description True / False Source code in pyalgotrading/order/order_bracket_base.py 39 40 41 42 43 44 45 46 def is_closed ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: True / False \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"is_closed()"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.SellOrderBracket","text":"Class for Bracket Order Sell","title":"SellOrderBracket"},{"location":"package_order/#pyalgotrading.order.order_bracket_base.SellOrderBracket.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 65 66 67 68 69 70 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger )","title":"__init__()"},{"location":"package_order/#pyalgotrading.order.order_regular_base","text":"Class for Regular Order","title":"order_regular_base"},{"location":"package_order/#pyalgotrading.order.order_regular_base.BuyOrderRegular","text":"Class for Regular Order Buy","title":"BuyOrderRegular"},{"location":"package_order/#pyalgotrading.order.order_regular_base.BuyOrderRegular.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 38 39 40 41 42 43 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price )","title":"__init__()"},{"location":"package_order/#pyalgotrading.order.order_regular_base.OrderRegularBase","text":"Class for Regular Order","title":"OrderRegularBase"},{"location":"package_order/#pyalgotrading.order.order_regular_base.OrderRegularBase.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code regular order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None Source code in pyalgotrading/order/order_regular_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: regular order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_REGULAR self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price","title":"__init__()"},{"location":"package_order/#pyalgotrading.order.order_regular_base.SellOrderRegular","text":"Class for Regular Order Buy","title":"SellOrderRegular"},{"location":"package_order/#pyalgotrading.order.order_regular_base.SellOrderRegular.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 50 51 52 53 54 55 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price )","title":"__init__()"},{"location":"package_strategy/","text":"\u00b6 strategy_base \u00b6 StrategyBase \u00b6 Dummy placeholder class. Here to ensure all required methods are implemented and as per requirements. Once uploaded, this strategy will be replaced with the real base class strategy __init__ ( self , * args , ** kwargs ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Source code in pyalgotrading/strategy/strategy_base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args , ** kwargs ): \"\"\" Init method that is used while creating an object of this class Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list \"\"\" # Dummy attributes self . strategy_parameters = defaultdict ( lambda : 'dummy' ) self . broker = broker . broker_connection_base . BrokerConnectionBase () self . utils = broker . utils # Dummy Order Attributes self . BuyOrderRegular = BuyOrderRegular self . SellOrderRegular = SellOrderRegular self . BuyOrderBracket = BuyOrderBracket self . SellOrderBracket = SellOrderBracket # Dummy strategy config attributes self . strategy_mode = StrategyMode . INTRADAY # <Type: Enum of type StrategyMode; This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.> self . number_of_lots = 1 # <Type: This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.> get_historical_data ( self , instrument ) \u00b6 Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Parameters: Name Type Description Default instrument instrument key required Returns: Type Description None Source code in pyalgotrading/strategy/strategy_base.py 52 53 54 55 56 57 58 59 60 61 62 63 def get_historical_data ( self , instrument ): \"\"\" Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Args: instrument: instrument key Returns: None \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass initialize ( self ) \u00b6 Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. Source code in pyalgotrading/strategy/strategy_base.py 74 75 76 77 78 79 80 81 82 83 @abstractmethod def initialize ( self ): \"\"\" Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. \"\"\" raise NotImplementedError name () staticmethod \u00b6 Name of the strategy Returns: None Source code in pyalgotrading/strategy/strategy_base.py 42 43 44 45 46 47 48 49 50 @staticmethod @abstractmethod def name (): \"\"\" Name of the strategy Returns: None \"\"\" raise NotImplementedError strategy_enter_position ( self , candle , instrument , sideband_info ) \u00b6 Enter position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description the order, if position is entered Source code in pyalgotrading/strategy/strategy_base.py 97 98 99 100 101 102 103 104 105 106 107 108 109 @abstractmethod def strategy_enter_position ( self , candle , instrument , sideband_info ): \"\"\" Enter position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: the order, if position is entered \"\"\" raise NotImplementedError strategy_exit_position ( self , candle , instrument , sideband_info ) \u00b6 Exit position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description True if order is exited else False Source code in pyalgotrading/strategy/strategy_base.py 124 125 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def strategy_exit_position ( self , candle , instrument , sideband_info ): \"\"\" Exit position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: True if order is exited else False \"\"\" raise NotImplementedError strategy_select_instruments_for_entry ( self , candle , instruments_bucket ) \u00b6 Select instruments for entry here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 85 86 87 88 89 90 91 92 93 94 95 def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): \"\"\" Select instruments for entry here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError strategy_select_instruments_for_exit ( self , candle , instruments_bucket ) \u00b6 Select instruments for exit here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 111 112 113 114 115 116 117 118 119 120 121 122 @abstractmethod def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): \"\"\" Select instruments for exit here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError versions_supported () staticmethod \u00b6 Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully Source code in pyalgotrading/strategy/strategy_base.py 65 66 67 68 69 70 71 72 @staticmethod @abstractmethod def versions_supported (): \"\"\" Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully \"\"\" raise NotImplementedError validate_strategy \u00b6 A module in construction. Create class which validates the strategy - 1. Ensures all methods are implemented and all looks good 2. Basic sanity checks Add additional information - 1. Add a versioning information in the class automatically","title":"strategy"},{"location":"package_strategy/#pyalgotrading.strategy","text":"","title":"pyalgotrading.strategy"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base","text":"","title":"strategy_base"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase","text":"Dummy placeholder class. Here to ensure all required methods are implemented and as per requirements. Once uploaded, this strategy will be replaced with the real base class strategy","title":"StrategyBase"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Source code in pyalgotrading/strategy/strategy_base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args , ** kwargs ): \"\"\" Init method that is used while creating an object of this class Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list \"\"\" # Dummy attributes self . strategy_parameters = defaultdict ( lambda : 'dummy' ) self . broker = broker . broker_connection_base . BrokerConnectionBase () self . utils = broker . utils # Dummy Order Attributes self . BuyOrderRegular = BuyOrderRegular self . SellOrderRegular = SellOrderRegular self . BuyOrderBracket = BuyOrderBracket self . SellOrderBracket = SellOrderBracket # Dummy strategy config attributes self . strategy_mode = StrategyMode . INTRADAY # <Type: Enum of type StrategyMode; This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.> self . number_of_lots = 1 # <Type: This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.>","title":"__init__()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.get_historical_data","text":"Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Parameters: Name Type Description Default instrument instrument key required Returns: Type Description None Source code in pyalgotrading/strategy/strategy_base.py 52 53 54 55 56 57 58 59 60 61 62 63 def get_historical_data ( self , instrument ): \"\"\" Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Args: instrument: instrument key Returns: None \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"get_historical_data()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.initialize","text":"Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. Source code in pyalgotrading/strategy/strategy_base.py 74 75 76 77 78 79 80 81 82 83 @abstractmethod def initialize ( self ): \"\"\" Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. \"\"\" raise NotImplementedError","title":"initialize()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.name","text":"Name of the strategy Returns: None Source code in pyalgotrading/strategy/strategy_base.py 42 43 44 45 46 47 48 49 50 @staticmethod @abstractmethod def name (): \"\"\" Name of the strategy Returns: None \"\"\" raise NotImplementedError","title":"name()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_enter_position","text":"Enter position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description the order, if position is entered Source code in pyalgotrading/strategy/strategy_base.py 97 98 99 100 101 102 103 104 105 106 107 108 109 @abstractmethod def strategy_enter_position ( self , candle , instrument , sideband_info ): \"\"\" Enter position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: the order, if position is entered \"\"\" raise NotImplementedError","title":"strategy_enter_position()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_exit_position","text":"Exit position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description True if order is exited else False Source code in pyalgotrading/strategy/strategy_base.py 124 125 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def strategy_exit_position ( self , candle , instrument , sideband_info ): \"\"\" Exit position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: True if order is exited else False \"\"\" raise NotImplementedError","title":"strategy_exit_position()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_select_instruments_for_entry","text":"Select instruments for entry here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 85 86 87 88 89 90 91 92 93 94 95 def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): \"\"\" Select instruments for entry here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError","title":"strategy_select_instruments_for_entry()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_select_instruments_for_exit","text":"Select instruments for exit here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 111 112 113 114 115 116 117 118 119 120 121 122 @abstractmethod def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): \"\"\" Select instruments for exit here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError","title":"strategy_select_instruments_for_exit()"},{"location":"package_strategy/#pyalgotrading.strategy.strategy_base.StrategyBase.versions_supported","text":"Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully Source code in pyalgotrading/strategy/strategy_base.py 65 66 67 68 69 70 71 72 @staticmethod @abstractmethod def versions_supported (): \"\"\" Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully \"\"\" raise NotImplementedError","title":"versions_supported()"},{"location":"package_strategy/#pyalgotrading.strategy.validate_strategy","text":"A module in construction. Create class which validates the strategy - 1. Ensures all methods are implemented and all looks good 2. Basic sanity checks Add additional information - 1. Add a versioning information in the class automatically","title":"validate_strategy"},{"location":"package_utils/","text":"\u00b6 candlesticks special \u00b6 Handy functions for computing various candlesticks patterns from OHLC data heikinashi \u00b6 HeikinAshi ( japanese_data , ohlc = ( 'timestamp' , 'open' , 'high' , 'low' , 'close' )) \u00b6 Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Parameters: Name Type Description Default japanese_data DataFrame Pandas DataFrame holding Japanese Candlesticks Pattern Data required ohlc tuple Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively ('timestamp', 'open', 'high', 'low', 'close') Returns: Type Description HeikinAshi Candlesticks Pattern data Source code in pyalgotrading/utils/candlesticks/heikinashi.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def HeikinAshi ( japanese_data : pd . DataFrame , ohlc : tuple = ( 'timestamp' , 'open' , 'high' , 'low' , 'close' )): \"\"\" Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Args: japanese_data: Pandas DataFrame holding Japanese Candlesticks Pattern Data ohlc: Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively Returns: HeikinAshi Candlesticks Pattern data \"\"\" if not len ( ohlc ) >= 5 : print ( \"Argument 'ohlc' should be a tuple of 5 values corresponding to the column names in 'japanese_data' pandas DataFrame, for 'timestamp', 'open', 'high', 'low' and 'close' data respectively.\" ) ha_open = 'ha_' + ohlc [ 0 ] ha_high = 'ha_' + ohlc [ 1 ] ha_low = 'ha_' + ohlc [ 2 ] ha_close = 'ha_' + ohlc [ 3 ] japanese_data = japanese_data . copy () # make sure we don't modify the original DataFrame japanese_data [ ha_close ] = ( japanese_data [ ohlc [ 1 ]] + japanese_data [ ohlc [ 2 ]] + japanese_data [ ohlc [ 3 ]] + japanese_data [ ohlc [ 4 ]]) / 4 japanese_data [ ha_open ] = 0.0 for i in range ( 0 , len ( japanese_data )): if i == 0 : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ohlc [ 1 ]] . iat [ i ] + japanese_data [ ohlc [ 4 ]] . iat [ i ]) / 2 else : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ha_open ] . iat [ i - 1 ] + japanese_data [ ha_close ] . iat [ i - 1 ]) / 2 japanese_data [ ha_high ] = japanese_data [[ ha_open , ha_close , ohlc [ 2 ]]] . max ( axis = 1 ) japanese_data [ ha_low ] = japanese_data [[ ha_open , ha_close , ohlc [ 3 ]]] . min ( axis = 1 ) # Create separate DataFrame with the required columns only heikinashi_data = pd . DataFrame () heikinashi_data [ 'timestamp' ] = japanese_data [ 'timestamp' ] heikinashi_data [ 'open' ] = japanese_data [ ha_open ] heikinashi_data [ 'high' ] = japanese_data [ ha_high ] heikinashi_data [ 'low' ] = japanese_data [ ha_low ] heikinashi_data [ 'close' ] = japanese_data [ ha_close ] return heikinashi_data linebreak \u00b6 Linebreak ( japanese_candles ) \u00b6 Parameters: Name Type Description Default japanese_candles required Source code in pyalgotrading/utils/candlesticks/linebreak.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def Linebreak ( japanese_candles ): \"\"\" Args: japanese_candles: Returns: \"\"\" linebreak_candles = [{ 'close' : candle [ 'close' ], 'open' : candle [ 'open' ], 'timestamp' : candle [ 'timestamp' ]} for _ , candle in japanese_candles . iloc [: 3 ] . iterrows ()] for _ , candle in japanese_candles . iloc [ 3 :] . iterrows (): all_greater = all ( candle [ 'close' ] > _ for _ in [ max ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) all_lesser = all ( candle [ 'close' ] < _ for _ in [ min ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) prev_linebreak_candle = linebreak_candles [ - 1 ] if all_greater : new_linebreak_candle = { 'open' : max ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) elif all_lesser : new_linebreak_candle = { 'open' : min ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) return pd . DataFrame ( linebreak_candles ) renko \u00b6 Renko ( japanese_candles , brick_count = 2 , initial_open = None , initial_close = None ) \u00b6 Parameters: Name Type Description Default japanese_candles required brick_count 2 initial_open None initial_close None Source code in pyalgotrading/utils/candlesticks/renko.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def Renko ( japanese_candles , brick_count = 2 , initial_open = None , initial_close = None ): \"\"\" Args: japanese_candles: brick_count: initial_open: initial_close: Returns: \"\"\" if not initial_close : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] initial_close = japanese_candles . iloc [ 0 ][ 'close' ] else : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'open' ] - initial_open ) % brick_count )) initial_close = japanese_candles . iloc [ 0 ][ 'close' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'close' ] - initial_close ) % brick_count )) renko_candles = [{ 'timestamp' : japanese_candles . iloc [ 0 ][ 'timestamp' ], 'open' : initial_open , 'close' : initial_close }] prev_renko_candle = renko_candles [ - 1 ] for _ , candle in japanese_candles . iloc [ 1 :] . iterrows (): max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) if candle [ 'close' ] > max_open_close : number_of_renko_candles = math . floor (( candle [ 'close' ] - max_open_close ) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : max_open_close , 'close' : max_open_close + brick_count }) prev_renko_candle = renko_candles [ - 1 ] max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) elif candle [ 'close' ] < min_open_close : number_of_renko_candles = math . floor (( min_open_close - candle [ 'close' ]) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : min_open_close , 'close' : min_open_close - brick_count }) prev_renko_candle = renko_candles [ - 1 ] min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) return pd . DataFrame ( renko_candles ) func \u00b6 A module for plotting candlesticks import_with_install ( package_import_name , package_install_name = None , dependancies = ()) \u00b6 Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Parameters: Name Type Description Default package_import_name name of package to be installed using pip, str required package_install_name name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. None dependancies list of python packages to be installed as additional dependencies' () Returns: Type Description The imported package Source code in pyalgotrading/utils/func.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def import_with_install ( package_import_name , package_install_name = None , dependancies = ()): \"\"\" Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Args: package_import_name: name of package to be installed using pip, str package_install_name: name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. dependancies: list of python packages to be installed as additional dependencies' Returns: The imported package \"\"\" package_install_name = package_install_name if package_install_name is not None else package_import_name try : return __import__ ( package_import_name ) except ImportError : print ( f \"Installing package { package_import_name } via pip. This may take a while...\" ) import subprocess import sys cmd_list = [ sys . executable , '-m' , 'pip' , 'install' , package_install_name ] if dependancies : cmd_list . extend ( dependancies ) subprocess . check_call ( cmd_list ) return __import__ ( package_import_name ) plot_candlesticks_chart ( data , plot_type , caption = '' , hide_missing_dates = False , show = True , indicators = (), plot_indicators_separately = False , plot_height = 500 , plot_width = 1000 ) \u00b6 Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Parameters: Name Type Description Default data DataFrame Pandas DataFrame with columns timestamp , open , 'high , 'low , close required plot_type PlotType Enum of type PlotType required caption str Caption for the chart '' hide_missing_dates bool If True, missing dates in the data (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. False show bool If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks True indicators tuple Indicator data to be displayed () plot_indicators_separately bool If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range False plot_height int Plot height in pixels 500 plot_width int Plot width in pixels 1000 Source code in pyalgotrading/utils/func.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def plot_candlesticks_chart ( data : pd . DataFrame , plot_type : PlotType , caption : str = '' , hide_missing_dates : bool = False , show : bool = True , indicators : tuple = (), plot_indicators_separately : bool = False , plot_height : int = 500 , plot_width : int = 1000 ): \"\"\" Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Args: data: Pandas DataFrame with columns `timestamp`, `open`, 'high`, 'low`, `close` plot_type: Enum of type PlotType caption: Caption for the chart hide_missing_dates: If True, missing dates in the `data` (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. show: If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks indicators: Indicator data to be displayed plot_indicators_separately: If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range plot_height: Plot height in pixels plot_width: Plot width in pixels \"\"\" import_with_install ( package_import_name = 'plotly' , package_install_name = 'plotly==4.9.0' , dependancies = [ 'notebook>=5.3' , 'ipywidgets==7.5' , 'psutil' ]) # Plotly requirements taken from here: https://pypi.org/project/plotly/ from plotly.subplots import make_subplots from plotly import graph_objects as go # Sanity checks if not isinstance ( plot_type , PlotType ): print ( f 'Error: plot_type should be an instance of { PlotType . __class__ } ' ) return # Plot if plot_type is PlotType . QUANDL_JAPANESE : data [ 'timestamp' ] = data . index if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. The below code gives # custom timestamp formatting, which will be the x-axis ticks format_timestamp = lambda x : x . strftime ( \" %d /%m %H:%M\" ) timestamps = data [ 'timestamp' ] . apply ( format_timestamp ) else : timestamps = data [ 'timestamp' ] candlesticks_data_subplot_row_index = 1 candlesticks_data_subplot_col_index = 1 if indicators and ( plot_indicators_separately is True ): fig = make_subplots ( rows = 3 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True , specs = [[{ \"rowspan\" : 2 }], [{}], [{}]]) indicator_subplot_row_index = 3 indicator_subplot_col_index = 1 else : fig = make_subplots ( rows = 1 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True ) indicator_subplot_row_index = 1 indicator_subplot_col_index = 1 if plot_type in [ PlotType . JAPANESE , PlotType . HEIKINASHI ]: fig . append_trace ( go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [ 'high' ], low = data [ 'low' ], close = data [ 'close' ], name = 'Historical Data' ), row = candlesticks_data_subplot_row_index , col = candlesticks_data_subplot_col_index ) elif plot_type == PlotType . LINEBREAK : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . RENKO : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . QUANDL_JAPANESE : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'Open' ], high = data [ 'High' ], low = data [ 'Low' ], close = data [ 'Close' ], name = 'Historical Data' )]) else : print ( f 'Error: plot_type ( { plot_type } ) is not implemented yet' ) return for indicator in indicators : indicator_name = indicator [ 'name' ] indicator_data = indicator [ 'data' ] extra = indicator [ 'extra' ] if 'extra' in indicator else {} fig . add_trace ( go . Scatter ( x = timestamps , y = indicator_data , name = indicator_name , ** extra ), row = indicator_subplot_row_index , col = indicator_subplot_col_index ) # Plot customization if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. Hence, the below fix fig . layout . xaxis . type = 'category' fig . update ( layout_xaxis_rangeslider_visible = False ) fig . update_layout ( title = { 'text' : caption , 'y' : 0.9 , 'x' : 0.5 , 'xanchor' : 'center' , 'yanchor' : 'bottom' }, height = plot_height , width = plot_width ) # Show the plot if show : fig . show ()","title":"utils"},{"location":"package_utils/#pyalgotrading.utils","text":"","title":"pyalgotrading.utils"},{"location":"package_utils/#pyalgotrading.utils.candlesticks","text":"Handy functions for computing various candlesticks patterns from OHLC data","title":"candlesticks"},{"location":"package_utils/#pyalgotrading.utils.candlesticks.heikinashi","text":"","title":"heikinashi"},{"location":"package_utils/#pyalgotrading.utils.candlesticks.heikinashi.HeikinAshi","text":"Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Parameters: Name Type Description Default japanese_data DataFrame Pandas DataFrame holding Japanese Candlesticks Pattern Data required ohlc tuple Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively ('timestamp', 'open', 'high', 'low', 'close') Returns: Type Description HeikinAshi Candlesticks Pattern data Source code in pyalgotrading/utils/candlesticks/heikinashi.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def HeikinAshi ( japanese_data : pd . DataFrame , ohlc : tuple = ( 'timestamp' , 'open' , 'high' , 'low' , 'close' )): \"\"\" Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Args: japanese_data: Pandas DataFrame holding Japanese Candlesticks Pattern Data ohlc: Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively Returns: HeikinAshi Candlesticks Pattern data \"\"\" if not len ( ohlc ) >= 5 : print ( \"Argument 'ohlc' should be a tuple of 5 values corresponding to the column names in 'japanese_data' pandas DataFrame, for 'timestamp', 'open', 'high', 'low' and 'close' data respectively.\" ) ha_open = 'ha_' + ohlc [ 0 ] ha_high = 'ha_' + ohlc [ 1 ] ha_low = 'ha_' + ohlc [ 2 ] ha_close = 'ha_' + ohlc [ 3 ] japanese_data = japanese_data . copy () # make sure we don't modify the original DataFrame japanese_data [ ha_close ] = ( japanese_data [ ohlc [ 1 ]] + japanese_data [ ohlc [ 2 ]] + japanese_data [ ohlc [ 3 ]] + japanese_data [ ohlc [ 4 ]]) / 4 japanese_data [ ha_open ] = 0.0 for i in range ( 0 , len ( japanese_data )): if i == 0 : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ohlc [ 1 ]] . iat [ i ] + japanese_data [ ohlc [ 4 ]] . iat [ i ]) / 2 else : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ha_open ] . iat [ i - 1 ] + japanese_data [ ha_close ] . iat [ i - 1 ]) / 2 japanese_data [ ha_high ] = japanese_data [[ ha_open , ha_close , ohlc [ 2 ]]] . max ( axis = 1 ) japanese_data [ ha_low ] = japanese_data [[ ha_open , ha_close , ohlc [ 3 ]]] . min ( axis = 1 ) # Create separate DataFrame with the required columns only heikinashi_data = pd . DataFrame () heikinashi_data [ 'timestamp' ] = japanese_data [ 'timestamp' ] heikinashi_data [ 'open' ] = japanese_data [ ha_open ] heikinashi_data [ 'high' ] = japanese_data [ ha_high ] heikinashi_data [ 'low' ] = japanese_data [ ha_low ] heikinashi_data [ 'close' ] = japanese_data [ ha_close ] return heikinashi_data","title":"HeikinAshi()"},{"location":"package_utils/#pyalgotrading.utils.candlesticks.linebreak","text":"","title":"linebreak"},{"location":"package_utils/#pyalgotrading.utils.candlesticks.linebreak.Linebreak","text":"Parameters: Name Type Description Default japanese_candles required Source code in pyalgotrading/utils/candlesticks/linebreak.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def Linebreak ( japanese_candles ): \"\"\" Args: japanese_candles: Returns: \"\"\" linebreak_candles = [{ 'close' : candle [ 'close' ], 'open' : candle [ 'open' ], 'timestamp' : candle [ 'timestamp' ]} for _ , candle in japanese_candles . iloc [: 3 ] . iterrows ()] for _ , candle in japanese_candles . iloc [ 3 :] . iterrows (): all_greater = all ( candle [ 'close' ] > _ for _ in [ max ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) all_lesser = all ( candle [ 'close' ] < _ for _ in [ min ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) prev_linebreak_candle = linebreak_candles [ - 1 ] if all_greater : new_linebreak_candle = { 'open' : max ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) elif all_lesser : new_linebreak_candle = { 'open' : min ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) return pd . DataFrame ( linebreak_candles )","title":"Linebreak()"},{"location":"package_utils/#pyalgotrading.utils.candlesticks.renko","text":"","title":"renko"},{"location":"package_utils/#pyalgotrading.utils.candlesticks.renko.Renko","text":"Parameters: Name Type Description Default japanese_candles required brick_count 2 initial_open None initial_close None Source code in pyalgotrading/utils/candlesticks/renko.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def Renko ( japanese_candles , brick_count = 2 , initial_open = None , initial_close = None ): \"\"\" Args: japanese_candles: brick_count: initial_open: initial_close: Returns: \"\"\" if not initial_close : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] initial_close = japanese_candles . iloc [ 0 ][ 'close' ] else : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'open' ] - initial_open ) % brick_count )) initial_close = japanese_candles . iloc [ 0 ][ 'close' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'close' ] - initial_close ) % brick_count )) renko_candles = [{ 'timestamp' : japanese_candles . iloc [ 0 ][ 'timestamp' ], 'open' : initial_open , 'close' : initial_close }] prev_renko_candle = renko_candles [ - 1 ] for _ , candle in japanese_candles . iloc [ 1 :] . iterrows (): max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) if candle [ 'close' ] > max_open_close : number_of_renko_candles = math . floor (( candle [ 'close' ] - max_open_close ) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : max_open_close , 'close' : max_open_close + brick_count }) prev_renko_candle = renko_candles [ - 1 ] max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) elif candle [ 'close' ] < min_open_close : number_of_renko_candles = math . floor (( min_open_close - candle [ 'close' ]) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : min_open_close , 'close' : min_open_close - brick_count }) prev_renko_candle = renko_candles [ - 1 ] min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) return pd . DataFrame ( renko_candles )","title":"Renko()"},{"location":"package_utils/#pyalgotrading.utils.func","text":"A module for plotting candlesticks","title":"func"},{"location":"package_utils/#pyalgotrading.utils.func.import_with_install","text":"Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Parameters: Name Type Description Default package_import_name name of package to be installed using pip, str required package_install_name name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. None dependancies list of python packages to be installed as additional dependencies' () Returns: Type Description The imported package Source code in pyalgotrading/utils/func.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def import_with_install ( package_import_name , package_install_name = None , dependancies = ()): \"\"\" Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Args: package_import_name: name of package to be installed using pip, str package_install_name: name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. dependancies: list of python packages to be installed as additional dependencies' Returns: The imported package \"\"\" package_install_name = package_install_name if package_install_name is not None else package_import_name try : return __import__ ( package_import_name ) except ImportError : print ( f \"Installing package { package_import_name } via pip. This may take a while...\" ) import subprocess import sys cmd_list = [ sys . executable , '-m' , 'pip' , 'install' , package_install_name ] if dependancies : cmd_list . extend ( dependancies ) subprocess . check_call ( cmd_list ) return __import__ ( package_import_name )","title":"import_with_install()"},{"location":"package_utils/#pyalgotrading.utils.func.plot_candlesticks_chart","text":"Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Parameters: Name Type Description Default data DataFrame Pandas DataFrame with columns timestamp , open , 'high , 'low , close required plot_type PlotType Enum of type PlotType required caption str Caption for the chart '' hide_missing_dates bool If True, missing dates in the data (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. False show bool If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks True indicators tuple Indicator data to be displayed () plot_indicators_separately bool If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range False plot_height int Plot height in pixels 500 plot_width int Plot width in pixels 1000 Source code in pyalgotrading/utils/func.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def plot_candlesticks_chart ( data : pd . DataFrame , plot_type : PlotType , caption : str = '' , hide_missing_dates : bool = False , show : bool = True , indicators : tuple = (), plot_indicators_separately : bool = False , plot_height : int = 500 , plot_width : int = 1000 ): \"\"\" Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Args: data: Pandas DataFrame with columns `timestamp`, `open`, 'high`, 'low`, `close` plot_type: Enum of type PlotType caption: Caption for the chart hide_missing_dates: If True, missing dates in the `data` (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. show: If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks indicators: Indicator data to be displayed plot_indicators_separately: If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range plot_height: Plot height in pixels plot_width: Plot width in pixels \"\"\" import_with_install ( package_import_name = 'plotly' , package_install_name = 'plotly==4.9.0' , dependancies = [ 'notebook>=5.3' , 'ipywidgets==7.5' , 'psutil' ]) # Plotly requirements taken from here: https://pypi.org/project/plotly/ from plotly.subplots import make_subplots from plotly import graph_objects as go # Sanity checks if not isinstance ( plot_type , PlotType ): print ( f 'Error: plot_type should be an instance of { PlotType . __class__ } ' ) return # Plot if plot_type is PlotType . QUANDL_JAPANESE : data [ 'timestamp' ] = data . index if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. The below code gives # custom timestamp formatting, which will be the x-axis ticks format_timestamp = lambda x : x . strftime ( \" %d /%m %H:%M\" ) timestamps = data [ 'timestamp' ] . apply ( format_timestamp ) else : timestamps = data [ 'timestamp' ] candlesticks_data_subplot_row_index = 1 candlesticks_data_subplot_col_index = 1 if indicators and ( plot_indicators_separately is True ): fig = make_subplots ( rows = 3 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True , specs = [[{ \"rowspan\" : 2 }], [{}], [{}]]) indicator_subplot_row_index = 3 indicator_subplot_col_index = 1 else : fig = make_subplots ( rows = 1 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True ) indicator_subplot_row_index = 1 indicator_subplot_col_index = 1 if plot_type in [ PlotType . JAPANESE , PlotType . HEIKINASHI ]: fig . append_trace ( go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [ 'high' ], low = data [ 'low' ], close = data [ 'close' ], name = 'Historical Data' ), row = candlesticks_data_subplot_row_index , col = candlesticks_data_subplot_col_index ) elif plot_type == PlotType . LINEBREAK : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . RENKO : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . QUANDL_JAPANESE : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'Open' ], high = data [ 'High' ], low = data [ 'Low' ], close = data [ 'Close' ], name = 'Historical Data' )]) else : print ( f 'Error: plot_type ( { plot_type } ) is not implemented yet' ) return for indicator in indicators : indicator_name = indicator [ 'name' ] indicator_data = indicator [ 'data' ] extra = indicator [ 'extra' ] if 'extra' in indicator else {} fig . add_trace ( go . Scatter ( x = timestamps , y = indicator_data , name = indicator_name , ** extra ), row = indicator_subplot_row_index , col = indicator_subplot_col_index ) # Plot customization if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. Hence, the below fix fig . layout . xaxis . type = 'category' fig . update ( layout_xaxis_rangeslider_visible = False ) fig . update_layout ( title = { 'text' : caption , 'y' : 0.9 , 'x' : 0.5 , 'xanchor' : 'center' , 'yanchor' : 'bottom' }, height = plot_height , width = plot_width ) # Show the plot if show : fig . show ()","title":"plot_candlesticks_chart()"},{"location":"prerequisites/","text":"You will need the following to perform this tutorial: Algobulls Account ( Link ) - You will need this account to upload and test your strategies. The account needs to be setup with the proper risk managmenet values and a binded broker before any trades can be excecuted. Make sure the account is properly setup or contact Algobulls Support for any help. Python 3.7+ ( Link ) - The AlgoBulls platform can run all strategies that conform to Python 3.7 and above. A Python IDE of your choice, like Pycharm ( Link ) - As mentioned in the [Introduction], this tutorial will demonstrate the pyalgotrading package by implementing the Simple Moving Average Crossover Strategy for Regular Orders. You will make this strategy as a separate python file, and the PyCharm Community Edition IDE is enough for this purpose. If you are already using a Python IDE of your choice, you may skip this step. TA-Lib Package ( Link ) - This package encompasses all Technical Indicators used in Technical Analysis by strategists. You will need this package to compute Moving Average (SMA) for the example. pyalgotrading Package ( Link ) - This package has all the necessary classes to create strategies. For the SMA strategy, you will subclass your class from the StrategyBase class which is present in this package. Jupyter Notebook ( Link ) - You will use a Jupyter Notebook to connect to the AlgoBulls platform. You will upload the strategy, test your strategy (Backtest, Paper Trade, Real Trade), and fetch logs using the notebook. Note It is a good idea to setup a virtual environment first Install Python 3.7+ Once Python is installed, most packages are easily installed in your venv using pip install command pip install TA-Lib pip install pyalgotrading pip install jupyterlab","title":"Prerequisites"},{"location":"programexample/","text":"Create a python file called strategy_sma_regular_order.py . You will add the following code snippets into the file and then save it. Import the following \u00b6 from pyalgotrading.strategy.strategy_base import StrategyBase from pyalgotrading.constants import * Create the class StrategySMARegularOrder and subclass it from StrategyBase \u00b6 class StrategySMARegularOrder ( StrategyBase ): Now you can add the methods mentioned in the structure inside the class. First you can add the __init__ and the initialize methods. Init method \u00b6 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . timeperiod_x = self . strategy_parameters [ 'timeperiod1' ] self . timeperiod_y = self . strategy_parameters [ 'timeperiod2' ] self . main_order = None The init method does the following: super() - Calls the constructor of the superclass. self.strategy_parameters - Catches the parameters and saves them for local use - When you will submit a testing job for your SMA strategy, you will pass parameters that will be used inside the strategy. For SMA, we are calculating crossover for 2 SMA timeperiod values, example 5 and 12. These 2 parameters will be caught by self.strategy_parameters and stored for local use in self.timeperiod1 and self.timeperiod2 . self.main_order - Create an object that manages orders for you throughout the strategy. The init method is specific to Python's internal workings and it is preceded and succeeded by double underscores ( _ _ ) joined together. Initialize method \u00b6 def initialize ( self ): self . main_order = {} The initialize method sets the self.main_order as an empty dictionary. This method is called at the start of every trading day. For instance, say you are submitting a backtesting job for 5 previous days starting at 10:30 everyday, then the initialize method will be called everyday for 5 days at 10:30. Now add the two static methods, name and versions_supprted . Name method \u00b6 @staticmethod def name (): return 'SMA Regular Order Strategy' The name should be unique in your collection of strategies. Versions Suported \u00b6 @staticmethod def versions_supported (): return AlgoBullsEngineVersion . VERSION_3_2_0 Mark both the above methods as @staticmethod . The versions_supported method does the following: It notifies the AlgoBulls platform that the strategy is working correctly for the platform version 3.2.0 Since the platform will be constantly upgraded to incorporate new features and improve efficiency, the verion may change. If the version changes, and if you submit a job for this strategy, then the AlgoBulls platform will spawn a server having version 3.2.0 for your strategy. Having this method ensures that the AlgoBulls platform always provides the correct environment for your strategy. Select Instruments for Entry \u00b6 def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): selected_instruments_bucket = [] sideband_info_bucket = [] for instrument in instruments_bucket : crossover_value = self . get_crossover_value ( instrument ) if crossover_value == 1 : selected_instruments_bucket . append ( instrument ) sideband_info_bucket . append ({ 'action' : 'BUY' }) elif crossover_value == - 1 : if self . strategy_mode is StrategyMode . INTRADAY : selected_instruments_bucket . append ( instrument ) sideband_info_bucket . append ({ 'action' : 'SELL' }) return selected_instruments_bucket , sideband_info_bucket The strategy_select_instruments_for_entry method does the following: selected_instruments_bucket and sideband_info_bucket - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (while submitting the job) and will decide whether to set an entry position or not for it. crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If conditions - If the crossover value is 1, then the instrument is selected for entry position, with the position as 'BUY'. If the crossover value is -1, then the instrument is selected for entry position, with the position as 'SELL'. The selected instrument is appended to the selected_instruments_bucket , and the associated action (BUY/SELL) is appended to the sideband_info_bucket . selected_instruments_bucket and sideband_info_bucket - Both the lists (whether populated or empty) are returned to the platform for further actions. Note SELL Entry positions are allowed only if the strategy is running for INTRADAY. DELIVERY strategies do not allow SELL as entry positions. This is taken care of in the elif part. The strategy_select_instruments_for_entry method is called once for every candle time. For Instance, if you submit a job with the candle time as 15 minutes, then this method will be called once for every 15 minute candle. The actual Entry position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the sideband_info_bucket . The Entry position will be taken in the next method below. The sideband_info_bucket contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. Entry Position for each (Selected) Instrument \u00b6 def strategy_enter_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'BUY' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . BuyOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) elif sideband_info [ 'action' ] == 'SELL' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . SellOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) else : raise SystemExit ( f 'Got invalid sideband_info value: { sideband_info } ' ) return self . main_order [ instrument ] The strategy_enter_position method does the following: If conditions - The conditions read the action from the sideband_info and perform the required action (BUY/SELL). qty - The quantity is calculated and stored here. The number of lots will be passed by you as a parameter while submitting a job. The parameter will be caught in self.number_of_lots . The instrument object has the lot size, which you can retrieve using instrument.lot_size . You can then use the formula as shown in the code to calculate the quantity. BuyOrderRegular and SellOrderRegular - These execute the required action. You need the pass the instrument, order code, order variety and the quantity values. instrument - the instrument on which the BUY/SELL action will be performed. order_code - whether the order is for INTRADAY or DELIVERY. Possible values are: BrokerOrderCodeConstants.INTRADAY BrokerOrderCodeConstants.DELIVERY BrokerOrderCodeConstants.DELIVERY_T1 BrokerOrderCodeConstants.DELIVERY_T2 order_variety - the type of order variety. Possible values are: BrokerOrderVarietyConstants.MARKET BrokerOrderVarietyConstants.LIMIT BrokerOrderVarietyConstants.STOPLOSS_MARKET BrokerOrderVarietyConstants.STOPLOSS_LIMIT qty - the quantity to BUY/SELL. self.main_order - The main order (for that particular instrument) is now populated (BUY OR SELL) and is returned to the platform for further actions. You can also punch Bracket Orders instead of Regular Orders. A typical BUY Bracket Order will look like this: qty = self . number_of_lots * instrument . lot_size ltp = self . broker . get_ltp ( instrument ) self . main_order [ instrument ] = \\ self . broker . BuyOrderBracket ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . LIMIT , quantity = qty , price = ltp , stoploss_trigger = ltp - ( ltp * self . stoploss ), target_trigger = ltp + ( ltp * self . target ), trailing_stoploss_trigger = ltp * self . trailing_stoploss ) The additional parameters are: price - If you want to BUY at the market price (Last Traded Price) or LTP, then just fetch the LTP using get_ltp as shown in the code above. Store the value in ltp and pass it to price . stoploss_trigger , target_trigger and trailing_stoploss_trigger - You can calculate these using the ltp and the values you will pass through the job that you will submit. The parameters will be caught as self.stoploss , self.target and self.trailing_stoploss . Note If you plan to use Bracket Order instead of Regular Orders, then create a separate Python file for it, say strategy_sma_bracket_order.py . You can also change the class name as StrategySMABracketOrder . There will be changes in the entry and exit methods also. The strategy_enter_position method is called once for every instrument. For instance, you want to run this strategy for 5 instruments. Say that the strategy_select_instruments_for_entry method selects 3 instruments for ENTRY positions (BUY/SELL). Then, the strategy_enter_position method will be called thrice, once for each instrument respectively within the candle time frame (say, 15 minutes). Select Instruments for Exit \u00b6 def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): selected_instruments_bucket = [] sideband_info_bucket = [] for instrument in instruments_bucket : if self . main_order . get ( instrument ) is not None : crossover_value = self . get_crossover_value ( instrument ) if crossover_value in [ 1 , - 1 ]: selected_instruments_bucket . append ( instrument ) sideband_info_bucket . append ({ 'action' : 'EXIT' }) return selected_instruments_bucket , sideband_info_bucket The strategy_select_instruments_for_exit method does the following: selected_instruments_bucket and sideband_info_bucket - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (which are in Entry position (BUY/SELL)) and will decide whether to set an exit position or not for it. If condition - The exit steps are executed only if the instrument is holding at an ENTRY position (BUY/SELL). You can do this by checking if the self.main_order object is None or not, and proceed only if it is not None . crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If condition - If the crossover value is 1 or -1, then the instrument is selected for exit position. The selected instrument is appended to the selected_instruments_bucket , and the associated action (EXIT) is appended to the sideband_info_bucket . selected_instruments_bucket and sideband_info_bucket - Both the lists (whether populated or empty) are returned to the platform for further actions. Note The actual Exit position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the sideband_info_bucket . The Exit position will be taken in the next method below. The sideband_info_bucket contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. Whenever a new trading day starts, the strategy_select_instruments_for_exit is called first. This is very important for DELIVERY strategies. Many instruments might be holding in an Entry Position at the end of the previous trading day, and they might be eligible for exit at the start of the new trading day. Exit Position for each (Selected) Instrument \u00b6 def strategy_exit_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'EXIT' : self . main_order [ instrument ] . exit_position () self . main_order [ instrument ] = None return True return False The strategy_exit_position method does the following: If condition - checks whether the appropriate action is set in the sideband_info . self.main_order - calls exit_position method for the particular main order of the instrument. If the Entry Position was BUY, then the exit position is automatically taken as SELL and vice versa. The platform takes care of this automatically. self.main_order - set it to None , as the order has been exited and no longer holds anything. Return values - returns True to the platform if the exit steps were performed, else return False . Crossover function \u00b6 def get_crossover_value ( self , instrument ): hist_data = self . get_historical_data ( instrument ) sma_x = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_x ) sma_y = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_y ) crossover_value = self . utils . crossover ( sma_x , sma_y ) return crossover_value The get_crossover_value method does the following: hist_data - The historical data for the instrument is fetched using the get_historical_data method and stored here. The data is in the form of a table (Pandas DataFrame) having the follwing columns: timestamp - the data and time when the datawas measured volume - the volume of that instrument open , high , low and close - the OHLC values of the intrument oi - the Open Interest of that instrument sma_x and sma_y - the SMA function from the talib package is used to calculate the Moving Average for both SMA timeperiods. The candle close value is used for calculations, i.e. hist_data['close'] . crossover_value - calculates the crossover value using the crossover method from the utils package. Return value - return the crossover value to the caller method. Note The order of values passed to the crossover method of the utils package is very important. For instance, you have 2 SMA values, 5 and 12, and the strategy describes that there should be an BUY Entry Position when SMA(5) cuts SMA(12) upwards (crossover value should be 1). In this case, if you mistakenly pass SMA(12) value first and SMA(5) value next to the crossover function, the answer you will get is -1 (Cut downwards). This is correct but the strategy will not take the BUY Entry Position as it is expecting the value of 1 (Cut Upwards) to take that position. Therefore, the strategy will work correctly only if you pass SMA(5) first and then SMA(12).","title":"Program Example"},{"location":"programexample/#import-the-following","text":"from pyalgotrading.strategy.strategy_base import StrategyBase from pyalgotrading.constants import *","title":"Import the following"},{"location":"programexample/#create-the-class-strategysmaregularorder-and-subclass-it-from-strategybase","text":"class StrategySMARegularOrder ( StrategyBase ): Now you can add the methods mentioned in the structure inside the class. First you can add the __init__ and the initialize methods.","title":"Create the class StrategySMARegularOrder and subclass it from StrategyBase"},{"location":"programexample/#init-method","text":"def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . timeperiod_x = self . strategy_parameters [ 'timeperiod1' ] self . timeperiod_y = self . strategy_parameters [ 'timeperiod2' ] self . main_order = None The init method does the following: super() - Calls the constructor of the superclass. self.strategy_parameters - Catches the parameters and saves them for local use - When you will submit a testing job for your SMA strategy, you will pass parameters that will be used inside the strategy. For SMA, we are calculating crossover for 2 SMA timeperiod values, example 5 and 12. These 2 parameters will be caught by self.strategy_parameters and stored for local use in self.timeperiod1 and self.timeperiod2 . self.main_order - Create an object that manages orders for you throughout the strategy. The init method is specific to Python's internal workings and it is preceded and succeeded by double underscores ( _ _ ) joined together.","title":"Init method"},{"location":"programexample/#initialize-method","text":"def initialize ( self ): self . main_order = {} The initialize method sets the self.main_order as an empty dictionary. This method is called at the start of every trading day. For instance, say you are submitting a backtesting job for 5 previous days starting at 10:30 everyday, then the initialize method will be called everyday for 5 days at 10:30. Now add the two static methods, name and versions_supprted .","title":"Initialize method"},{"location":"programexample/#name-method","text":"@staticmethod def name (): return 'SMA Regular Order Strategy' The name should be unique in your collection of strategies.","title":"Name method"},{"location":"programexample/#versions-suported","text":"@staticmethod def versions_supported (): return AlgoBullsEngineVersion . VERSION_3_2_0 Mark both the above methods as @staticmethod . The versions_supported method does the following: It notifies the AlgoBulls platform that the strategy is working correctly for the platform version 3.2.0 Since the platform will be constantly upgraded to incorporate new features and improve efficiency, the verion may change. If the version changes, and if you submit a job for this strategy, then the AlgoBulls platform will spawn a server having version 3.2.0 for your strategy. Having this method ensures that the AlgoBulls platform always provides the correct environment for your strategy.","title":"Versions Suported"},{"location":"programexample/#select-instruments-for-entry","text":"def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): selected_instruments_bucket = [] sideband_info_bucket = [] for instrument in instruments_bucket : crossover_value = self . get_crossover_value ( instrument ) if crossover_value == 1 : selected_instruments_bucket . append ( instrument ) sideband_info_bucket . append ({ 'action' : 'BUY' }) elif crossover_value == - 1 : if self . strategy_mode is StrategyMode . INTRADAY : selected_instruments_bucket . append ( instrument ) sideband_info_bucket . append ({ 'action' : 'SELL' }) return selected_instruments_bucket , sideband_info_bucket The strategy_select_instruments_for_entry method does the following: selected_instruments_bucket and sideband_info_bucket - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (while submitting the job) and will decide whether to set an entry position or not for it. crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If conditions - If the crossover value is 1, then the instrument is selected for entry position, with the position as 'BUY'. If the crossover value is -1, then the instrument is selected for entry position, with the position as 'SELL'. The selected instrument is appended to the selected_instruments_bucket , and the associated action (BUY/SELL) is appended to the sideband_info_bucket . selected_instruments_bucket and sideband_info_bucket - Both the lists (whether populated or empty) are returned to the platform for further actions. Note SELL Entry positions are allowed only if the strategy is running for INTRADAY. DELIVERY strategies do not allow SELL as entry positions. This is taken care of in the elif part. The strategy_select_instruments_for_entry method is called once for every candle time. For Instance, if you submit a job with the candle time as 15 minutes, then this method will be called once for every 15 minute candle. The actual Entry position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the sideband_info_bucket . The Entry position will be taken in the next method below. The sideband_info_bucket contains a very versatile dictionary object. You may use it to pass any other additional information that you wish.","title":"Select Instruments for Entry"},{"location":"programexample/#entry-position-for-each-selected-instrument","text":"def strategy_enter_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'BUY' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . BuyOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) elif sideband_info [ 'action' ] == 'SELL' : qty = self . number_of_lots * instrument . lot_size self . main_order [ instrument ] = \\ self . broker . SellOrderRegular ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . MARKET , quantity = qty ) else : raise SystemExit ( f 'Got invalid sideband_info value: { sideband_info } ' ) return self . main_order [ instrument ] The strategy_enter_position method does the following: If conditions - The conditions read the action from the sideband_info and perform the required action (BUY/SELL). qty - The quantity is calculated and stored here. The number of lots will be passed by you as a parameter while submitting a job. The parameter will be caught in self.number_of_lots . The instrument object has the lot size, which you can retrieve using instrument.lot_size . You can then use the formula as shown in the code to calculate the quantity. BuyOrderRegular and SellOrderRegular - These execute the required action. You need the pass the instrument, order code, order variety and the quantity values. instrument - the instrument on which the BUY/SELL action will be performed. order_code - whether the order is for INTRADAY or DELIVERY. Possible values are: BrokerOrderCodeConstants.INTRADAY BrokerOrderCodeConstants.DELIVERY BrokerOrderCodeConstants.DELIVERY_T1 BrokerOrderCodeConstants.DELIVERY_T2 order_variety - the type of order variety. Possible values are: BrokerOrderVarietyConstants.MARKET BrokerOrderVarietyConstants.LIMIT BrokerOrderVarietyConstants.STOPLOSS_MARKET BrokerOrderVarietyConstants.STOPLOSS_LIMIT qty - the quantity to BUY/SELL. self.main_order - The main order (for that particular instrument) is now populated (BUY OR SELL) and is returned to the platform for further actions. You can also punch Bracket Orders instead of Regular Orders. A typical BUY Bracket Order will look like this: qty = self . number_of_lots * instrument . lot_size ltp = self . broker . get_ltp ( instrument ) self . main_order [ instrument ] = \\ self . broker . BuyOrderBracket ( instrument = instrument , order_code = BrokerOrderCodeConstants . INTRADAY , order_variety = BrokerOrderVarietyConstants . LIMIT , quantity = qty , price = ltp , stoploss_trigger = ltp - ( ltp * self . stoploss ), target_trigger = ltp + ( ltp * self . target ), trailing_stoploss_trigger = ltp * self . trailing_stoploss ) The additional parameters are: price - If you want to BUY at the market price (Last Traded Price) or LTP, then just fetch the LTP using get_ltp as shown in the code above. Store the value in ltp and pass it to price . stoploss_trigger , target_trigger and trailing_stoploss_trigger - You can calculate these using the ltp and the values you will pass through the job that you will submit. The parameters will be caught as self.stoploss , self.target and self.trailing_stoploss . Note If you plan to use Bracket Order instead of Regular Orders, then create a separate Python file for it, say strategy_sma_bracket_order.py . You can also change the class name as StrategySMABracketOrder . There will be changes in the entry and exit methods also. The strategy_enter_position method is called once for every instrument. For instance, you want to run this strategy for 5 instruments. Say that the strategy_select_instruments_for_entry method selects 3 instruments for ENTRY positions (BUY/SELL). Then, the strategy_enter_position method will be called thrice, once for each instrument respectively within the candle time frame (say, 15 minutes).","title":"Entry Position for each (Selected) Instrument"},{"location":"programexample/#select-instruments-for-exit","text":"def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): selected_instruments_bucket = [] sideband_info_bucket = [] for instrument in instruments_bucket : if self . main_order . get ( instrument ) is not None : crossover_value = self . get_crossover_value ( instrument ) if crossover_value in [ 1 , - 1 ]: selected_instruments_bucket . append ( instrument ) sideband_info_bucket . append ({ 'action' : 'EXIT' }) return selected_instruments_bucket , sideband_info_bucket The strategy_select_instruments_for_exit method does the following: selected_instruments_bucket and sideband_info_bucket - Creates 2 empty lists that will be used to pass the selected instruments and additional information about them respectively. The Loop - The loop will iterate over each instrument name passed (which are in Entry position (BUY/SELL)) and will decide whether to set an exit position or not for it. If condition - The exit steps are executed only if the instrument is holding at an ENTRY position (BUY/SELL). You can do this by checking if the self.main_order object is None or not, and proceed only if it is not None . crossover_value - The crossover value is calculated and stored here. Crossover values are interpreted as: Value 1 - Cut upwards Value -1 - Cut downwards Value 0 - No crossover If condition - If the crossover value is 1 or -1, then the instrument is selected for exit position. The selected instrument is appended to the selected_instruments_bucket , and the associated action (EXIT) is appended to the sideband_info_bucket . selected_instruments_bucket and sideband_info_bucket - Both the lists (whether populated or empty) are returned to the platform for further actions. Note The actual Exit position (BUY/SELL) is not entered here. Here, only the instrument is selected based on the crossover value with the proper action mentioned in the sideband_info_bucket . The Exit position will be taken in the next method below. The sideband_info_bucket contains a very versatile dictionary object. You may use it to pass any other additional information that you wish. Whenever a new trading day starts, the strategy_select_instruments_for_exit is called first. This is very important for DELIVERY strategies. Many instruments might be holding in an Entry Position at the end of the previous trading day, and they might be eligible for exit at the start of the new trading day.","title":"Select Instruments for Exit"},{"location":"programexample/#exit-position-for-each-selected-instrument","text":"def strategy_exit_position ( self , candle , instrument , sideband_info ): if sideband_info [ 'action' ] == 'EXIT' : self . main_order [ instrument ] . exit_position () self . main_order [ instrument ] = None return True return False The strategy_exit_position method does the following: If condition - checks whether the appropriate action is set in the sideband_info . self.main_order - calls exit_position method for the particular main order of the instrument. If the Entry Position was BUY, then the exit position is automatically taken as SELL and vice versa. The platform takes care of this automatically. self.main_order - set it to None , as the order has been exited and no longer holds anything. Return values - returns True to the platform if the exit steps were performed, else return False .","title":"Exit Position for each (Selected) Instrument"},{"location":"programexample/#crossover-function","text":"def get_crossover_value ( self , instrument ): hist_data = self . get_historical_data ( instrument ) sma_x = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_x ) sma_y = talib . SMA ( hist_data [ 'close' ], timeperiod = self . timeperiod_y ) crossover_value = self . utils . crossover ( sma_x , sma_y ) return crossover_value The get_crossover_value method does the following: hist_data - The historical data for the instrument is fetched using the get_historical_data method and stored here. The data is in the form of a table (Pandas DataFrame) having the follwing columns: timestamp - the data and time when the datawas measured volume - the volume of that instrument open , high , low and close - the OHLC values of the intrument oi - the Open Interest of that instrument sma_x and sma_y - the SMA function from the talib package is used to calculate the Moving Average for both SMA timeperiods. The candle close value is used for calculations, i.e. hist_data['close'] . crossover_value - calculates the crossover value using the crossover method from the utils package. Return value - return the crossover value to the caller method. Note The order of values passed to the crossover method of the utils package is very important. For instance, you have 2 SMA values, 5 and 12, and the strategy describes that there should be an BUY Entry Position when SMA(5) cuts SMA(12) upwards (crossover value should be 1). In this case, if you mistakenly pass SMA(12) value first and SMA(5) value next to the crossover function, the answer you will get is -1 (Cut downwards). This is correct but the strategy will not take the BUY Entry Position as it is expecting the value of 1 (Cut Upwards) to take that position. Therefore, the strategy will work correctly only if you pass SMA(5) first and then SMA(12).","title":"Crossover function"},{"location":"structure/","text":"You have the following methods: strategy_select_instruments_for_entry(self, candle, instruments_bucket) - A method to select instruments for entry strategy_enter_position(self, candle, instrument, sideband_info) - A method to set enter positions for each selected instrument strategy_select_instruments_for_exit(self, candle, instruments_bucket) - A method to select instruments for exit strategy_exit_position(self, candle, instrument, sideband_info) - A method to set exit positions for each selected instrument You have the following supporting methods: __init__(self, *args, **kwargs) - A method called init which is called when the strategy starts for the first time initialize(self) - A method called initialise which is called when the strategy starts for the first time as well as the start of every trading day name() - A method which sets a unique name for your strategy versions_supported() - A method which sets the version of Algobulls Platform on which this strategy is certified tested successfully by you You have the following strategy specific method: get_crossover_value(self, instrument) - A method which calculates the crossover value The flowchart is as follows:","title":"Basic Structure"},{"location":"testing/","text":"Once the SMA Strategy is uploaded successfully, you can now perform Backtesting, Paper Trading and Real Trading on it. You can open a Jupyter Notebook. The steps you will follow are: Establish a connection to the AlgoBulls Platform. Display all Strategies you have in your account. Select the SMA strategy. Optionally, print the strategy once. Select instrument(s). Submit/Run a Backtest, Paper Trade or Real Trade job. Check Job Status. Fetch Logs (even while the job is running). Fetch Reports. (PnL, Statistics, Order History) You will run the following code snippets into the notebook one by one (or all together). Import the following \u00b6 from pyalgotrading.algobulls import AlgoBullsConnection from datetime import datetime as dt from pyalgotrading.constants import * Now you will establish a connection to the Algobulls Platform. You will need to login to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options Establish a connection to the AlgoBulls Platform \u00b6 algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () # The output of the above step is: # Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login # Set the access token in the next line of code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) Display all strategies in your account \u00b6 all_strategies = algobulls_connection . get_all_strategies () all_strategies An example of the output wil be: In this case, we will seelct the last entry of the column strategyCode and display it. Select the SMA strategy \u00b6 strategy_code1 = all_strategies . iloc [ - 1 ][ 'strategyCode' ] strategy_code1 You can print your strategy code once to verify if this is the correct code. Print your Strategy code \u00b6 strategy_details1 = algobulls_connection . get_strategy_details ( strategy_code1 ) print ( strategy_details1 ) Now display some instruments and select one of them. Search for instruments (based on a search query) \u00b6 instruments = algobulls_connection . search_instrument ( 'SBIN' ) instruments Select the first one for this example. Select an instrument \u00b6 instrument = instruments [ 0 ][ 'value' ] instrument Submit a Job \u00b6 Backtesting algobulls_connection . backtest ( strategy_code = strategy_code1 , start_timestamp = dt ( year = 2020 , month = 7 , day = 1 , hour = 9 , minute = 15 ), end_timestamp = dt ( year = 2020 , month = 7 , day = 7 , hour = 15 , minute = 30 ), instrument = instrument , lots = 1 , strategy_parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 }, candle_interval = CandleInterval . MINUTES_15 ) Paper Trading algobulls_connection . papertrade ( strategy_code = strategy_code1 , start_time = time ( hour = 9 , minute = 15 ), end_time = time ( hour = 23 , minute = 30 ), instrument = instrument , lots = 1 , strategy_parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 }, candle_interval = CandleInterval . MINUTES_15 ) Real Trading algobulls_connection . realtrade ( strategy_code = strategy_code1 , start_time = time ( hour = 9 , minute = 15 ), end_time = time ( hour = 15 , minute = 30 ), instrument = instrument , lots = 1 , strategy_parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 }, candle_interval = CandleInterval . MINUTES_1 ) Fetch Job Status \u00b6 Backtesting algobulls_connection . get_backtesting_job_status ( strategy_code1 ) Paper Trading algobulls_connection . get_papertrading_job_status ( strategy_code1 ) Real Trading algobulls_connection . get_realtrading_job_status ( strategy_code = strategy_code1 ) You can stop a submitted job anytime. Stop a Job \u00b6 Backtesting algobulls_connection . stop_backtesting_job ( strategy_code1 ) Paper Trading algobulls_connection . stop_papertrading_job ( strategy_code1 ) Real Trading algobulls_connection . stop_realtrading_job ( strategy_code = strategy_code1 ) You can fetch the logs in the middle of a job to mnoitor the progress. Fetch logs of an ongoing/stopped/completed job \u00b6 Backtesting logs = algobulls_connection . get_backtesting_logs ( strategy_code1 ) print ( logs ) Paper Trading logs = algobulls_connection . get_papertrading_logs ( strategy_code1 ) print ( logs ) Real Trading logs = algobulls_connection . get_realtrading_logs ( strategy_code = strategy_code1 ) print ( logs ) You can fetch the PnL report, statistics and order history for a job. Backtesting algobulls_connection . get_backtesting_report_pnl_table ( strategy_code1 , show_all_rows = True ) algobulls_connection . get_backtesting_report_statistics ( strategy_code1 ) order_history = algobulls_connection . get_backtesting_report_order_history ( strategy_code1 ) print ( order_history ) Paper Trading algobulls_connection . get_papertrading_report_pnl_table ( strategy_code1 ) algobulls_connection . get_papertrading_report_statistics ( strategy_code1 ) order_history = algobulls_connection . get_papertrading_report_order_history ( strategy_code1 ) print ( order_history ) Real Trading algobulls_connection . get_realtrading_report_pnl_table ( strategy_code = strategy_code1 ) algobulls_connection . get_realtrading_report_statistics ( strategy_code = strategy_code1 ) # order history is missing","title":"Testing"},{"location":"testing/#import-the-following","text":"from pyalgotrading.algobulls import AlgoBullsConnection from datetime import datetime as dt from pyalgotrading.constants import * Now you will establish a connection to the Algobulls Platform. You will need to login to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options","title":"Import the following"},{"location":"testing/#establish-a-connection-to-the-algobulls-platform","text":"algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () # The output of the above step is: # Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login # Set the access token in the next line of code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' )","title":"Establish a connection to the AlgoBulls Platform"},{"location":"testing/#display-all-strategies-in-your-account","text":"all_strategies = algobulls_connection . get_all_strategies () all_strategies An example of the output wil be: In this case, we will seelct the last entry of the column strategyCode and display it.","title":"Display all strategies in your account"},{"location":"testing/#select-the-sma-strategy","text":"strategy_code1 = all_strategies . iloc [ - 1 ][ 'strategyCode' ] strategy_code1 You can print your strategy code once to verify if this is the correct code.","title":"Select the SMA strategy"},{"location":"testing/#print-your-strategy-code","text":"strategy_details1 = algobulls_connection . get_strategy_details ( strategy_code1 ) print ( strategy_details1 ) Now display some instruments and select one of them.","title":"Print your Strategy code"},{"location":"testing/#search-for-instruments-based-on-a-search-query","text":"instruments = algobulls_connection . search_instrument ( 'SBIN' ) instruments Select the first one for this example.","title":"Search for instruments (based on a search query)"},{"location":"testing/#select-an-instrument","text":"instrument = instruments [ 0 ][ 'value' ] instrument","title":"Select an instrument"},{"location":"testing/#submit-a-job","text":"Backtesting algobulls_connection . backtest ( strategy_code = strategy_code1 , start_timestamp = dt ( year = 2020 , month = 7 , day = 1 , hour = 9 , minute = 15 ), end_timestamp = dt ( year = 2020 , month = 7 , day = 7 , hour = 15 , minute = 30 ), instrument = instrument , lots = 1 , strategy_parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 }, candle_interval = CandleInterval . MINUTES_15 ) Paper Trading algobulls_connection . papertrade ( strategy_code = strategy_code1 , start_time = time ( hour = 9 , minute = 15 ), end_time = time ( hour = 23 , minute = 30 ), instrument = instrument , lots = 1 , strategy_parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 }, candle_interval = CandleInterval . MINUTES_15 ) Real Trading algobulls_connection . realtrade ( strategy_code = strategy_code1 , start_time = time ( hour = 9 , minute = 15 ), end_time = time ( hour = 15 , minute = 30 ), instrument = instrument , lots = 1 , strategy_parameters = { 'timeperiod1' : 5 , 'timeperiod2' : 12 }, candle_interval = CandleInterval . MINUTES_1 )","title":"Submit a Job"},{"location":"testing/#fetch-job-status","text":"Backtesting algobulls_connection . get_backtesting_job_status ( strategy_code1 ) Paper Trading algobulls_connection . get_papertrading_job_status ( strategy_code1 ) Real Trading algobulls_connection . get_realtrading_job_status ( strategy_code = strategy_code1 ) You can stop a submitted job anytime.","title":"Fetch Job Status"},{"location":"testing/#stop-a-job","text":"Backtesting algobulls_connection . stop_backtesting_job ( strategy_code1 ) Paper Trading algobulls_connection . stop_papertrading_job ( strategy_code1 ) Real Trading algobulls_connection . stop_realtrading_job ( strategy_code = strategy_code1 ) You can fetch the logs in the middle of a job to mnoitor the progress.","title":"Stop a Job"},{"location":"testing/#fetch-logs-of-an-ongoingstoppedcompleted-job","text":"Backtesting logs = algobulls_connection . get_backtesting_logs ( strategy_code1 ) print ( logs ) Paper Trading logs = algobulls_connection . get_papertrading_logs ( strategy_code1 ) print ( logs ) Real Trading logs = algobulls_connection . get_realtrading_logs ( strategy_code = strategy_code1 ) print ( logs ) You can fetch the PnL report, statistics and order history for a job. Backtesting algobulls_connection . get_backtesting_report_pnl_table ( strategy_code1 , show_all_rows = True ) algobulls_connection . get_backtesting_report_statistics ( strategy_code1 ) order_history = algobulls_connection . get_backtesting_report_order_history ( strategy_code1 ) print ( order_history ) Paper Trading algobulls_connection . get_papertrading_report_pnl_table ( strategy_code1 ) algobulls_connection . get_papertrading_report_statistics ( strategy_code1 ) order_history = algobulls_connection . get_papertrading_report_order_history ( strategy_code1 ) print ( order_history ) Real Trading algobulls_connection . get_realtrading_report_pnl_table ( strategy_code = strategy_code1 ) algobulls_connection . get_realtrading_report_statistics ( strategy_code = strategy_code1 ) # order history is missing","title":"Fetch logs of an ongoing/stopped/completed job"},{"location":"upload/","text":"You can open a Jupyter Notebook. You will run the following code snippets into the notebook one by one (or all together). Import the following \u00b6 import inspect from pyalgotrading.algobulls import AlgoBullsConnection # Fetch the strategy code from the python file as shown in the next line of code here: from strategy_sma_regular_order import StrategySMARegularOrder Now you will establish a connection to the Algobulls Platform. You will need to login to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options Establish a connection to the AlgoBulls Platform \u00b6 algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () # The output of the above step is: # Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login # Set the access token in the next line of code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) You can print your strategy code once to verify if this is the correct code before uploading it to the platform. Print your Strategy code \u00b6 print ( inspect . getsource ( StrategySMARegularOrder )) Upload your Strategy \u00b6 algobulls_connection . create_strategy ( StrategySMARegularOrder ) # If you are re-uploading your strategy after some changes, then use the overwrite switch as shown here: # algobulls_connection.create_strategy(StrategySMARegularOrder, overwrite=True)","title":"Upload your Strategy"},{"location":"upload/#import-the-following","text":"import inspect from pyalgotrading.algobulls import AlgoBullsConnection # Fetch the strategy code from the python file as shown in the next line of code here: from strategy_sma_regular_order import StrategySMARegularOrder Now you will establish a connection to the Algobulls Platform. You will need to login to your AlgoBulls account and fetch the access token from: Settings -> General -> Developer Options","title":"Import the following"},{"location":"upload/#establish-a-connection-to-the-algobulls-platform","text":"algobulls_connection = AlgoBullsConnection () algobulls_connection . get_authorization_url () # The output of the above step is: # Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login # Set the access token in the next line of code as shown here: algobulls_connection . set_access_token ( '4365817b795770ea31040a21ad29c8e78b63ad88' ) You can print your strategy code once to verify if this is the correct code before uploading it to the platform.","title":"Establish a connection to the AlgoBulls Platform"},{"location":"upload/#print-your-strategy-code","text":"print ( inspect . getsource ( StrategySMARegularOrder ))","title":"Print your Strategy code"},{"location":"upload/#upload-your-strategy","text":"algobulls_connection . create_strategy ( StrategySMARegularOrder ) # If you are re-uploading your strategy after some changes, then use the overwrite switch as shown here: # algobulls_connection.create_strategy(StrategySMARegularOrder, overwrite=True)","title":"Upload your Strategy"}]}